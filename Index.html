<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор вопросов SAT</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%; /* Ensure container takes full width on smaller screens */
        }
        .section-title {
            border-bottom: 2px solid #cbd5e1; /* Light gray border */
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .question-card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0; /* Light border */
        }
        .question-passage {
            font-style: italic;
            color: #4a5568; /* Dark gray text */
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .question-text {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2d3748; /* Darker gray text */
        }
        .option-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            border-radius: 0.5rem;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 1px solid transparent; /* Default transparent border */
        }
        .option-item:hover:not(.disabled) {
            background-color: #f3f4f6; /* Light gray on hover */
        }
        .option-item.correct {
            background-color: #d1fae5; /* Light green for correct answer */
            border-color: #34d399; /* Green border */
            font-weight: 500;
        }
        .option-item.incorrect {
            background-color: #fee2e2; /* Light red for incorrect answer */
            border-color: #ef4444; /* Red border */
            font-weight: 500;
        }
        .option-item.disabled {
            pointer-events: none; /* Disable clicks */
            opacity: 0.8; /* Slightly dim disabled options */
        }
        .explanation {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #e2e8f0;
            font-size: 0.9rem;
            color: #4a5568;
            display: none; /* Hidden by default */
        }
        /* New: Style for tooltips */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #94a3b8; /* Dotted underline for tooltip words */
        }
        .tooltip-text {
            visibility: hidden;
            width: auto; /* Adjust width based on content */
            max-width: 500px; /* Increased max-width for more words */
            background-color: #333;
            color: #fff;
            text-align: left; /* Align text to left for multi-line */
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 100; /* Ensure tooltip is on top */
            bottom: 125%; /* Position above the text */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Allow text wrapping */
            word-wrap: break-word; /* Ensure long words break */
            font-size: 0.85rem;
            pointer-events: none; /* Allow clicks to pass through tooltip when not hovered */
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .login-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .login-button {
            width: 100%;
            background-color: #4299e1; /* Blue */
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #3182ce; /* Darker blue */
        }
        .error-message {
            color: #ef4444;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        /* New styles for completed tests screen */
        .completed-tests-screen {
            background-color: #f0f4f8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }
        .completed-test-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .completed-test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .completed-test-card-details {
            border-left: 4px solid #3b82f6; /* Blue border for details */
            padding-left: 1rem;
            margin-top: 1rem;
        }
        .completed-test-details-question-card {
            background-color: #f8fafc;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
        }
        .user-answer {
            font-weight: 500;
        }
        /* Style for SVG container to ensure responsiveness */
        .svg-container {
            width: 100%;
            height: auto;
            max-width: 600px; /* New: Limit max width on large screens */
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            margin-left: auto; /* New: Center the container */
            margin-right: auto; /* New: Center the container */
        }
        /* New: Style for text inside the SVG */
        .svg-container svg text {
            font-family: 'Inter', sans-serif;
            font-size: 12px; /* Set a default font size */
        }
        /* Styles for the new modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
        }
    </style>
</head>
<body>
    <div id="loginScreen" class="login-container">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">Welcome to Jaleel's Verbal SAT Question Generator</h2>
        <input type="password" id="passwordInput" class="login-input" placeholder="Введите пароль">
        <button id="loginBtn" class="login-button">Войти</button>
        <p id="loginError" class="error-message" style="display: none;">Неверный пароль. Попробуйте снова.</p>
    </div>

    <div id="appContent" class="container" style="display: none;">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Генератор вопросов SAT (Verbal Section)</h1>
        
        <div id="timerContainer" class="flex items-center justify-center mb-4 text-xl font-bold text-red-600" style="display: none;">
            <svg class="h-6 w-6 mr-2 animate-pulse" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span id="fullTestTimer"></span>
        </div>
        
        <div class="mb-6">
            <label for="difficultySelect" class="block text-gray-700 text-sm font-bold mb-2">Выберите уровень сложности:</label>
            <select id="difficultySelect" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500">
                <option value="easy">Облегченный уровень (Easier Module)</option>
                <option value="hard">Усложненный уровень (Harder Module 2)</option>
                <option value="gre_gmat">Сложный уровень (GRE/GMAT-level)</option>
            </select>
        </div>
        
        <!-- UPDATED: Moved and styled the "Exclude Topics" button -->
        <div class="mb-4">
            <button id="excludeTopicsBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
                Исключить темы
            </button>
        </div>

        <div id="categoryButtonsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <!-- Buttons for each category will be inserted here by JavaScript -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mb-4">
            <button id="fullTestBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
                Полный тест с контролем времени
            </button>
            <button id="showCompletedTestsBtn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                Завершенные тесты
            </button>
        </div>
        
        <div id="loadingIndicator" class="loading-indicator text-center" style="display: none;">
            <!-- Questions will be loaded here -->
        </div>
        
        <div id="questionsContainer" class="space-y-10">
            <!-- Questions will be loaded here -->
        </div>

        <!-- Corrected button order -->
        <div class="flex flex-col sm:flex-row justify-between gap-4 mt-4">
            <button id="nextBtn" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                Следующий вопрос
            </button>
            <button id="saveAndExitBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" style="display: none;">
                Сохранить и выйти
            </button>
        </div>
    </div>

    <div id="completedTestsScreen" class="completed-tests-screen" style="display: none;">
        <button id="backToMainBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
            &larr; Назад в главное окно
        </button>
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Завершенные тесты</h1>
        <div id="testsListContainer" class="space-y-4">
            <!-- Completed tests will be listed here -->
        </div>
        <div id="completedTestDetailsContainer" class="mt-8" style="display: none;">
            <button id="backToTestsBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
                &larr; Назад к списку тестов
            </button>
            <!-- New delete button added here -->
            <button id="deleteTestBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mb-4 ml-4 transition duration-200 ease-in-out">
                Удалить тест
            </button>
            <div id="testReviewContainer">
                <!-- Detailed test review will be displayed here -->
            </div>
        </div>
    </div>

    <!-- NEW: Exclude Topics Modal -->
    <div id="excludeTopicsModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Исключить темы</h2>
            <div class="flex items-center space-x-2 mb-4">
                <input type="text" id="topicInput" class="login-input flex-grow" placeholder="Введите тему для исключения">
                <button id="addTopicBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Добавить</button>
            </div>
            <div id="excludedTopicsList" class="space-y-2 mb-4 max-h-40 overflow-y-auto p-2 bg-gray-100 rounded-md">
                <!-- Excluded topics will be listed here -->
            </div>
            <div class="flex justify-end space-x-4">
                <button id="cancelExcludeBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Ок</button>
            </div>
        </div>
    </div>

    <script type="module">
        const apiKey = "AIzaSyB6HddnRBVrrDWv_ujKlFx7ZQST1RzvcZs";
        
        // --- Get all the DOM elements
        const loginScreen = document.getElementById('loginScreen');
        const passwordInput = document.getElementById('passwordInput');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const appContent = document.getElementById('appContent');
        const categoryButtonsContainer = document.getElementById('categoryButtonsContainer');
        const fullTestBtn = document.getElementById('fullTestBtn');
        const questionsContainer = document.getElementById('questionsContainer');
        const showCompletedTestsBtn = document.getElementById('showCompletedTestsBtn');
        const completedTestsScreen = document.getElementById('completedTestsScreen');
        const testsListContainer = document.getElementById('testsListContainer');
        const completedTestDetailsContainer = document.getElementById('completedTestDetailsContainer');
        const testReviewContainer = document.getElementById('testReviewContainer');
        const backToTestsBtn = document.getElementById('backToTestsBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const difficultySelect = document.getElementById('difficultySelect');
        const nextBtn = document.getElementById('nextBtn');
        const saveAndExitBtn = document.getElementById('saveAndExitBtn');
        const deleteTestBtn = document.getElementById('deleteTestBtn');
        const timerContainer = document.getElementById('timerContainer');
        const fullTestTimer = document.getElementById('fullTestTimer');
        
        // NEW: Exclude topics modal elements
        const excludeTopicsBtn = document.getElementById('excludeTopicsBtn');
        const excludeTopicsModal = document.getElementById('excludeTopicsModal');
        const topicInput = document.getElementById('topicInput');
        const addTopicBtn = document.getElementById('addTopicBtn');
        const excludedTopicsList = document.getElementById('excludedTopicsList');
        // FIX: Renamed variable to avoid conflict with global 'document' object
        const cancelExcludeBtnEl = document.getElementById('cancelExcludeBtn');

        const categories = {
            "Information and Ideas": "information_ideas",
            "Craft and Structure": "craft_structure",
            "Expression of Ideas": "expression_ideas",
            "Standard English Conventions": "standard_english_conventions"
        };
        const romanNumerals = ['I', 'II', 'III', 'IV'];

        // Global state to manage questions and current position
        let allGeneratedQuestions = {};
        let completedQuestions = [];
        let categoriesArray = [];
        let currentCategoryIndex = 0;
        let currentQuestionIndex = 0;
        let isSessionActive = false;
        let isFullTest = false; 
        let currentReviewingTest = null;
        let questionStartTime = 0; 

        // Hardcoded password array for client-side authentication
        const CORRECT_PASSWORDS = ["Jaleel2010", "Janiya2010", "ThirdPassword"];

        // Inactivity timer variables
        let inactivityTimer;
        const INACTIVITY_TIMEOUT = 5 * 60 * 1000;
        
        // Countdown timer variables
        let generationCountdownInterval;
        const GENERATION_COUNTDOWN_SECONDS = 90;

        // Full Test timer variables - UPDATED
        let fullTestInterval;
        const FULL_TEST_DURATION_MINUTES = 30; 
        const FULL_TEST_DURATION_SECONDS = FULL_TEST_DURATION_MINUTES * 60;
        let timeLeft = FULL_TEST_DURATION_SECONDS;
        
        // --- NEW: Function to robustly parse the API response to handle non-JSON text ---
        function parseApiResponse(text) {
            try {
                // Try to find the JSON array part of the string.
                // This regex looks for the content between the first '[' and the last ']'.
                const jsonMatch = text.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                } else {
                    // If no array is found, it might be a single JSON object.
                    const objectMatch = text.match(/\{[\s\S]*\}/);
                    if (objectMatch) {
                        return JSON.parse(objectMatch[0]);
                    }
                }
            } catch (e) {
                console.error("Failed to parse JSON even after cleaning:", e);
                throw new Error("Invalid JSON format from API.");
            }
            throw new Error("No valid JSON found in API response.");
        }

        // Function to reset the inactivity timer
        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(logoutUser, INACTIVITY_TIMEOUT);
        }

        // Function to save the current session state
        function saveSession() {
            if (Object.keys(allGeneratedQuestions).length > 0) {
                const sessionData = {
                    categoryIndex: currentCategoryIndex,
                    questionIndex: currentQuestionIndex,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value,
                    completedQuestions: completedQuestions,
                    categoriesArray: categoriesArray,
                    isFullTest: isFullTest,
                    timeLeft: timeLeft
                };
                localStorage.setItem('satQuizSession', JSON.stringify(sessionData));
                console.log('Session saved.');
            }
        }

        // Function to load a saved session state
        async function loadSession() {
            const savedSession = localStorage.getItem('satQuizSession');
            if (savedSession) {
                const sessionData = JSON.parse(savedSession);
                
                // NEW FIX: Check if the saved session is valid and has questions
                if (!sessionData || !sessionData.questions || Object.keys(sessionData.questions).length === 0) {
                    localStorage.removeItem('satQuizSession');
                    console.error("Invalid or empty session data found. Clearing session.");
                    return false;
                }

                const confirmation = await showCustomConfirm('Обнаружена незавершенная сессия. Хотите продолжить с того места, где остановились?');
                
                if (confirmation) {
                    currentCategoryIndex = sessionData.categoryIndex;
                    currentQuestionIndex = sessionData.questionIndex;
                    allGeneratedQuestions = sessionData.questions;
                    difficultySelect.value = sessionData.difficulty;
                    completedQuestions = sessionData.completedQuestions || [];
                    categoriesArray = sessionData.categoriesArray || Object.keys(categories);
                    isFullTest = sessionData.isFullTest || false;
                    timeLeft = sessionData.timeLeft || FULL_TEST_DURATION_SECONDS;
                    isSessionActive = true;
                    console.log('Session loaded. Resuming test.');
                    return true;
                } else {
                    localStorage.removeItem('satQuizSession');
                    isSessionActive = false;
                    return false;
                }
            }
            return false;
        }

        // Custom confirmation dialog (replaces alert/confirm)
        function showCustomConfirm(message) {
            return new Promise(resolve => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modalOverlay.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <p class="text-lg font-semibold mb-4">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                            <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('confirmYes').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });
                document.getElementById('confirmNo').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(false);
                });
            });
        }

        // Function to update the disabled state of the buttons
        function updateMainButtonsState(isDisabled) {
            document.querySelectorAll('#categoryButtonsContainer button').forEach(button => {
                button.disabled = isDisabled;
                button.classList.toggle('opacity-50', isDisabled);
                button.classList.toggle('cursor-not-allowed', isDisabled);
                button.classList.toggle('hover:bg-blue-700', !isDisabled);
                button.classList.toggle('hover:scale-105', !isDisabled);
            });
            fullTestBtn.disabled = isDisabled;
            fullTestBtn.classList.toggle('opacity-50', isDisabled);
            fullTestBtn.classList.toggle('cursor-not-allowed', isDisabled);
            fullTestBtn.classList.toggle('hover:bg-indigo-700', !isDisabled);
            fullTestBtn.classList.toggle('hover:scale-105', !isDisabled);
            showCompletedTestsBtn.disabled = isDisabled;
            showCompletedTestsBtn.classList.toggle('opacity-50', isDisabled);
            showCompletedTestsBtn.classList.toggle('cursor-not-allowed', isDisabled);
            showCompletedTestsBtn.classList.toggle('hover:bg-gray-600', !isDisabled);
            showCompletedTestsBtn.classList.toggle('hover:scale-105', !isDisabled);
            excludeTopicsBtn.disabled = isDisabled;
            excludeTopicsBtn.classList.toggle('opacity-50', isDisabled);
            excludeTopicsBtn.classList.toggle('cursor-not-allowed', isDisabled);
            excludeTopicsBtn.classList.toggle('hover:bg-purple-700', !isDisabled);
        }

        // Function to log out the user and reset the app state
        function logoutUser(saveCurrent = true) {
            if (saveCurrent) {
                saveSession();
            } else {
                localStorage.removeItem('satQuizSession');
            }
            
            isSessionActive = false;
            isFullTest = false;
            updateMainButtonsState(false);

            // Hide app content and show login screen
            appContent.style.display = 'none';
            loginScreen.style.display = 'block';
            passwordInput.value = '';
            loginError.style.display = 'none';

            // Reset application state
            allGeneratedQuestions = {};
            completedQuestions = [];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            currentReviewingTest = null;
            categoriesArray = [];
            questionStartTime = 0;

            // Hide all buttons that appear after login/generation
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            questionsContainer.innerHTML = '';
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            timerContainer.style.display = 'none';

            // Stop any existing timers
            clearTimeout(inactivityTimer);
            clearInterval(generationCountdownInterval);
            clearInterval(fullTestInterval);
        }

        // Event listeners for user activity to reset the timer
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        document.addEventListener('scroll', resetInactivityTimer);

        // Initial check for activity when the page loads
        resetInactivityTimer();

        // Function to generate the category buttons
        function createCategoryButtons() {
            categoryButtonsContainer.innerHTML = '';
            Object.keys(categories).forEach(categoryTitle => {
                const categoryKey = categories[categoryTitle];
                const button = document.createElement('button');
                button.id = `generateBtn-${categoryKey}`;
                button.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75';
                button.textContent = categoryTitle;
                button.addEventListener('click', () => handleNewTest(categoryKey));
                categoryButtonsContainer.appendChild(button);
            });
        }

        // Login function
        loginBtn.addEventListener('click', async () => {
            if (CORRECT_PASSWORDS.includes(passwordInput.value)) {
                loginScreen.style.display = 'none';
                appContent.style.display = 'block';
                loginError.style.display = 'none';
                
                createCategoryButtons();
                const sessionResumed = await loadSession();
                if (sessionResumed) {
                    displayCurrentQuestion();
                    nextBtn.style.display = 'block';
                    // Conditional display for save/exit button
                    saveAndExitBtn.style.display = isFullTest ? 'none' : 'block';
                    nextBtn.disabled = true;
                    nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    if (isFullTest) {
                        startFullTestTimer();
                        timerContainer.style.display = 'flex';
                    }
                } else {
                    questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите на кнопку категории, чтобы начать новый тест, или "Полный тест с контролем времени".</p>';
                }
                updateMainButtonsState(isSessionActive);
                resetInactivityTimer();
            } else {
                loginError.style.display = 'block';
            }
        });

        // Allow pressing Enter key to login
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loginBtn.click();
            }
        });
        
        // Function to start the generation countdown timer
        function startGenerationCountdown() {
            let timeLeft = GENERATION_COUNTDOWN_SECONDS;
            const timerElement = document.getElementById('timer');
            timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;

            generationCountdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;
                } else {
                    clearInterval(generationCountdownInterval);
                    timerElement.textContent = 'Время вышло, генерация продолжается...';
                }
            }, 1000);
        }

        // Function to start the full test timer
        function startFullTestTimer() {
            clearInterval(fullTestInterval);
            timerContainer.style.display = 'flex';

            fullTestInterval = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                fullTestTimer.textContent = `Осталось: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    clearInterval(fullTestInterval);
                    endQuizTimedOut();
                }
            }, 1000);
        }

        // Function to show loading indicator
        function showLoading(message) {
            questionsContainer.innerHTML = '';
            loadingIndicator.innerHTML = `
                <p class="text-xl font-semibold mb-4 text-gray-700">${message}</p>
                <div id="timer" class="text-md font-medium text-gray-500 mb-4"></div>
                <div class="mt-4">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-gray-900 mx-auto"></div>
                </div>
            `;
            loadingIndicator.style.display = 'block';
            
            updateMainButtonsState(true);

            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            timerContainer.style.display = 'none';
            
            clearInterval(generationCountdownInterval);
            startGenerationCountdown();
        }

        // Function to hide loading indicator
        function hideLoading() {
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            clearInterval(generationCountdownInterval);
        }
        
        // NEW: Functions for managing excluded topics
        function getExcludedTopics() {
            const excludedTopics = localStorage.getItem('excludedTopics');
            return excludedTopics ? JSON.parse(excludedTopics) : [];
        }

        function saveExcludedTopics(topics) {
            localStorage.setItem('excludedTopics', JSON.stringify(topics));
        }

        function renderExcludedTopicsList() {
            const topics = getExcludedTopics();
            excludedTopicsList.innerHTML = '';
            if (topics.length === 0) {
                excludedTopicsList.innerHTML = '<p class="text-gray-500 text-center text-sm">Нет исключенных тем.</p>';
                return;
            }

            topics.forEach(topic => {
                const topicItem = document.createElement('div');
                topicItem.className = 'flex items-center justify-between p-2 bg-white rounded-md shadow-sm border border-gray-200';
                topicItem.innerHTML = `
                    <span class="text-gray-800">${topic}</span>
                    <button class="delete-topic-btn bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-2 rounded-full transition duration-200" data-topic="${topic}">
                        Удалить
                    </button>
                `;
                excludedTopicsList.appendChild(topicItem);
            });
        }
        
        // Event listeners for the new modal
        excludeTopicsBtn.addEventListener('click', () => {
            renderExcludedTopicsList();
            excludeTopicsModal.classList.remove('hidden');
        });

        // FIX: Use the correct variable name
        cancelExcludeBtnEl.addEventListener('click', () => {
            excludeTopicsModal.classList.add('hidden');
        });
        
        addTopicBtn.addEventListener('click', () => {
            const topic = topicInput.value.trim();
            if (topic) {
                const topics = getExcludedTopics();
                if (!topics.includes(topic)) {
                    topics.push(topic);
                    saveExcludedTopics(topics);
                    renderExcludedTopicsList();
                }
                topicInput.value = '';
            }
        });
        
        excludedTopicsList.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-topic-btn')) {
                const topicToDelete = event.target.dataset.topic;
                const topics = getExcludedTopics();
                const updatedTopics = topics.filter(t => t !== topicToDelete);
                saveExcludedTopics(updatedTopics);
                renderExcludedTopicsList();
            }
        });
        
        // Helper function to get the correct number of vocabulary words
        function getVocabCount(difficulty) {
            switch(difficulty) {
                case 'easy':
                    return 4;
                case 'hard':
                    return 6;
                case 'gre_gmat':
                    return 8;
                default:
                    return 4; // Default to easy
            }
        }

        // Function to generate multiple questions for a given category with exponential backoff
        // ИСПРАВЛЕНО: Эта функция теперь использует прямой вызов 'fetch' вместо
        // внешней библиотеки GoogleGenerativeAI, чтобы обойти потенциальные ошибки
        // аутентификации в среде Canvas.
        async function generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, retries = 0) {
            const MAX_RETRIES = 5;
            const BASE_DELAY_MS = 1000;
            
            // ИСПРАВЛЕНО: Запросить ровно 7 вопросов, чтобы избежать ошибок с индексацией
            const numberOfQuestions = 7; 
            const vocabCount = getVocabCount(difficulty);

            // NEW: Get excluded topics directly from local storage
            const excludedTopics = getExcludedTopics();
            let prompt = "";
            
            // NEW: Define word count and difficulty modifier based on the selected level
            let difficultyModifier;
            let wordCountRange;
            if (difficulty === 'easy') {
                difficultyModifier = 'straightforward';
                wordCountRange = '40-60';
            } else if (difficulty === 'hard') {
                difficultyModifier = 'challenging';
                wordCountRange = '60-80';
            } else if (difficulty === 'gre_gmat') {
                difficultyModifier = 'highly challenging, GRE/GMAT-level';
                wordCountRange = '100-150';
            }
            
            // NEW: Add excluded topics to the prompt
            // ИСПРАВЛЕНО: Убедиться, что исключенные темы включены в промпт
            const excludeText = excludedTopics && excludedTopics.length > 0 ? `Explicitly and strictly avoid passages and questions on the following topics: ${excludedTopics.join(', ')}. It is critical that no generated content relates to these topics.` : '';
            
            // Define the JSON schema for the expected output
            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        passage: { type: "STRING" },
                        question: { type: "STRING" },
                        options: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    label: { type: "STRING" },
                                    text: { type: "STRING" }
                                },
                                required: ["label", "text"]
                            }
                        },
                        correct_answer: { type: "STRING" },
                        explanation: { type: "STRING" },
                        // UPDATED SCHEMA: Now includes synonyms
                        vocabulary: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    word: { "type": "STRING" },
                                    translation: { "type": "STRING" },
                                    synonyms: { "type": "STRING" },
                                },
                                required: ["word", "translation", "synonyms"]
                            }
                        },
                        category: { type: "STRING" },
                        graphic: { type: "STRING" }
                    },
                    required: ["passage", "question", "options", "correct_answer", "explanation", "category"]
                }
            };
            
            switch (categoryKey) {
                case "information_ideas":
                    // UPDATED PROMPT: Now requests a specific number of vocabulary words
                    prompt = `
                        Generate exactly ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions in English, each based on a new and distinct topic. ${excludeText}
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. Passages must be fresh and not repeat previous topics within this generation request.
                        2. A specific SAT-style question in English based on the passage, designed to test a particular skill.
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.
                        
                        The ${numberOfQuestions} questions should be of the following types, each with a unique source material and topic, explicitly avoiding the excluded topics:
                        - Question 1 (Direct Question): Based on an excerpt from an 18th-century philosophical text.
                        - Question 2 (Inference Question): Based on an excerpt from a 20th-century American novel.
                        - Question 3 (Main Idea Question): Based on a short essay about a recent astronomical discovery.
                        - Question 4 (Figure based Question): Based on a bar chart, line graph, or pie chart illustrating a historical demographic trend. The passage field should provide context for the data, and a new "graphic" field must contain a **complete and self-contained SVG string** for the chart. The SVG should be compact, and all text labels (titles, axes, data labels) must be legible, not overlap, be contained within the SVG's viewBox, and use the 'Inter, sans-serif' font family with a font-size of 12px to match the application's styling. The SVG must be responsive, and all graphic components (bars, lines, slices) must use a color palette that excludes pure white and black. The font inside the SVG must be the same as the font of the answers.
                        - Question 5 (Strengthen Weaken Question): Based on a short argumentative essay on an ethical issue concerning artificial intelligence.
                        - Question 6 (Poem based Question): Based on a short contemporary poem.
                        - Question 7 (Character Descriptions): Based on an an excerpt from a biography of a historical figure.
                    `;
                    break;
                case "craft_structure":
                    // UPDATED PROMPT: Now requests a specific number of vocabulary words
                    prompt = `
                        Generate exactly ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions in English, each based on a new and distinct topic. ${excludeText}
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. For Cross-text Connection questions, provide two distinct, short passages. The passages must be fresh and not repeat previous topics within this generation request.
                        2. A specific SAT-style question in English based on the passage(s).
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.

                        The ${numberOfQuestions} questions should be of the following types, ensuring a good mix across the list and using unique topics, explicitly avoiding the excluded topics:
                        - Vocabulary in Context (from a text about a specific art movement)
                        - Primary Purpose Questions (from an excerpt of a scientific research summary)
                        - Purpose of a portion Questions (from a philosophical text on logic)
                        - Structure Questions (from a detailed guide on computer programming)
                        - Cross-text Connection Questions (two passages on differing interpretations of a myth)
                        - Quotes Illustrate Questions (from an analysis of a psychological concept)
                        - A seventh question which is a duplicate of one of the above types, but with a different topic.
                        
                        For "Vocabulary in Context" and "Purpose of a portion" questions, highlight the specific word, phrase, or sentence in the passage by enclosing it in double asterisks (e.g., **word**).
                    `;
                    break;
                case "expression_ideas":
                    // UPDATED PROMPT: Now explicitly uses the blank line for transition questions
                    // to better match the user's example.
                    prompt = `
                        Generate exactly ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions in English, each based on a new and distinct topic, such as a student's essay draft about the social impact of a new technology, an analysis of a classic piece of music, or a research proposal on a historical event. The passages must be fresh and not repeat previous topics within this generation request.
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic.
                        2. A specific SAT-style question in English based on the passage. The questions must consist of:
                           - **3-4 Transition Questions**: These questions ask for the most logical transition to connect a paragraph to a previous one or to a specific sentence within the paragraph. The blank space for the transition word or phrase must be represented by exactly three underscores (e.g., ___).
                           - **3-4 Goal-based Questions**: These questions ask which revision of a sentence best achieves a specified goal, such as making a point more precise or establishing a clearer tone. The part of the passage to be revised must be highlighted by enclosing it in double asterisks (e.g., **The phrase to be revised**).
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.
                    `;
                    break;
                case "standard_english_conventions":
                    // UPDATED PROMPT: Now requests a specific number of vocabulary words
                    prompt = `
                        Generate exactly ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions in English, each based on a new and distinct topic. ${excludeText} For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, such as a historical account of a battle, a technical manual for a tool, or a biographical sketch of an artist. Each passage must contain a specific grammatical or punctuation error. The passages must be fresh and not repeat previous topics within this generation request.
                        2. A SAT-style question in English that asks the user to correct the error. The questions must cover a variety of the following rules:
                           - Subject-verb agreement
                           - Subject pronoun agreement
                           - Comma subject rule
                           - Punctuation on the SAT
                           - Apostrophe
                           - Listing
                           - Introduction of a list or description
                           - Comparison
                           - Tense
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. One of the options must always be "NO CHANGE".
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.
                        
                        The part of the passage with the grammatical error should be replaced with a blank line, represented by three underscores (e.g., ___). It is critical that you use exactly three underscores, nothing more and nothing less.
                    `;
                    break;
            }

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    }
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                // Check for HTTP errors
                if (!response.ok) {
                    const errorDetails = await response.text();
                    throw new Error(`HTTP Error: ${response.status} ${response.statusText}. Details: ${errorDetails}`);
                }
                
                const result = await response.json();

                // Используем новую надежную функцию для парсинга JSON
                const questionsArray = parseApiResponse(result?.candidates?.[0]?.content?.parts?.[0]?.text || "[]");
                
                if (!Array.isArray(questionsArray)) {
                    throw new Error("API не вернул массив JSON вопросов.");
                }
                return questionsArray;
            } catch (error) {
                console.error(`Ошибка генерации вопросов для ${categoryTitle} (Уровень: ${difficulty}):`, error);
                
                if (retries < MAX_RETRIES) {
                    const delay = BASE_DELAY_MS * Math.pow(2, retries) + (Math.random() * 100);
                    console.warn(`Повторная попытка генерации вопросов для ${categoryTitle} через ${delay} мс (попытка ${retries + 1}/${MAX_RETRIES})...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, retries + 1);
                }

                // ИСПРАВЛЕНИЕ: Улучшенное сообщение об ошибке для 401/403
                let errorMessage = `<p class='text-red-600'>Произошла ошибка при генерации вопросов. Пожалуйста, попробуйте еще раз.</p>`;
                
                if (error.message) {
                    if (error.message.includes("401") || error.message.includes("403")) {
                         errorMessage = "<p class='text-red-600'>Ошибка 401/403: Проблема с доступом к Gemini API. Это часто указывает на то, что API-ключ недействителен или отсутствует. Пожалуйста, убедитесь, что ваш API-ключ правильно настроен в вашей среде.</p>";
                    } else if (error.message.includes("API key not valid")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: API ключ Gemini недействителен. Пожалуйста, убедитесь, что он правильно настроен в вашей среде.</p>";
                    } else if (error.message.includes("Invalid JSON format from API")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: API вернул данные в неверном формате. Пожалуйста, попробуйте снова.</p>";
                    }
                }
                
                questionsContainer.innerHTML = errorMessage;
                hideLoading();
                updateMainButtonsState(false);
                throw error;
            }
        }

        // Function to handle the start of a new test
        async function handleNewTest(categoryKey) {
            isSessionActive = true;
            isFullTest = false;
            completedQuestions = [];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            const difficulty = difficultySelect.value;
            questionsContainer.innerHTML = '';
            
            showLoading(`Генерация вопросов для "${Object.keys(categories).find(key => categories[key] === categoryKey)}" (Уровень: ${difficulty}). Это может занять до 90 секунд...`);
            
            try {
                const questions = await generateQuestionsForCategory(
                    Object.keys(categories).find(key => categories[key] === categoryKey),
                    categoryKey,
                    difficulty
                );
                
                // NEW FIX: Check if questions were successfully returned
                if (!questions || questions.length === 0) {
                    questionsContainer.innerHTML = `<p class='text-red-600'>Не удалось сгенерировать вопросы для этой категории. Пожалуйста, попробуйте другую категорию или уровень сложности.</p>`;
                    hideLoading();
                    updateMainButtonsState(false);
                    return; // Stop execution
                }
                
                allGeneratedQuestions = {};
                allGeneratedQuestions[categoryKey] = questions;
                
                hideLoading();
                displayCurrentQuestion();
                nextBtn.style.display = 'block';
                saveAndExitBtn.style.display = 'block';
                updateMainButtonsState(true);
            } catch (error) {
                console.error("Failed to generate questions:", error);
                // Error message is already displayed by generateQuestionsForCategory
                hideLoading();
                updateMainButtonsState(false);
            }
        }
        
        async function handleFullTest() {
            isSessionActive = true;
            isFullTest = true;
            completedQuestions = [];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            const difficulty = difficultySelect.value;
            questionsContainer.innerHTML = '';
            categoriesArray = Object.keys(categories);
            allGeneratedQuestions = {};
            timeLeft = FULL_TEST_DURATION_SECONDS;
            
            showLoading(`Генерация вопросов для полного теста (Уровень: ${difficulty}). Это может занять до 90 секунд...`);
            
            try {
                const allQuestionsPromises = categoriesArray.map(categoryTitle => 
                    generateQuestionsForCategory(categoryTitle, categories[categoryTitle], difficulty)
                );
                
                const allQuestionsArrays = await Promise.all(allQuestionsPromises);
                
                // NEW FIX: Check if all question sets were successfully returned
                if (allQuestionsArrays.some(arr => !arr || arr.length === 0)) {
                    questionsContainer.innerHTML = `<p class='text-red-600'>Не удалось сгенерировать полный тест. Пожалуйста, попробуйте еще раз.</p>`;
                    hideLoading();
                    updateMainButtonsState(false);
                    return; // Stop execution
                }
                
                categoriesArray.forEach((categoryTitle, index) => {
                    allGeneratedQuestions[categories[categoryTitle]] = allQuestionsArrays[index];
                });
                
                hideLoading();
                startFullTestTimer();
                displayCurrentQuestion();
                nextBtn.style.display = 'block';
                // No save and exit button for timed tests
                saveAndExitBtn.style.display = 'none';
                updateMainButtonsState(true);
            } catch (error) {
                console.error("Failed to generate full test questions:", error);
                // Error message is already displayed by generateQuestionsForCategory
                hideLoading();
                updateMainButtonsState(false);
            }
        }
        
        fullTestBtn.addEventListener('click', handleFullTest);
        
        function endQuiz() {
            isSessionActive = false;
            updateMainButtonsState(false);
            
            const completedTest = {
                timestamp: new Date().toLocaleString(),
                difficulty: difficultySelect.value,
                questions: completedQuestions,
                isFullTest: isFullTest,
                categories: categoriesArray
            };
            
            const allTests = JSON.parse(localStorage.getItem('completedTests')) || [];
            allTests.push(completedTest);
            localStorage.setItem('completedTests', JSON.stringify(allTests));
            
            localStorage.removeItem('satQuizSession');
            
            // Show a final message and reset the UI
            questionsContainer.innerHTML = `
                <div class="text-center p-6 bg-white rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">Тест завершен!</h2>
                    <p class="text-gray-600">Ваши результаты сохранены в "Завершенные тесты".</p>
                </div>
            `;
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            timerContainer.style.display = 'none';
            clearInterval(fullTestInterval);
        }

        function endQuizTimedOut() {
            isSessionActive = false;
            updateMainButtonsState(false);
            
            const completedTest = {
                timestamp: new Date().toLocaleString(),
                difficulty: difficultySelect.value,
                questions: completedQuestions,
                isFullTest: isFullTest,
                categories: categoriesArray,
                timedOut: true
            };
            
            const allTests = JSON.parse(localStorage.getItem('completedTests')) || [];
            allTests.push(completedTest);
            localStorage.setItem('completedTests', JSON.stringify(allTests));
            
            localStorage.removeItem('satQuizSession');
            
            // Show a final message and reset the UI
            questionsContainer.innerHTML = `
                <div class="text-center p-6 bg-white rounded-lg shadow-md bg-red-100 border-l-4 border-red-500 text-red-700">
                    <h2 class="text-2xl font-bold mb-4">Время вышло!</h2>
                    <p>Ваш тест завершен автоматически. Ваши результаты были сохранены в "Завершенные тесты".</p>
                </div>
            `;
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            timerContainer.style.display = 'none';
            clearInterval(fullTestInterval);
        }

        function displayCurrentQuestion() {
            nextBtn.disabled = true;
            nextBtn.classList.add('opacity-50', 'cursor-not-allowed');

            const currentCategoryKey = isFullTest ? categoriesArray[currentCategoryIndex] : Object.keys(allGeneratedQuestions)[0];
            const questions = allGeneratedQuestions[currentCategoryKey];
            
            // NEW FIX: Add a check for the questions array itself before accessing an index
            if (!questions || questions.length === 0) {
                console.error("No questions found for the current category.");
                questionsContainer.innerHTML = "<p class='text-red-600'>Ошибка: Не удалось загрузить вопросы для этой категории. Пожалуйста, начните новый тест.</p>";
                hideLoading();
                updateMainButtonsState(false);
                return;
            }
            
            const currentQuestionData = questions[currentQuestionIndex];
            
            if (!currentQuestionData) {
                // ИСПРАВЛЕНО: Добавить более информативное сообщение об ошибке, если
                // данные вопроса отсутствуют, что указывает на проблему с индексацией.
                console.error(`Ошибка: данные вопроса не найдены по индексу ${currentQuestionIndex} в категории ${currentCategoryKey}.`);
                questionsContainer.innerHTML = "<p class='text-red-600'>Ошибка: Не удалось загрузить вопрос. Возможно, данные были повреждены. Пожалуйста, начните новый тест.</p>";
                hideLoading();
                updateMainButtonsState(false);
                return;
            }

            questionsContainer.innerHTML = '';
            
            const questionCard = document.createElement('div');
            questionCard.className = 'question-card';
            questionCard.dataset.questionIndex = currentQuestionIndex;
            
            // Display category and question number
            const questionLabel = document.createElement('div');
            const questionNumber = completedQuestions.length + 1;
            questionLabel.className = 'text-gray-500 text-sm mb-4';
            questionLabel.textContent = `Категория: ${currentQuestionData.category} | Вопрос ${questionNumber}`;
            questionCard.appendChild(questionLabel);

            // Display graphic if present
            if (currentQuestionData.graphic) {
                const svgContainer = document.createElement('div');
                svgContainer.className = 'svg-container';
                svgContainer.innerHTML = currentQuestionData.graphic;
                questionCard.appendChild(svgContainer);
            }
            
            // Display the passage, replacing double asterisks with tooltips
            const passageParagraph = document.createElement('p');
            passageParagraph.className = 'question-passage';
            // Use regex to find `**word**` patterns and wrap them in a tooltip container
            let passageWithTooltips = currentQuestionData.passage;

            if (currentQuestionData.vocabulary && !isFullTest) {
                // Create a regular expression to match all words in the vocabulary list
                const wordsToMatch = currentQuestionData.vocabulary.map(v => v.word).join('|');
                const regex = new RegExp(`\\b(${wordsToMatch})\\b`, 'g');
                
                passageWithTooltips = passageWithTooltips.replace(regex, (match) => {
                    const vocab = currentQuestionData.vocabulary.find(v => v.word === match);
                    if (vocab) {
                        return `<span class="tooltip-container">${match}<span class="tooltip-text">Перевод: ${vocab.translation}<br>Синонимы: ${vocab.synonyms}</span></span>`;
                    }
                    return match;
                });
            }
            
            // UPDATED: Now handle the double-asterisk highlighting and the new triple-underscore blank line
            // Use a simple, visible line for the blank
            passageWithTooltips = passageWithTooltips.replace(/___/g, `<span class="border-b-2 border-gray-500 px-4 pb-1"> </span>`);
            passageWithTooltips = passageWithTooltips.replace(/\*\*(.*?)\*\*/g, (match, word) => `<span class="bg-yellow-200 p-1 rounded">${word}</span>`);
            
            passageParagraph.innerHTML = passageWithTooltips;
            questionCard.appendChild(passageParagraph);

            // Display the question text
            const questionText = document.createElement('p');
            questionText.className = 'question-text';
            questionText.textContent = currentQuestionData.question;
            questionCard.appendChild(questionText);

            // Display the options
            const optionsList = document.createElement('ul');
            optionsList.className = 'space-y-2';
            currentQuestionData.options.forEach(option => {
                const optionItem = document.createElement('li');
                optionItem.className = 'option-item p-3 pl-4 border rounded-lg hover:bg-gray-50';
                optionItem.dataset.label = option.label;
                optionItem.innerHTML = `<span class="font-semibold text-gray-800">${option.label}.</span> ${option.text}`;
                optionsList.appendChild(optionItem);
            });
            questionCard.appendChild(optionsList);

            // Display the explanation area
            const explanationDiv = document.createElement('div');
            explanationDiv.className = 'explanation';
            explanationDiv.innerHTML = `<p class="font-bold mb-2 text-gray-700">Объяснение:</p>${currentQuestionData.explanation}`;
            questionCard.appendChild(explanationDiv);
            
            questionsContainer.appendChild(questionCard);
            
            questionStartTime = Date.now();
            attachEventListeners();
        }

        function attachEventListeners() {
            // Remove previous listeners to avoid duplicates
            questionsContainer.removeEventListener('click', handleAnswer);
            nextBtn.removeEventListener('click', nextQuestion);

            // Add new listeners
            questionsContainer.addEventListener('click', handleAnswer);
            nextBtn.addEventListener('click', nextQuestion);
        }

        function handleAnswer(event) {
            const selectedOption = event.target.closest('.option-item');
            if (!selectedOption) return;

            const questionCard = selectedOption.closest('.question-card');
            const questionIndex = parseInt(questionCard.dataset.questionIndex);
            
            const currentCategoryKey = isFullTest ? categoriesArray[currentCategoryIndex] : Object.keys(allGeneratedQuestions)[0];
            const questions = allGeneratedQuestions[currentCategoryKey];
            const currentQuestionData = questions[questionIndex];
            const correctAnswer = currentQuestionData.correct_answer;
            const selectedAnswer = selectedOption.dataset.label;
            
            // Disable all options after one is selected
            questionCard.querySelectorAll('.option-item').forEach(option => {
                option.classList.add('disabled');
            });

            // Highlight the correct and incorrect answers
            if (selectedAnswer === correctAnswer) {
                selectedOption.classList.add('correct');
            } else {
                selectedOption.classList.add('incorrect');
                // Also highlight the correct one if the user was wrong
                questionCard.querySelector(`.option-item[data-label="${correctAnswer}"]`).classList.add('correct');
            }

            // Show the explanation
            questionCard.querySelector('.explanation').style.display = 'block';

            // Enable the Next button
            nextBtn.disabled = false;
            nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');

            // Record the user's performance
            const timeTaken = Math.floor((Date.now() - questionStartTime) / 1000);
            const userPerformance = {
                questionIndex: completedQuestions.length,
                questionData: currentQuestionData,
                userAnswer: selectedAnswer,
                isCorrect: selectedAnswer === correctAnswer,
                timeTaken: timeTaken
            };
            completedQuestions.push(userPerformance);
            
            saveSession();
        }

        function nextQuestion() {
            const currentCategoryKey = isFullTest ? categoriesArray[currentCategoryIndex] : Object.keys(allGeneratedQuestions)[0];
            const questions = allGeneratedQuestions[currentCategoryKey];

            // If it's a full test and we're at the end of a category
            if (isFullTest && currentQuestionIndex + 1 >= questions.length) {
                // Move to the next category
                currentCategoryIndex++;
                currentQuestionIndex = 0;
                
                // Check if the full test is complete
                if (currentCategoryIndex >= categoriesArray.length) {
                    endQuiz();
                    return;
                }

                // If not complete, display the next question
                displayCurrentQuestion();
                
            } else if (!isFullTest && currentQuestionIndex + 1 >= questions.length) {
                // If it's a single category test and we're at the end
                endQuiz();
            } else {
                // Move to the next question in the current category
                currentQuestionIndex++;
                displayCurrentQuestion();
            }
        }
        
        // Event listeners for the main app
        nextBtn.addEventListener('click', nextQuestion);

        saveAndExitBtn.addEventListener('click', () => {
            // This button is only for single-category tests, so we save and exit
            const saveConfirmed = showCustomConfirm('Вы уверены, что хотите сохранить прогресс и выйти?');
            saveConfirmed.then(result => {
                if(result) {
                    logoutUser(true);
                }
            });
        });

        // Completed tests screen functionality
        showCompletedTestsBtn.addEventListener('click', () => {
            appContent.style.display = 'none';
            completedTestsScreen.style.display = 'block';
            renderCompletedTestsList();
        });
        
        backToMainBtn.addEventListener('click', () => {
            completedTestsScreen.style.display = 'none';
            appContent.style.display = 'block';
            
            // If a session is active, update button state to be disabled
            updateMainButtonsState(isSessionActive);
        });

        backToTestsBtn.addEventListener('click', () => {
            completedTestDetailsContainer.style.display = 'none';
            testsListContainer.style.display = 'block';
        });
        
        // Delete button listener
        deleteTestBtn.addEventListener('click', async () => {
            if (currentReviewingTest !== null) {
                const confirmation = await showCustomConfirm('Вы уверены, что хотите удалить этот тест? Это действие необратимо.');
                if (confirmation) {
                    let allTests = JSON.parse(localStorage.getItem('completedTests')) || [];
                    const updatedTests = allTests.filter((_, index) => index !== currentReviewingTest);
                    localStorage.setItem('completedTests', JSON.stringify(updatedTests));
                    currentReviewingTest = null;
                    completedTestDetailsContainer.style.display = 'none';
                    renderCompletedTestsList();
                }
            }
        });

        function renderCompletedTestsList() {
            testsListContainer.innerHTML = '';
            const allTests = JSON.parse(localStorage.getItem('completedTests')) || [];

            if (allTests.length === 0) {
                testsListContainer.innerHTML = '<p class="text-center text-gray-600">Нет завершенных тестов.</p>';
                return;
            }

            allTests.forEach((test, index) => {
                const testCard = document.createElement('div');
                testCard.className = 'completed-test-card';
                testCard.dataset.testIndex = index;
                
                const score = test.questions.filter(q => q.isCorrect).length;
                const total = test.questions.length;
                
                let categoriesDisplay = test.isFullTest ? 'Полный тест' : test.questions[0]?.questionData?.category || 'Неизвестно';
                if(test.timedOut) {
                    categoriesDisplay += ' (Время вышло)';
                }
                
                testCard.innerHTML = `
                    <p class="text-sm text-gray-500 mb-1">Дата: ${test.timestamp}</p>
                    <p class="text-xl font-bold text-gray-800">${categoriesDisplay}</p>
                    <p class="text-md text-gray-700">Сложность: ${test.difficulty}</p>
                    <p class="text-md text-gray-700">Результат: ${score} из ${total}</p>
                `;
                testCard.addEventListener('click', () => showTestReview(index));
                testsListContainer.appendChild(testCard);
            });
            
            testsListContainer.style.display = 'block';
        }
        
        function showTestReview(testIndex) {
            testsListContainer.style.display = 'none';
            completedTestDetailsContainer.style.display = 'block';
            
            const allTests = JSON.parse(localStorage.getItem('completedTests')) || [];
            const test = allTests[testIndex];
            currentReviewingTest = testIndex;

            testReviewContainer.innerHTML = `
                <h2 class="text-3xl font-bold text-gray-800 mb-4">Обзор теста</h2>
                <div class="bg-gray-100 p-4 rounded-lg mb-6">
                    <p class="text-sm text-gray-600">Дата: ${test.timestamp}</p>
                    <p class="text-sm text-gray-600">Сложность: ${test.difficulty}</p>
                    <p class="text-sm text-gray-600">Категория: ${test.isFullTest ? 'Полный тест' : test.questions[0]?.questionData?.category}</p>
                    <p class="text-sm text-gray-600">Результат: ${test.questions.filter(q => q.isCorrect).length} из ${test.questions.length}</p>
                </div>
            `;
            
            test.questions.forEach((q, index) => {
                const reviewCard = document.createElement('div');
                reviewCard.className = 'completed-test-details-question-card';
                
                let passageContent = q.questionData.passage;
                if (q.questionData.vocabulary) {
                    const wordsToMatch = q.questionData.vocabulary.map(v => v.word).join('|');
                    const regex = new RegExp(`\\b(${wordsToMatch})\\b`, 'g');
                    passageContent = passageContent.replace(regex, (match) => {
                        const vocab = q.questionData.vocabulary.find(v => v.word === match);
                        if (vocab) {
                            return `<span class="tooltip-container">${match}<span class="tooltip-text">Перевод: ${vocab.translation}<br>Синонимы: ${vocab.synonyms}</span></span>`;
                        }
                        return match;
                    });
                }
                
                // UPDATED: Now handle the double-asterisk highlighting and the new triple-underscore blank line
                const passageWithHighlights = passageContent.replace(/___/g, `<span class="border-b-2 border-gray-500 pb-1 px-4"> </span>`);
                
                reviewCard.innerHTML = `
                    <p class="font-bold text-lg mb-2 text-gray-800">Вопрос ${index + 1} (${q.questionData.category})</p>
                    ${q.questionData.graphic ? `<div class="svg-container">${q.questionData.graphic}</div>` : ''}
                    <p class="text-gray-600 mb-2 italic">${passageWithHighlights}</p>
                    <p class="font-semibold text-gray-700 mb-4">${q.questionData.question}</p>
                    <ul class="space-y-1">
                        ${q.questionData.options.map(option => `
                            <li class="p-2 border rounded-md text-gray-800
                                ${option.label === q.questionData.correct_answer ? 'bg-green-100 border-green-400' : ''}
                                ${option.label === q.userAnswer && option.label !== q.questionData.correct_answer ? 'bg-red-100 border-red-400' : ''}">
                                <span class="font-semibold">${option.label}.</span> ${option.text}
                            </li>
                        `).join('')}
                    </ul>
                    <div class="mt-4 pt-4 border-t border-dashed border-gray-300">
                        <p class="font-bold text-sm mb-1 text-gray-700">Ваш ответ: <span class="user-answer ${q.isCorrect ? 'text-green-600' : 'text-red-600'}">${q.userAnswer}</span></p>
                        <p class="font-bold text-sm mb-1 text-gray-700">Правильный ответ: <span class="user-answer text-green-600">${q.questionData.correct_answer}</span></p>
                        <p class="font-bold text-sm text-gray-700">Объяснение: <span class="font-normal">${q.questionData.explanation}</span></p>
                    </div>
                `;
                testReviewContainer.appendChild(reviewCard);
            });
        }
    </script>
</body>
</html>
