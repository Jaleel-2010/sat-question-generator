<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор вопросов SAT</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%; /* Ensure container takes full width on smaller screens */
        }
        .section-title {
            border-bottom: 2px solid #cbd5e1; /* Light gray border */
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .question-card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0; /* Light border */
        }
        .question-passage {
            font-style: italic;
            color: #4a5568; /* Dark gray text */
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .question-text {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2d3748; /* Darker gray text */
        }
        .option-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            border-radius: 0.5rem;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 1px solid transparent; /* Default transparent border */
        }
        .option-item:hover:not(.disabled) {
            background-color: #f3f4f6; /* Light gray on hover */
        }
        .option-item.correct {
            background-color: #d1fae5; /* Light green for correct answer */
            border-color: #34d399; /* Green border */
            font-weight: 500;
        }
        .option-item.incorrect {
            background-color: #fee2e2; /* Light red for incorrect answer */
            border-color: #ef4444; /* Red border */
            font-weight: 500;
        }
        .option-item.disabled {
            pointer-events: none; /* Disable clicks */
            opacity: 0.8; /* Slightly dim disabled options */
        }
        .explanation {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #e2e8f0;
            font-size: 0.9rem;
            color: #4a5568;
            display: none; /* Hidden by default */
        }
        /* New: Style for tooltips */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #94a3b8; /* Dotted underline for tooltip words */
        }
        .tooltip-text {
            visibility: hidden;
            width: auto; /* Adjust width based on content */
            max-width: 500px; /* Increased max-width for more words */
            background-color: #333;
            color: #fff;
            text-align: left; /* Align text to left for multi-line */
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 100; /* Ensure tooltip is on top */
            bottom: 125%; /* Position above the text */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Allow text wrapping */
            word-wrap: break-word; /* Ensure long words break */
            font-size: 0.85rem;
            pointer-events: none; /* Allow clicks to pass through tooltip when not hovered */
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .login-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .login-button {
            width: 100%;
            background-color: #4299e1; /* Blue */
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #3182ce; /* Darker blue */
        }
        .error-message {
            color: #ef4444;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        /* New: Style for completed tests screen */
        .completed-tests-screen {
            background-color: #f0f4f8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }
        .completed-test-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .completed-test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .completed-test-card-details {
            border-left: 4px solid #3b82f6; /* Blue border for details */
            padding-left: 1rem;
            margin-top: 1rem;
        }
        .completed-test-details-question-card {
            background-color: #f8fafc;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
        }
        .user-answer {
            font-weight: 500;
        }
        /* Style for SVG container to ensure responsiveness */
        .svg-container {
            width: 100%;
            height: auto;
            max-width: 600px; /* New: Limit max width on large screens */
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            margin-left: auto; /* New: Center the container */
            margin-right: auto; /* New: Center the container */
        }
        /* New: Style for text inside the SVG */
        .svg-container svg text {
            font-family: 'Inter', sans-serif;
            font-size: 12px; /* Set a default font size */
        }
        /* Styles for the new modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
        }
    </style>
</head>
<body>
    <div id="loginScreen" class="login-container">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">Welcome to Jaleel's Verbal SAT Question Generator</h2>
        <input type="password" id="passwordInput" class="login-input" placeholder="Введите пароль">
        <button id="loginBtn" class="login-button">Войти</button>
        <p id="loginError" class="error-message" style="display: none;">Неверный пароль. Попробуйте снова.</p>
    </div>

    <div id="appContent" class="container" style="display: none;">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Генератор вопросов SAT (Verbal Section)</h1>
        
        <div id="timerContainer" class="flex items-center justify-center mb-4 text-xl font-bold text-red-600" style="display: none;">
            <svg class="h-6 w-6 mr-2 animate-pulse" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span id="fullTestTimer"></span>
        </div>
        
        <div class="mb-6">
            <label for="difficultySelect" class="block text-gray-700 text-sm font-bold mb-2">Выберите уровень сложности:</label>
            <select id="difficultySelect" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500">
                <option value="easy">Облегченный уровень (Easier Module)</option>
                <option value="hard">Усложненный уровень (Harder Module 2)</option>
                <option value="gre_gmat">Сложный уровень (GRE/GMAT-level)</option>
            </select>
        </div>
        
        <!-- UPDATED: Moved and styled the "Exclude Topics" button -->
        <div class="mb-4">
            <button id="excludeTopicsBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
                Исключить темы
            </button>
        </div>

        <div id="categoryButtonsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <!-- Buttons for each category will be inserted here by JavaScript -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mb-4">
            <button id="fullTestBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
                Полный тест с контролем времени
            </button>
            <button id="showCompletedTestsBtn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                Завершенные тесты
            </button>
        </div>
        
        <div id="loadingIndicator" class="loading-indicator text-center" style="display: none;">
            <!-- Questions will be loaded here -->
        </div>
        
        <div id="questionsContainer" class="space-y-10">
            <!-- Questions will be loaded here -->
        </div>

        <!-- Corrected button order -->
        <div class="flex flex-col sm:flex-row justify-between gap-4 mt-4">
            <button id="nextBtn" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                Следующий вопрос
            </button>
            <button id="saveAndExitBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" style="display: none;">
                Сохранить и выйти
            </button>
        </div>
    </div>

    <div id="completedTestsScreen" class="completed-tests-screen" style="display: none;">
        <button id="backToMainBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
            &larr; Назад в главное окно
        </button>
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Завершенные тесты</h1>
        <div id="testsListContainer" class="space-y-4">
            <!-- Completed tests will be listed here -->
        </div>
        <div id="completedTestDetailsContainer" class="mt-8" style="display: none;">
            <button id="backToTestsBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
                &larr; Назад к списку тестов
            </button>
            <!-- New delete button added here -->
            <button id="deleteTestBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mb-4 ml-4 transition duration-200 ease-in-out">
                Удалить тест
            </button>
            <div id="testReviewContainer">
                <!-- Detailed test review will be displayed here -->
            </div>
        </div>
    </div>

    <!-- NEW: Exclude Topics Modal -->
    <div id="excludeTopicsModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Исключить темы</h2>
            <div class="flex items-center space-x-2 mb-4">
                <input type="text" id="topicInput" class="login-input flex-grow" placeholder="Введите тему для исключения">
                <button id="addTopicBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Добавить</button>
            </div>
            <div id="excludedTopicsList" class="space-y-2 mb-4 max-h-40 overflow-y-auto p-2 bg-gray-100 rounded-md">
                <!-- Excluded topics will be listed here -->
            </div>
            <div class="flex justify-end space-x-4">
                <button id="cancelExcludeBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Ок</button>
            </div>
        </div>
    </div>

    <script type="module">
        // The API key is automatically handled by the environment, so we leave it empty.
        const apiKey = "";
        
        // --- Get all the DOM elements
        const loginScreen = document.getElementById('loginScreen');
        const passwordInput = document.getElementById('passwordInput');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const appContent = document.getElementById('appContent');
        const categoryButtonsContainer = document.getElementById('categoryButtonsContainer');
        const fullTestBtn = document.getElementById('fullTestBtn');
        const questionsContainer = document.getElementById('questionsContainer');
        const showCompletedTestsBtn = document.getElementById('showCompletedTestsBtn');
        const completedTestsScreen = document.getElementById('completedTestsScreen');
        const testsListContainer = document.getElementById('testsListContainer');
        const completedTestDetailsContainer = document.getElementById('completedTestDetailsContainer');
        const testReviewContainer = document.getElementById('testReviewContainer');
        const backToTestsBtn = document.getElementById('backToTestsBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const difficultySelect = document.getElementById('difficultySelect');
        const nextBtn = document.getElementById('nextBtn');
        const saveAndExitBtn = document.getElementById('saveAndExitBtn');
        const deleteTestBtn = document.getElementById('deleteTestBtn');
        const timerContainer = document.getElementById('timerContainer');
        const fullTestTimer = document.getElementById('fullTestTimer');
        
        // NEW: Exclude topics modal elements
        const excludeTopicsBtn = document.getElementById('excludeTopicsBtn');
        const excludeTopicsModal = document.getElementById('excludeTopicsModal');
        const topicInput = document.getElementById('topicInput');
        const addTopicBtn = document.getElementById('addTopicBtn');
        const excludedTopicsList = document.getElementById('excludedTopicsList');
        const cancelExcludeBtnEl = document.getElementById('cancelExcludeBtn');

        const categories = {
            "Information and Ideas": "information_ideas",
            "Craft and Structure": "craft_structure",
            "Expression of Ideas": "expression_ideas",
            "Standard English Conventions": "standard_english_conventions"
        };
        const labels = ['A', 'B', 'C', 'D'];

        // Global state to manage questions and current position
        let allGeneratedQuestions = {};
        let completedQuestions = [];
        let categoriesArray = [];
        let currentCategoryIndex = 0;
        let currentQuestionIndex = 0;
        let isSessionActive = false;
        let isFullTest = false; 
        let currentReviewingTest = null;
        let questionStartTime = 0; 

        // Hardcoded password array for client-side authentication
        const CORRECT_PASSWORDS = ["Jaleel2010", "Janiya2010", "ThirdPassword"];

        // Inactivity timer variables
        let inactivityTimer;
        const INACTIVITY_TIMEOUT = 5 * 60 * 1000;
        
        // Countdown timer variables
        let generationCountdownInterval;
        const GENERATION_COUNTDOWN_SECONDS = 90;

        // Full Test timer variables - UPDATED
        let fullTestInterval;
        const FULL_TEST_DURATION_MINUTES = 30; 
        const FULL_TEST_DURATION_SECONDS = FULL_TEST_DURATION_MINUTES * 60;
        let timeLeft = FULL_TEST_DURATION_SECONDS;
        
        // --- NEW: Function to robustly parse the API response to handle non-JSON text ---
        function parseApiResponse(text) {
            try {
                // Try to find the JSON array part of the string.
                // This regex looks for the content between the first '[' and the last ']'.
                const jsonMatch = text.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                } else {
                    // If no array is found, it might be a single JSON object.
                    const objectMatch = text.match(/\{[\s\S]*\}/);
                    if (objectMatch) {
                        return JSON.parse(objectMatch[0]);
                    }
                }
            } catch (e) {
                console.error("Failed to parse JSON even after cleaning:", e);
                throw new Error("Invalid JSON format from API.");
            }
            throw new Error("No valid JSON found in API response.");
        }

        // Function to reset the inactivity timer
        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(logoutUser, INACTIVITY_TIMEOUT);
        }

        // Function to save the current session state
        function saveSession() {
            if (Object.keys(allGeneratedQuestions).length > 0) {
                const sessionData = {
                    categoryIndex: currentCategoryIndex,
                    questionIndex: currentQuestionIndex,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value,
                    completedQuestions: completedQuestions,
                    categoriesArray: categoriesArray,
                    isFullTest: isFullTest,
                    timeLeft: timeLeft
                };
                localStorage.setItem('satQuizSession', JSON.stringify(sessionData));
                console.log('Session saved.');
            }
        }

        // Function to load a saved session state
        async function loadSession() {
            const savedSession = localStorage.getItem('satQuizSession');
            if (savedSession) {
                const sessionData = JSON.parse(savedSession);
                
                // NEW FIX: Check if the saved session is valid and has questions
                if (!sessionData || !sessionData.questions || Object.keys(sessionData.questions).length === 0) {
                    localStorage.removeItem('satQuizSession');
                    console.error("Invalid or empty session data found. Clearing session.");
                    return false;
                }

                const confirmation = await showCustomConfirm('Обнаружена незавершенная сессия. Хотите продолжить с того места, где остановились?');
                
                if (confirmation) {
                    currentCategoryIndex = sessionData.categoryIndex;
                    currentQuestionIndex = sessionData.questionIndex;
                    allGeneratedQuestions = sessionData.questions;
                    difficultySelect.value = sessionData.difficulty;
                    completedQuestions = sessionData.completedQuestions || [];
                    categoriesArray = sessionData.categoriesArray || Object.keys(categories);
                    isFullTest = sessionData.isFullTest || false;
                    timeLeft = sessionData.timeLeft || FULL_TEST_DURATION_SECONDS;
                    isSessionActive = true;
                    console.log('Session loaded. Resuming test.');
                    return true;
                } else {
                    localStorage.removeItem('satQuizSession');
                    isSessionActive = false;
                    return false;
                }
            }
            return false;
        }

        // Custom confirmation dialog (replaces alert/confirm)
        function showCustomConfirm(message) {
            return new Promise(resolve => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modalOverlay.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <p class="text-lg font-semibold mb-4">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                            <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('confirmYes').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });
                document.getElementById('confirmNo').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(false);
                });
            });
        }

        // Function to update the disabled state of the buttons
        function updateMainButtonsState(isDisabled) {
            document.querySelectorAll('#categoryButtonsContainer button').forEach(button => {
                button.disabled = isDisabled;
                button.classList.toggle('opacity-50', isDisabled);
                button.classList.toggle('cursor-not-allowed', isDisabled);
                button.classList.toggle('hover:bg-blue-700', !isDisabled);
                button.classList.toggle('hover:scale-105', !isDisabled);
            });
            fullTestBtn.disabled = isDisabled;
            fullTestBtn.classList.toggle('opacity-50', isDisabled);
            fullTestBtn.classList.toggle('cursor-not-allowed', isDisabled);
            fullTestBtn.classList.toggle('hover:bg-indigo-700', !isDisabled);
            fullTestBtn.classList.toggle('hover:scale-105', !isDisabled);
            showCompletedTestsBtn.disabled = isDisabled;
            showCompletedTestsBtn.classList.toggle('opacity-50', isDisabled);
            showCompletedTestsBtn.classList.toggle('cursor-not-allowed', isDisabled);
            showCompletedTestsBtn.classList.toggle('hover:bg-gray-600', !isDisabled);
            showCompletedTestsBtn.classList.toggle('hover:scale-105', !isDisabled);
            excludeTopicsBtn.disabled = isDisabled;
            excludeTopicsBtn.classList.toggle('opacity-50', isDisabled);
            excludeTopicsBtn.classList.toggle('cursor-not-allowed', isDisabled);
            excludeTopicsBtn.classList.toggle('hover:bg-purple-700', !isDisabled);
        }

        // Function to log out the user and reset the app state
        function logoutUser(saveCurrent = true) {
            if (saveCurrent) {
                saveSession();
            } else {
                localStorage.removeItem('satQuizSession');
            }
            
            isSessionActive = false;
            isFullTest = false;
            updateMainButtonsState(false);

            // Hide app content and show login screen
            appContent.style.display = 'none';
            loginScreen.style.display = 'block';
            passwordInput.value = '';
            loginError.style.display = 'none';

            // Reset application state
            allGeneratedQuestions = {};
            completedQuestions = [];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            currentReviewingTest = null;
            categoriesArray = [];
            questionStartTime = 0;

            // Hide all buttons that appear after login/generation
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            questionsContainer.innerHTML = '';
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            timerContainer.style.display = 'none';

            // Stop any existing timers
            clearTimeout(inactivityTimer);
            clearInterval(generationCountdownInterval);
            clearInterval(fullTestInterval);
        }

        // Event listeners for user activity to reset the timer
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        document.addEventListener('scroll', resetInactivityTimer);

        // Initial check for activity when the page loads
        resetInactivityTimer();

        // Function to generate the category buttons
        function createCategoryButtons() {
            categoryButtonsContainer.innerHTML = '';
            Object.keys(categories).forEach(categoryTitle => {
                const categoryKey = categories[categoryTitle];
                const button = document.createElement('button');
                button.id = `generateBtn-${categoryKey}`;
                button.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75';
                button.textContent = categoryTitle;
                button.addEventListener('click', () => handleNewTest(categoryKey));
                categoryButtonsContainer.appendChild(button);
            });
        }

        // Login function
        loginBtn.addEventListener('click', async () => {
            if (CORRECT_PASSWORDS.includes(passwordInput.value)) {
                loginScreen.style.display = 'none';
                appContent.style.display = 'block';
                loginError.style.display = 'none';
                
                createCategoryButtons();
                const sessionResumed = await loadSession();
                if (sessionResumed) {
                    displayCurrentQuestion();
                    nextBtn.style.display = 'block';
                    // Conditional display for save/exit button
                    saveAndExitBtn.style.display = isFullTest ? 'none' : 'block';
                    nextBtn.disabled = true;
                    nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    if (isFullTest) {
                        startFullTestTimer();
                        timerContainer.style.display = 'flex';
                    }
                } else {
                    questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите на кнопку категории, чтобы начать новый тест, или "Полный тест с контролем времени".</p>';
                }
                updateMainButtonsState(isSessionActive);
                resetInactivityTimer();
            } else {
                loginError.style.display = 'block';
            }
        });

        // Allow pressing Enter key to login
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loginBtn.click();
            }
        });
        
        // Function to start the generation countdown timer
        function startGenerationCountdown() {
            let timeLeft = GENERATION_COUNTDOWN_SECONDS;
            const timerElement = document.getElementById('timer');
            timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;

            generationCountdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;
                } else {
                    clearInterval(generationCountdownInterval);
                    timerElement.textContent = 'Время вышло, генерация продолжается...';
                }
            }, 1000);
        }

        // Function to start the full test timer
        function startFullTestTimer() {
            clearInterval(fullTestInterval);
            timerContainer.style.display = 'flex';

            fullTestInterval = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                fullTestTimer.textContent = `Осталось: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    clearInterval(fullTestInterval);
                    endQuizTimedOut();
                }
            }, 1000);
        }

        // Function to show loading indicator
        function showLoading(message) {
            questionsContainer.innerHTML = '';
            loadingIndicator.innerHTML = `
                <p class="text-xl font-semibold mb-4 text-gray-700">${message}</p>
                <div id="timer" class="text-md font-medium text-gray-500 mb-4"></div>
                <div class="mt-4">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-gray-900 mx-auto"></div>
                </div>
            `;
            loadingIndicator.style.display = 'block';
            
            updateMainButtonsState(true);

            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            timerContainer.style.display = 'none';
            
            clearInterval(generationCountdownInterval);
            startGenerationCountdown();
        }

        // Function to hide loading indicator
        function hideLoading() {
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            clearInterval(generationCountdownInterval);
        }
        
        // NEW: Functions for managing excluded topics
        function getExcludedTopics() {
            const excludedTopics = localStorage.getItem('excludedTopics');
            return excludedTopics ? JSON.parse(excludedTopics) : [];
        }

        function saveExcludedTopics(topics) {
            localStorage.setItem('excludedTopics', JSON.stringify(topics));
        }

        function renderExcludedTopicsList() {
            const topics = getExcludedTopics();
            excludedTopicsList.innerHTML = '';
            if (topics.length === 0) {
                excludedTopicsList.innerHTML = '<p class="text-gray-500 text-center text-sm">Нет исключенных тем.</p>';
                return;
            }

            topics.forEach(topic => {
                const topicItem = document.createElement('div');
                topicItem.className = 'flex items-center justify-between p-2 bg-white rounded-md shadow-sm border border-gray-200';
                topicItem.innerHTML = `
                    <span class="text-gray-800">${topic}</span>
                    <button class="delete-topic-btn bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-2 rounded-full transition duration-200" data-topic="${topic}">
                        Удалить
                    </button>
                `;
                excludedTopicsList.appendChild(topicItem);
            });
        }
        
        // Event listeners for the new modal
        excludeTopicsBtn.addEventListener('click', () => {
            renderExcludedTopicsList();
            excludeTopicsModal.classList.remove('hidden');
        });

        // FIX: Use the correct variable name
        cancelExcludeBtnEl.addEventListener('click', () => {
            excludeTopicsModal.classList.add('hidden');
        });
        
        addTopicBtn.addEventListener('click', () => {
            const topic = topicInput.value.trim();
            if (topic) {
                const topics = getExcludedTopics();
                if (!topics.includes(topic)) {
                    topics.push(topic);
                    saveExcludedTopics(topics);
                    renderExcludedTopicsList();
                }
                topicInput.value = '';
            }
        });
        
        excludedTopicsList.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-topic-btn')) {
                const topicToDelete = event.target.dataset.topic;
                const topics = getExcludedTopics();
                const updatedTopics = topics.filter(t => t !== topicToDelete);
                saveExcludedTopics(updatedTopics);
                renderExcludedTopicsList();
            }
        });
        
        // Helper function to get the correct number of vocabulary words
        function getVocabCount(difficulty) {
            switch(difficulty) {
                case 'easy':
                    return 4;
                case 'hard':
                    return 6;
                case 'gre_gmat':
                    return 8;
                default:
                    return 4; // Default to easy
            }
        }

        // Function to generate multiple questions for a given category with exponential backoff
        async function generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, retries = 0) {
            const MAX_RETRIES = 5;
            const BASE_DELAY_MS = 1000;
            
            // The number of questions to generate per category.
            const numberOfQuestions = 7; 
            const vocabCount = getVocabCount(difficulty);

            const excludedTopics = getExcludedTopics();
            let prompt = "";
            
            let difficultyModifier;
            let wordCountRange;
            if (difficulty === 'easy') {
                difficultyModifier = 'straightforward';
                wordCountRange = '40-60';
            } else if (difficulty === 'hard') {
                difficultyModifier = 'challenging';
                wordCountRange = '60-80';
            } else if (difficulty === 'gre_gmat') {
                difficultyModifier = 'highly challenging';
                wordCountRange = '100-150';
            }
            
            const excludeText = excludedTopics && excludedTopics.length > 0 ? `Explicitly and strictly avoid passages and questions on the following topics: ${excludedTopics.join(', ')}. It is critical that no generated content relates to these topics.` : '';
            
            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        passage: { type: "STRING" },
                        question: { type: "STRING" },
                        options: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    label: { type: "STRING" },
                                    text: { type: "STRING" }
                                },
                                required: ["label", "text"]
                            }
                        },
                        correct_answer: { type: "STRING" },
                        explanation: { type: "STRING" },
                        vocabulary: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    word: { "type": "STRING" },
                                    translation: { "type": "STRING" },
                                    synonyms: { "type": "STRING" },
                                },
                                required: ["word", "translation", "synonyms"]
                            }
                        }
                    },
                    required: ["passage", "question", "options", "correct_answer", "explanation"]
                }
            };
            
            switch (categoryKey) {
                case "information_ideas":
                    prompt = `
                        Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Information and Ideas" questions in English, each based on a new and distinct topic. ${excludeText}
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. Passages must be fresh and not repeat previous topics within this generation request.
                        2. A specific SAT-style question in English based on the passage, designed to test a particular skill.
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. The "NO CHANGE" option must not be included.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                    `;
                    break;
                case "craft_structure":
                    prompt = `
                        Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Craft and Structure" questions in English, each based on a new and distinct topic. ${excludeText}
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. For Cross-text Connection questions, provide two distinct, short passages. The passages must be fresh and not repeat previous topics within this generation request.
                        2. A specific SAT-style question in English based on the passage(s).
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. The "NO CHANGE" option must not be included.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                    `;
                    break;
                case "expression_ideas":
                    prompt = `
                        Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Expression of Ideas" questions in English, each based on a new and distinct topic, such as a student's essay draft about the social impact of a new technology, an analysis of a classic piece of music, or a research proposal on a historical event. The passages must be fresh and not repeat previous topics within this generation request.
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. One sentence in the passage must have a blank space for a transition, represented by exactly three underscores (e.g., "People often speak of the philosophy of the ancient Greeks or what the Greeks believed, as though they had a single shared opinion. ___ Greek philosophers held a great diversity of opinions...").
                        2. A specific SAT-style question in English, with the exact wording: "Which choice completes the text with the most logical transition?".
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. Each choice should be a single transition word or phrase (e.g., "Ancient", "Meanwhile, ancient", "Consequently, ancient", "However, ancient"). The "NO CHANGE" option must not be included.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                    `;
                    break;
                case "standard_english_conventions":
                    // Обновленный запрос: явно указывает не использовать "NO CHANGE".
                    prompt = `
                        Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Standard English Conventions" questions in English, each based on a new and distinct topic. ${excludeText} For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, such as a historical account of a battle, a technical manual for a tool, or a biographical sketch of an artist. Each passage must contain a specific grammatical or punctuation error. The passages must be fresh and not repeat previous topics within this generation request.
                        2. A SAT-style question in English that asks the user to correct the error. The questions must cover a variety of the following rules:
                           - Subject-verb agreement
                           - Subject pronoun agreement
                           - Comma subject rule
                           - Punctuation on the SAT
                           - Apostrophe
                           - Listing
                           - Introduction of a list or description
                           - Comparison
                           - Tense
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. None of the options should be "NO CHANGE". The correct answer will always be one of the provided revisions.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                        
                        The part of the passage with the grammatical error should be replaced with a blank line, represented by three underscores (e.g., ___). It is critical that you use exactly three underscores, nothing more and nothing less.
                    `;
                    break;
            }

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    }
                };

                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                // Check for HTTP errors
                if (!response.ok) {
                    const errorDetails = await response.text();
                    throw new Error(`HTTP Error: ${response.status} ${response.statusText}. Details: ${errorDetails}`);
                }
                
                const result = await response.json();

                // Используем новую надежную функцию для парсинга JSON
                const questionsArray = parseApiResponse(result?.candidates?.[0]?.content?.parts?.[0]?.text || "[]");
                
                if (!Array.isArray(questionsArray)) {
                    throw new Error("API не вернул массив JSON вопросов.");
                }
                return questionsArray;
            } catch (error) {
                console.error(`Ошибка генерации вопросов для ${categoryTitle} (Уровень: ${difficulty}):`, error);
                
                if (retries < MAX_RETRIES) {
                    const delay = BASE_DELAY_MS * Math.pow(2, retries) + (Math.random() * 100);
                    console.warn(`Повторная попытка генерации вопросов для ${categoryTitle} через ${delay} мс (попытка ${retries + 1}/${MAX_RETRIES})...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, retries + 1);
                } else {
                    hideLoading();
                    questionsContainer.innerHTML = `<p class="text-center text-red-600 font-bold text-lg">Ошибка генерации вопросов. Пожалуйста, попробуйте еще раз.</p>`;
                    updateMainButtonsState(false);
                    return null;
                }
            }
        }

        // --- Core Quiz Logic ---
        
        // This function handles a single category quiz or one module of the full test
        async function handleNewTest(categoryKey) {
            isFullTest = false;
            categoriesArray = [categoryKey];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            isSessionActive = true;
            completedQuestions = [];
            
            showLoading("Генерация вопросов... Пожалуйста, подождите.");
            
            try {
                const questions = await generateQuestionsForCategory(Object.keys(categories).find(key => categories[key] === categoryKey), categoryKey, difficultySelect.value);
                if (questions) {
                    allGeneratedQuestions = { [categoryKey]: questions };
                    hideLoading();
                    displayCurrentQuestion();
                    nextBtn.style.display = 'block';
                    saveAndExitBtn.style.display = 'block';
                    updateMainButtonsState(true);
                }
            } catch (error) {
                hideLoading();
                questionsContainer.innerHTML = `<p class="text-center text-red-600 font-bold text-lg">Ошибка при загрузке вопросов: ${error.message}</p>`;
                updateMainButtonsState(false);
            }
        }
        
        async function handleFullTest() {
            isFullTest = true;
            categoriesArray = Object.keys(categories).sort(() => 0.5 - Math.random());
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            isSessionActive = true;
            completedQuestions = [];
            timeLeft = FULL_TEST_DURATION_SECONDS;

            questionsContainer.innerHTML = '';
            showLoading("Генерация полного теста...");
            
            try {
                for (const categoryKey of categoriesArray) {
                    const questions = await generateQuestionsForCategory(Object.keys(categories).find(key => categories[key] === categoryKey), categoryKey, difficultySelect.value);
                    if (questions) {
                        allGeneratedQuestions[categoryKey] = questions;
                    } else {
                         // Stop if generation fails for any category
                         throw new Error(`Failed to generate questions for category: ${categoryKey}`);
                    }
                }
                
                hideLoading();
                displayCurrentQuestion();
                nextBtn.style.display = 'block';
                saveAndExitBtn.style.display = 'none'; // No saving during full test
                updateMainButtonsState(true);
                startFullTestTimer();
            } catch (error) {
                hideLoading();
                questionsContainer.innerHTML = `<p class="text-center text-red-600 font-bold text-lg">Ошибка при загрузке полного теста: ${error.message}</p>`;
                updateMainButtonsState(false);
            }
        }
        
        fullTestBtn.addEventListener('click', handleFullTest);

        function displayCurrentQuestion() {
            if (!isSessionActive) {
                return;
            }
            
            // Check if we have questions for the current category
            const currentCategory = categoriesArray[currentCategoryIndex];
            if (!allGeneratedQuestions[currentCategory] || allGeneratedQuestions[currentCategory].length === 0) {
                console.error("No questions for the current category.");
                endQuiz();
                return;
            }

            const questions = allGeneratedQuestions[currentCategory];

            // Check if we are at the end of the current module
            if (currentQuestionIndex >= questions.length) {
                if (isFullTest) {
                    // Move to the next module
                    currentCategoryIndex++;
                    currentQuestionIndex = 0;
                    if (currentCategoryIndex < categoriesArray.length) {
                        displayCurrentQuestion(); // Recurse to display the first question of the new module
                        return; // Exit
                    } else {
                        // All modules completed
                        endQuiz();
                        return;
                    }
                } else {
                    // Single category test completed
                    endQuiz();
                    return;
                }
            }
            
            const questionData = questions[currentQuestionIndex];
            questionsContainer.innerHTML = renderQuestion(questionData, currentQuestionIndex + 1, questions.length);
            questionStartTime = Date.now();
            
            // Enable the 'Next' button after a selection is made
            nextBtn.disabled = true;
            nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }

        // Handles user selecting an answer
        function handleAnswerSelection(event, questionIndex, categoryKey) {
            const selectedOption = event.target.closest('.option-item');
            if (!selectedOption) return;

            const userChoice = selectedOption.dataset.label;
            const questionData = allGeneratedQuestions[categoryKey][questionIndex];
            
            // Save the user's answer and time taken
            const timeTaken = (Date.now() - questionStartTime) / 1000;
            
            // Ensure we don't save duplicate answers if user clicks multiple times
            if (!completedQuestions.find(q => q.question.question === questionData.question)) {
                completedQuestions.push({
                    question: questionData,
                    userAnswer: userChoice,
                    timeTaken: timeTaken,
                    isCorrect: userChoice === questionData.correct_answer
                });
            }

            // Apply visual feedback and disable other options
            const options = selectedOption.parentNode.querySelectorAll('.option-item');
            options.forEach(option => {
                option.classList.add('disabled');
                const label = option.dataset.label;
                if (label === questionData.correct_answer) {
                    option.classList.add('correct');
                }
                if (label === userChoice && userChoice !== questionData.correct_answer) {
                    option.classList.add('incorrect');
                }
            });

            // Show explanation
            const explanationElement = document.getElementById(`explanation-${questionIndex}`);
            if (explanationElement) {
                explanationElement.style.display = 'block';
            }

            // Enable next button
            nextBtn.disabled = false;
            nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        }

        function renderQuestion(questionData, number, total) {
            let passageHtml = questionData.passage;
            let questionText = questionData.question;
            
            // The prompt for 'Expression of Ideas' still includes the blank space (___)
            // which needs to be handled.
            if (passageHtml.includes('___')) {
                // Get the text that follows the blank, for a more accurate presentation
                const blankIndex = passageHtml.indexOf('___');
                const textAfterBlank = passageHtml.substring(blankIndex + 3).trim();
                const firstWordMatch = textAfterBlank.match(/^[a-zA-Z]+/);
                
                if (firstWordMatch) {
                    const firstWord = firstWordMatch[0];
                    // Append the word that follows the blank to the question.
                    questionText = `Which choice completes the text with the most logical transition? ${firstWord}`;
                }
            }


            // Handle vocabulary tooltips
            if (questionData.vocabulary && questionData.vocabulary.length > 0) {
                questionData.vocabulary.forEach(vocab => {
                    const regex = new RegExp(`\\b${vocab.word}\\b`, 'g');
                    passageHtml = passageHtml.replace(regex, `<span class="tooltip-container">${vocab.word}<span class="tooltip-text">${vocab.translation}<br>Синонимы: ${vocab.synonyms}</span></span>`);
                });
            }
            
            // Handle SVG graphics if they exist
            let graphicHtml = '';
            if (questionData.graphic) {
                graphicHtml = `<div class="svg-container">${questionData.graphic}</div>`;
            }

            const optionsHtml = questionData.options.map((option, index) => {
                const label = labels[index];
                return `
                    <div class="option-item flex items-start space-x-2 p-2" data-label="${label}">
                        <div class="font-bold w-6">${label}.</div>
                        <div class="flex-1">${option.text}</div>
                    </div>
                `;
            }).join('');

            return `
                <div id="question-card-${number - 1}" class="question-card">
                    <p class="text-lg font-semibold mb-2 text-gray-800">Вопрос ${number} из ${total}</p>
                    ${graphicHtml}
                    <p class="question-passage">${passageHtml}</p>
                    <p class="question-text">${questionText}</p>
                    <div class="options-container">
                        ${optionsHtml}
                    </div>
                    <div id="explanation-${number - 1}" class="explanation">
                        <p class="font-semibold">Объяснение:</p>
                        <p>${questionData.explanation}</p>
                    </div>
                </div>
            `;
        }
        
        questionsContainer.addEventListener('click', (event) => {
            const optionItem = event.target.closest('.option-item');
            if (optionItem && !optionItem.classList.contains('disabled')) {
                const questionCard = event.target.closest('.question-card');
                const questionIndex = parseInt(questionCard.id.split('-')[2]);
                const currentCategory = categoriesArray[currentCategoryIndex];
                handleAnswerSelection(event, questionIndex, currentCategory);
            }
        });
        
        nextBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            displayCurrentQuestion();
            if (isFullTest && currentQuestionIndex >= allGeneratedQuestions[categoriesArray[currentCategoryIndex]].length && currentCategoryIndex + 1 >= categoriesArray.length) {
                endQuiz();
            }
        });

        // --- FIX: The "Save and Exit" button now correctly saves the session and returns to the main screen. ---
        saveAndExitBtn.addEventListener('click', () => {
            logoutUser(true); // Saves the session and resets the UI
        });
        // --- END FIX ---


        // Function to handle the end of a quiz
        function endQuiz() {
            // FIX: Ensure completedQuestions is fully populated before saving.
            // This is the correct place to call the save function.
            saveCompletedTest(); 
            
            isSessionActive = false;
            updateMainButtonsState(false);
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            
            // Stop full test timer
            if (isFullTest) {
                clearInterval(fullTestInterval);
                timerContainer.style.display = 'none';
            }
            
            // Clear the current session data now that it's saved to the completed list
            localStorage.removeItem('satQuizSession');

            showSummaryScreen();
        }

        // Function to handle quiz end due to time out
        async function endQuizTimedOut() {
            isSessionActive = false;
            updateMainButtonsState(false);
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            timerContainer.style.display = 'none';
            
            await showCustomConfirm('Время вышло! Ваш тест будет сохранен, и вы сможете просмотреть его в разделе "Завершенные тесты".');
            
            // Save the session and log out without a warning
            saveSession();
            logoutUser(false);
        }

        function showSummaryScreen() {
            const correctCount = completedQuestions.filter(q => q.isCorrect).length;
            const totalQuestions = completedQuestions.length;
            const completionMessage = `Вы завершили тест. Правильных ответов: ${correctCount} из ${totalQuestions}.`;
            
            questionsContainer.innerHTML = `
                <div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4 mb-6 rounded-lg shadow-md" role="alert">
                    <p class="font-bold text-lg">Тест завершен!</p>
                    <p>${completionMessage}</p>
                </div>
                <p class="text-center text-gray-600">Вы можете просмотреть свои результаты и объяснения в разделе "Завершенные тесты".</p>
            `;
            
            // The `saveCompletedTest` call has been moved to `endQuiz`
        }

        // --- Completed Tests Functionality ---
        showCompletedTestsBtn.addEventListener('click', showCompletedTestsList);
        backToMainBtn.addEventListener('click', () => {
            completedTestsScreen.style.display = 'none';
            appContent.style.display = 'block';
            updateMainButtonsState(isSessionActive);
        });

        function getCompletedTests() {
            const tests = localStorage.getItem('completedSATTests');
            return tests ? JSON.parse(tests) : [];
        }

        // FIX: Добавлена проверка на наличие вопросов перед сохранением
        function saveCompletedTest() {
            if (completedQuestions.length === 0) {
                console.warn("Невозможно сохранить тест: список вопросов пуст.");
                return;
            }

            const completedTests = getCompletedTests();
            const newTest = {
                id: Date.now(),
                date: new Date().toLocaleString(),
                questions: completedQuestions,
                difficulty: difficultySelect.value,
                isFullTest: isFullTest,
                category: isFullTest ? 'Full Test' : Object.keys(categories).find(key => categories[key] === categoriesArray[0]),
                correctCount: completedQuestions.filter(q => q.isCorrect).length,
                totalQuestions: completedQuestions.length
            };
            completedTests.unshift(newTest);
            localStorage.setItem('completedSATTests', JSON.stringify(completedTests));
            console.log("Тест успешно сохранен в 'completedSATTests'!");
        }

        function showCompletedTestsList() {
            appContent.style.display = 'none';
            completedTestsScreen.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            
            const tests = getCompletedTests();
            testsListContainer.innerHTML = '';
            
            if (tests.length === 0) {
                testsListContainer.innerHTML = `<p class="text-center text-gray-500">Пока нет завершенных тестов.</p>`;
                return;
            }
            
            tests.forEach(test => {
                const testCard = document.createElement('div');
                testCard.className = 'completed-test-card';
                testCard.innerHTML = `
                    <p class="text-lg font-bold text-gray-800">${test.category} - ${test.date}</p>
                    <p class="text-sm text-gray-600">Сложность: ${test.difficulty}</p>
                    <p class="text-md font-semibold mt-2">Правильных ответов: ${test.correctCount} из ${test.totalQuestions}</p>
                `;
                testCard.addEventListener('click', () => showTestReview(test));
                testsListContainer.appendChild(testCard);
            });
        }
        
        function showTestReview(test) {
            currentReviewingTest = test;
            testsListContainer.style.display = 'none';
            completedTestDetailsContainer.style.display = 'block';
            
            const reviewHtml = test.questions.map((q, index) => {
                const questionData = q.question;
                const userChoice = q.userAnswer;
                const isCorrect = q.isCorrect;
                
                // Construct the passage HTML with vocabulary tooltips and bolding
                let passageHtml = questionData.passage;
                if (questionData.vocabulary && questionData.vocabulary.length > 0) {
                    questionData.vocabulary.forEach(vocab => {
                        const regex = new RegExp(`\\b${vocab.word}\\b`, 'g');
                        passageHtml = passageHtml.replace(regex, `<span class="tooltip-container">${vocab.word}<span class="tooltip-text">${vocab.translation}<br>Синонимы: ${vocab.synonyms}</span></span>`);
                    });
                }
                
                // Handle SVG graphics
                let graphicHtml = '';
                if (questionData.graphic) {
                    graphicHtml = `<div class="svg-container">${questionData.graphic}</div>`;
                }

                const optionsHtml = questionData.options.map((option, optionIndex) => {
                    const label = labels[optionIndex];
                    let optionClasses = 'p-2 rounded-md';
                    if (label === questionData.correct_answer) {
                        optionClasses += ' bg-green-200 border-green-500';
                    }
                    if (label === userChoice && !isCorrect) {
                        optionClasses += ' bg-red-200 border-red-500';
                    }
                    
                    return `
                        <div class="${optionClasses}">
                            <span class="font-bold">${label}.</span> ${option.text}
                            ${label === userChoice ? '<span class="user-answer ml-2">(Ваш ответ)</span>' : ''}
                        </div>
                    `;
                }).join('');
                
                return `
                    <div class="completed-test-details-question-card">
                        <p class="text-md font-semibold mb-2">Вопрос ${index + 1}:</p>
                        ${graphicHtml}
                        <p class="question-passage">${passageHtml}</p>
                        <p class="question-text">${questionData.question}</p>
                        <div class="space-y-2 mb-4">
                            ${optionsHtml}
                        </div>
                        <div class="explanation">
                            <p class="font-semibold">Объяснение:</p>
                            <p>${questionData.explanation}</p>
                        </div>
                    </div>
                `;
            }).join('');

            testReviewContainer.innerHTML = `
                <h2 class="text-3xl font-bold text-gray-800 mb-4">${test.category} Тест - Результаты</h2>
                <div class="bg-gray-100 p-4 rounded-lg mb-6">
                    <p class="font-semibold">Дата: ${test.date}</p>
                    <p class="font-semibold">Сложность: ${test.difficulty}</p>
                    <p class="font-semibold">Правильных ответов: ${test.correctCount} из ${test.totalQuestions}</p>
                </div>
                ${reviewHtml}
            `;
        }
        
        backToTestsBtn.addEventListener('click', () => {
            testsListContainer.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            showCompletedTestsList();
        });

        deleteTestBtn.addEventListener('click', async () => {
            if (currentReviewingTest) {
                const confirmation = await showCustomConfirm('Вы уверены, что хотите удалить этот тест? Это действие необратимо.');
                if (confirmation) {
                    let tests = getCompletedTests();
                    tests = tests.filter(t => t.id !== currentReviewingTest.id);
                    localStorage.setItem('completedSATTests', JSON.stringify(tests));
                    showCompletedTestsList();
                }
            }
        });

        // --- Initial app setup ---
        if (loginScreen.style.display === 'block') {
            questionsContainer.innerHTML = '';
        }

    </script>
</body>
</html>
