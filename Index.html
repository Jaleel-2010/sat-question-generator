<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор вопросов SAT</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%; /* Ensure container takes full width on smaller screens */
        }
        .section-title {
            border-bottom: 2px solid #cbd5e1; /* Light gray border */
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .question-card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0; /* Light border */
        }
        .question-passage {
            font-style: italic;
            color: #4a5568; /* Dark gray text */
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .question-image {
            /* Убедитесь, что изображение адаптивно и не превышает ширину родительского элемента */
            max-width: 100%;
            height: auto;
            margin: 1rem auto;
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .question-text {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2d3748; /* Darker gray text */
        }
        .option-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            border-radius: 0.5rem;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 1px solid transparent; /* Default transparent border */
        }
        .option-item:hover:not(.disabled) {
            background-color: #f3f4f6; /* Light gray on hover */
        }
        .option-item.correct {
            background-color: #d1fae5; /* Light green for correct answer */
            border-color: #34d399; /* Green border */
            font-weight: 500;
        }
        .option-item.incorrect {
            background-color: #fee2e2; /* Light red for incorrect answer */
            border-color: #ef4444; /* Red border */
            font-weight: 500;
        }
        .option-item.disabled {
            pointer-events: none; /* Disable clicks */
            opacity: 0.8; /* Slightly dim disabled options */
        }
        .explanation {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #e2e8f0;
            font-size: 0.9rem;
            color: #4a5568;
            display: none; /* Hidden by default */
        }
        .login-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .login-button {
            width: 100%;
            background-color: #4299e1; /* Blue */
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #3182ce; /* Darker blue */
        }
        .error-message {
            color: #ef4444;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #94a3b8; /* Dotted underline for tooltip words */
        }
        .tooltip-text {
            visibility: hidden;
            width: auto; /* Adjust width based on content */
            max-width: 500px; /* Changed: Increased max-width for more words */
            background-color: #333;
            color: #fff;
            text-align: left; /* Changed: Align text to left for multi-line */
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 100; /* Ensure tooltip is on top */
            bottom: 125%; /* Position above the text */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Changed: Allow text wrapping */
            word-wrap: break-word; /* Added: Ensure long words break */
            font-size: 0.85rem;
            pointer-events: none; /* Allow clicks to pass through tooltip when not hovered */
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        /* New styles for completed tests screen */
        .completed-tests-screen {
            background-color: #f0f4f8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }
        .completed-test-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .completed-test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .completed-test-card-details {
            border-left: 4px solid #3b82f6; /* Blue border for details */
            padding-left: 1rem;
            margin-top: 1rem;
        }
        .user-answer {
            font-weight: 500;
        }
        .completed-test-details-question-card {
            background-color: #f8fafc;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
        }
        /* Style for SVG graphs */
        .question-svg {
            margin: 1rem auto;
            display: block;
            max-width: 100%;
            height: auto;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="loginScreen" class="login-container">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">Welcome to Jaleel's Verbal SAT Question Generator</h2>
        <input type="password" id="passwordInput" class="login-input" placeholder="Введите пароль">
        <button id="loginBtn" class="login-button">Войти</button>
        <p id="loginError" class="error-message" style="display: none;">Неверный пароль. Попробуйте снова.</p>
    </div>

    <div id="appContent" class="container" style="display: none;">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Генератор вопросов SAT (Verbal Section)</h1>

        <div class="mb-6">
            <label for="difficultySelect" class="block text-gray-700 text-sm font-bold mb-2">Выберите уровень сложности:</label>
            <select id="difficultySelect" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500">
                <option value="easy" selected>Облегченный уровень (Easier Module)</option>
                <option value="hard">Усложненный уровень (Harder Module 2)</option>
            </select>
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mb-4">
            <button id="generateBtn" class="w-full sm:w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75">
                Сгенерировать вопросы
            </button>
            <button id="showCompletedTestsBtn" class="w-full sm:w-1/2 bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75" disabled>
                Завершенные тесты
            </button>
        </div>
        
        <div id="loadingIndicator" class="loading-indicator text-center" style="display: none;">
            <!-- Questions will be loaded here -->
        </div>

        <div id="questionsContainer" class="space-y-10">
            <!-- Questions will be loaded here -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mt-4">
            <button id="nextBtn" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                Следующий вопрос
            </button>
            <button id="saveAndExitBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" style="display: none;">
                Сохранить и выйти
            </button>
        </div>
    </div>

    <div id="completedTestsScreen" class="completed-tests-screen" style="display: none;">
        <button id="backToMainBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
            &larr; Назад в главное окно
        </button>
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Завершенные тесты</h1>
        <div id="testsListContainer" class="space-y-4">
            <!-- Completed tests will be listed here -->
        </div>
        <div id="completedTestDetailsContainer" class="mt-8" style="display: none;">
            <button id="backToTestsBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
                &larr; Назад к списку тестов
            </button>
            <!-- New delete button added here -->
            <button id="deleteTestBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mb-4 ml-4 transition duration-200 ease-in-out">
                Удалить тест
            </button>
            <div id="testReviewContainer">
                <!-- Detailed test review will be displayed here -->
            </div>
        </div>
    </div>

    <script type="module">
        // Import the Google Generative AI library
        import { GoogleGenerativeAI } from 'https://esm.sh/@google/generative-ai';

        // Initialize Firebase (required for Canvas environment, even if not directly used for auth in this example)
        // This ensures __app_id and __firebase_config are handled correctly.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        const apiKey = "AIzaSyB6HddnRBVrrWDr_ujKlFx7ZQST1RzvcZs";
        
        // Initialize Google Generative AI
        const genAI = new GoogleGenerativeAI(apiKey);
        const textModel = genAI.getGenerativeModel({ model: "gemini-2.5-flash-preview-05-20" });

        const loginScreen = document.getElementById('loginScreen');
        const passwordInput = document.getElementById('passwordInput');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const appContent = document.getElementById('appContent');

        const questionsContainer = document.getElementById('questionsContainer');
        const generateBtn = document.getElementById('generateBtn');
        const showCompletedTestsBtn = document.getElementById('showCompletedTestsBtn');
        const completedTestsScreen = document.getElementById('completedTestsScreen');
        const testsListContainer = document.getElementById('testsListContainer');
        const completedTestDetailsContainer = document.getElementById('completedTestDetailsContainer');
        const testReviewContainer = document.getElementById('testReviewContainer');
        const backToTestsBtn = document.getElementById('backToTestsBtn');
        const backToMainBtn = document.getElementById('backToMainBtn'); // New button
        const loadingIndicator = document.getElementById('loadingIndicator');
        const difficultySelect = document.getElementById('difficultySelect');
        const nextBtn = document.getElementById('nextBtn');
        const saveAndExitBtn = document.getElementById('saveAndExitBtn');
        const deleteTestBtn = document.getElementById('deleteTestBtn'); // New delete button

        const categories = {
            "Information and Ideas": "information_ideas",
            "Craft and Structure": "craft_structure",
            "Expression of Ideas": "expression_ideas",
            "Standard English Conventions": "standard_english_conventions"
        };
        const romanNumerals = ['I', 'II', 'III', 'IV'];

        // Global state to manage questions and current position
        let allGeneratedQuestions = {}; // Stores questions by category (e.g., { 'information_ideas': [q1, q2, q3, q4] })
        let completedQuestions = []; // Массив для хранения всех вопросов с ответами пользователя
        let categoriesArray = Object.keys(categories); // Array of category titles for ordered access
        let currentCategoryIndex = 0;
        let currentQuestionIndex = 0;
        let isSessionActive = false; // New state variable to track active session
        let currentReviewingTest = null; // New state variable to store the test currently being reviewed

        // Hardcoded password for client-side authentication
        const CORRECT_PASSWORD = "Jaleel2010";

        // Inactivity timer variables
        let inactivityTimer;
        // Inactivity timeout is now 5 minutes (5 * 60 * 1000 milliseconds)
        const INACTIVITY_TIMEOUT = 5 * 60 * 1000;
        
        // Countdown timer variables
        let countdownInterval;
        const COUNTDOWN_SECONDS = 90;

        // Function to reset the inactivity timer
        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(logoutUser, INACTIVITY_TIMEOUT);
        }

        // Function to save the current session state
        function saveSession() {
            if (Object.keys(allGeneratedQuestions).length > 0) { // Only save if questions have been generated
                const sessionData = {
                    categoryIndex: currentCategoryIndex,
                    questionIndex: currentQuestionIndex,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value,
                    completedQuestions: completedQuestions // Сохраняем уже отвеченные вопросы
                };
                localStorage.setItem('satQuizSession', JSON.stringify(sessionData));
                console.log('Session saved.');
            }
        }

        // Function to load a saved session state
        function loadSession() {
            const savedSession = localStorage.getItem('satQuizSession');
            if (savedSession) {
                const confirmation = showCustomConfirm('Обнаружена незавершенная сессия. Хотите продолжить с того места, где остановились?');
                
                return new Promise(resolve => {
                    confirmation.then(resume => {
                        if (resume) {
                            const sessionData = JSON.parse(savedSession);
                            currentCategoryIndex = sessionData.categoryIndex;
                            currentQuestionIndex = sessionData.questionIndex;
                            allGeneratedQuestions = sessionData.questions;
                            difficultySelect.value = sessionData.difficulty; // Set difficulty to saved one
                            completedQuestions = sessionData.completedQuestions || []; // Загружаем отвеченные вопросы
                            isSessionActive = true; // Set session active
                            console.log('Session loaded. Resuming test.');
                            resolve(true); // Session resumed
                        } else {
                            localStorage.removeItem('satQuizSession'); // Clear if user doesn't want to resume
                            isSessionActive = false; // No session active
                            console.log('Saved session discarded.');
                            resolve(false); // Session not resumed
                        }
                    });
                });
            }
            return Promise.resolve(false); // No session found, resolve with false
        }

        // Custom confirmation dialog (replaces alert/confirm)
        function showCustomConfirm(message) {
            return new Promise(resolve => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modalOverlay.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <p class="text-lg font-semibold mb-4">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                            <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('confirmYes').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });
                document.getElementById('confirmNo').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(false);
                });
            });
        }

        // Function to update the disabled state of the "Completed Tests" button
        function updateCompletedTestsBtnState() {
            if (isSessionActive) {
                showCompletedTestsBtn.disabled = true;
                showCompletedTestsBtn.classList.add('opacity-50', 'cursor-not-allowed');
                showCompletedTestsBtn.classList.remove('hover:bg-gray-600', 'hover:scale-105');
            } else {
                showCompletedTestsBtn.disabled = false;
                showCompletedTestsBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                showCompletedTestsBtn.classList.add('hover:bg-gray-600', 'hover:scale-105');
            }
        }

        // Function to log out the user and reset the app state
        function logoutUser(saveCurrent = true) { // Added parameter to control saving
            if (saveCurrent) {
                saveSession(); // Save session before logging out
            } else {
                localStorage.removeItem('satQuizSession'); // Clear session if not saving
            }
            
            isSessionActive = false;
            updateCompletedTestsBtnState();

            // Hide app content and show login screen
            appContent.style.display = 'none';
            loginScreen.style.display = 'block';
            passwordInput.value = ''; // Clear password field
            loginError.style.display = 'none'; // Hide any login error message

            // Reset application state (only if not saving or after saving)
            allGeneratedQuestions = {};
            completedQuestions = []; // Reset completed questions
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            currentReviewingTest = null;

            // Hide all buttons that appear after login/generation
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            generateBtn.disabled = false;
            generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            questionsContainer.innerHTML = ''; // Clear questions display
            loadingIndicator.style.display = 'none'; // Ensure loading indicator is hidden
            loadingIndicator.innerHTML = ''; // Clear loading message

            // Stop any existing inactivity timer and countdown timer
            clearTimeout(inactivityTimer);
            clearInterval(countdownInterval);
        }

        // Event listeners for user activity to reset the timer
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        document.addEventListener('scroll', resetInactivityTimer);

        // Initial check for activity when the page loads
        resetInactivityTimer();

        // Login function
        loginBtn.addEventListener('click', async () => { // Made async to await loadSession
            if (passwordInput.value === CORRECT_PASSWORD) {
                loginScreen.style.display = 'none';
                appContent.style.display = 'block';
                loginError.style.display = 'none';
                
                const sessionResumed = await loadSession(); // Await the promise
                if (sessionResumed) {
                    displayCurrentQuestion(); // Display the resumed question
                    // Ensure buttons are correctly displayed/enabled for resumed session
                    nextBtn.style.display = 'block';
                    saveAndExitBtn.style.display = 'block';
                    nextBtn.disabled = true; // Still disabled until answer is picked
                    nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    // If no session or user chose not to resume, start fresh
                    questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите "Сгенерировать вопросы", чтобы начать новый тест.</p>';
                    generateBtn.style.display = 'block'; // Ensure generate button is visible
                    nextBtn.style.display = 'none';
                    saveAndExitBtn.style.display = 'none';
                }
                updateCompletedTestsBtnState(); // Update button state on login
                resetInactivityTimer(); // Start timer after successful login
            } else {
                loginError.style.display = 'block';
            }
        });

        // Allow pressing Enter key to login
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loginBtn.click();
            }
        });
        
        // Function to start the countdown timer
        function startCountdown() {
            let timeLeft = COUNTDOWN_SECONDS;
            const timerElement = document.getElementById('timer');
            timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;

            countdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;
                } else {
                    clearInterval(countdownInterval);
                    timerElement.textContent = 'Время вышло, генерация продолжается...';
                }
            }, 1000);
        }

        // Function to show loading indicator
        function showLoading() {
            questionsContainer.innerHTML = ''; // Clear previous questions
            loadingIndicator.innerHTML = `
                <p class="text-xl font-semibold mb-4 text-gray-700">Генерация вопросов... это может занять несколько секунд.</p>
                <div id="timer" class="text-md font-medium text-gray-500 mb-4"></div>
                <div class="mt-4">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-gray-900 mx-auto"></div>
                </div>
            `;
            loadingIndicator.style.display = 'block'; // Make loading indicator visible
            generateBtn.disabled = true;
            generateBtn.classList.add('opacity-50', 'cursor-not-allowed');
            nextBtn.style.display = 'none'; // Hide next button during generation
            saveAndExitBtn.style.display = 'none'; // Hide save and exit button during generation
            
            clearInterval(countdownInterval); // Clear any old timer
            startCountdown(); // Start the new countdown
        }

        // Function to hide loading indicator
        function hideLoading() {
            loadingIndicator.style.display = 'none'; // Hide loading indicator
            loadingIndicator.innerHTML = ''; // Clear its content
            generateBtn.disabled = false;
            generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            clearInterval(countdownInterval); // Stop the countdown timer
        }

        // Function to generate multiple questions for a given category with exponential backoff
        async function generateQuestionsForCategory(categoryName, categoryKey, difficulty, retries = 0) {
            const MAX_RETRIES = 5;
            const BASE_DELAY_MS = 1000; // 1 second

            let prompt = "";
            const numberOfQuestions = 7; // We want 7 questions per category

            const difficultyModifier = difficulty === 'hard' ? 'challenging' : 'straightforward';
            const wordCountRange = difficulty === 'hard' ? '60-80' : '40-60';
            const analyticalSkill = difficulty === 'hard' ? 'deep analytical skills' : 'basic comprehension';
            const grammaticalNuance = difficulty === 'hard' ? 'complex grammatical error' : 'common grammatical error';

            // Define the JSON schema for the expected output
            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        passage: { type: "STRING" }, // Now optional for figure-based questions
                        svg_data: { type: "STRING" }, // New field for SVG data
                        question: { type: "STRING" },
                        options: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    label: { type: "STRING" },
                                    text: { type: "STRING" }
                                },
                                required: ["label", "text"]
                            }
                        },
                        correct_answer: { type: "STRING" },
                        explanation: { type: "STRING" },
                        vocabulary: { // New vocabulary field
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    word: { "type": "STRING" },
                                    translation: { "type": "STRING" },
                                    explanation: { "type": "STRING" } // Added explanation for vocabulary
                                },
                                required: ["word", "translation", "explanation"]
                            }
                        },
                        category: { type: "STRING" },
                        question_type: { type: "STRING" } // Added to distinguish question types
                    },
                    required: ["question_type", "question", "options", "correct_answer", "explanation", "category"]
                }
            };
            
            // --- UPDATED: More varied prompts for each category, with new SVG instruction ---
            const basePrompt = (passageType, questionType, highlightInstruction = '') => `
                Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryName}" questions.
                For each question, provide:
                1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, drawing from various styles and sources, such as: ${passageType}. The passages should be fresh and not repeat previous topics.
                2. A SAT-style "${questionType}" question based on the passage that requires ${analyticalSkill} to answer. The question and the answer options must be in English.
                3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                4. The correct answer label (e.g., "A").
                5. A brief explanation in Russian for the correct answer. **Пожалуйста, убедитесь, что все объяснения на русском языке написаны без грамматических и орфографических ошибок.**
                6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array. **Убедитесь, что все переводы и объяснения в 'vocabulary' также написаны на правильном русском языке.**
                7. Include the category name "${categoryName}" in a 'category' field and the question type in a 'question_type' field.
                ${highlightInstruction}
            `;

            switch (categoryKey) {
                case "information_ideas":
                    // UPDATED PROMPT: Even more explicit instructions for SVG generation and JSON structure
                    prompt = `Generate ${numberOfQuestions} unique and diverse SAT-style questions for the "Information and Ideas" category. The questions should be a mix of the following types: Direct Questions, Inference Questions, Main Idea Questions, Figure based Questions, Strengthen Weaken Questions, Poem based Questions, and Character Descriptions.
                    
                    For each question, provide a JSON object.
                    
                    For 'Figure based Questions', **you must provide a complete, well-formed, and valid SVG string in the 'svg_data' field**, and the 'passage' field should be an empty string. The SVG must be a simple bar chart, line graph, or pie chart with clear English labels, a title, and be visually clean. It must not contain any lorem ipsum or garbled text. The SVG must be a single, self-contained XML block that is ready to be injected into an HTML div.
                    
                    For all other question types, the 'svg_data' field should be an empty string, and you must provide a short, ${difficultyModifier} passage (${wordCountRange} words) in the 'passage' field.
                    
                    For all question types, provide:
                    1. A SAT-style question based on the passage or figure data that requires ${analyticalSkill} to answer. The question and the answer options must be in English.
                    2. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                    3. The correct answer label (e.g., "A").
                    4. A brief explanation in Russian for the correct answer. **Пожалуйста, убедитесь, что все объяснения на русском языке написаны без грамматических и орфографических ошибок.**
                    5. Identify 4-5 English words from the passage or question that would likely be rare or complex for a 9th-grade student. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array. **Убедитесь, что все переводы и объяснения в 'vocabulary' также написаны на правильном русском языке.**
                    6. Include the category name "Information and Ideas" in a 'category' field and the question type in a 'question_type' field.
                    The passages should be fresh and not repeat previous topics.`;
                    break;
                case "craft_structure":
                    prompt = `Generate ${numberOfQuestions} unique and diverse SAT-style questions for the "Craft and Structure" category. The questions should be a mix of the following types: Vocabulary in Context, Primary Purpose Questions, Purpose of a portion Questions, Structure Questions, Cross-text Connection Questions, and Quotes Illustrate Questions.
                    For each question, provide:
                    1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. For Cross-text questions, provide two short passages. For other questions, use one passage. The passages should be fresh and not repeat previous topics.
                    2. A SAT-style question based on the passage(s) that requires ${analyticalSkill} to answer, matching one of the requested types. The question and the answer options must be in English.
                    3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                    4. The correct answer label (e.g., "A").
                    5. A brief explanation in Russian for the correct answer. **Пожалуйста, убедитесь, что все объяснения на русском языке написаны без грамматических и орфографических ошибок.**
                    6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array. **Убедитесь, что все переводы и объяснения в 'vocabulary' также написаны на правильном русском языке.**
                    7. Include the category name "Craft and Structure" in a 'category' field and the question type in a 'question_type' field.`;
                    break;
                case "expression_ideas":
                    prompt = `Generate ${numberOfQuestions} unique and diverse SAT-style questions for the "Expression of Ideas" category. The questions should be a mix of the following types: Transition Questions and Goal-based Questions.
                    For each question, provide:
                    1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, such as a student's draft essay or a proposal that needs to be revised for logic and flow. The passages should be fresh and not repeat previous topics.
                    2. A SAT-style question based on the passage, matching one of the requested types. The question and the answer options must be in English. For Transition Questions, the question should ask which sentence or phrase best connects two ideas. For Goal-based Questions, the question should ask which change best achieves a stated goal (e.g., "The author wants to add a sentence to emphasize a point. Which of the following sentences would best achieve this goal?").
                    3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                    4. The correct answer label (e.g., "A").
                    5. A brief explanation in Russian for the correct answer. **Пожалуйста, убедитесь, что все объяснения на русском языке написаны без грамматических и орфографических ошибок.**
                    6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array. **Убедитесь, что все переводы и объяснения в 'vocabulary' также написаны на правильном русском языке.**
                    7. Include the category name "Expression of Ideas" in a 'category' field and the question type in a 'question_type' field.`;
                    break;
                case "standard_english_conventions":
                    // UPDATED PROMPT based on user's new list of topics
                    prompt = `Generate ${numberOfQuestions} unique and diverse SAT-style questions for the "Standard English Conventions" category. The questions should be a mix of the following types: Subject-verb agreement, Subject-pronoun agreement, Punctuation (including the comma subject rule, commas in lists, and introductions to lists), Apostrophe usage, Comparison rules, and Verb tense.
                    For each question, provide:
                    1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, such as a historical account, a technical manual, or a biographical sketch. The passages should be fresh and not repeat previous topics.
                    2. A SAT-style question based on the passage, matching one of the requested types. The question and the answer options must be in English.
                    3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                    4. The correct answer label (e.g., "A").
                    5. A brief explanation in Russian for the correct answer. **Пожалуйста, убедитесь, что все объяснения на русском языке написаны без грамматических и орфографических ошибок.**
                    6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array. **Убедитесь, что все переводы и объяснения в 'vocabulary' также написаны на правильном русском языке.**
                    7. Include the category name "Standard English Conventions" in a 'category' field and the question type in a 'question_type' field.
                    The part of the passage with the grammatical or punctuation error should be highlighted by enclosing it in double asterisks (e.g., **phrase with error**).`;
                    break;
            }

            try {
                // Use generationConfig to enforce JSON schema
                const result = await textModel.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    }
                });
                
                // The response should now be directly parsable JSON
                let questionsArray = JSON.parse(result.response.text());
                
                // Ensure the response is indeed an array
                if (!Array.isArray(questionsArray)) {
                    throw new Error("API did not return a JSON array of questions.");
                }
                
                // --- NEW LOGIC: Enforce the number of questions to be exactly 7 for Category 1 ---
                if (categoryKey === "information_ideas" && questionsArray.length !== numberOfQuestions) {
                    console.warn(`Category "${categoryName}" generated ${questionsArray.length} questions, but expected ${numberOfQuestions}. Trimming to the first ${numberOfQuestions}.`);
                    questionsArray = questionsArray.slice(0, numberOfQuestions);
                }

                return questionsArray; // Return the array of questions
            } catch (error) {
                console.error(`Error generating questions for ${categoryName} (Difficulty: ${difficulty}):`, error);
                
                // Implement exponential backoff for retries
                if (retries < MAX_RETRIES) {
                    const delay = BASE_DELAY_MS * Math.pow(2, retries) + (Math.random() * 100); // Add jitter
                    console.warn(`Retrying ${categoryName} question generation in ${delay}ms (retry ${retries + 1}/${MAX_RETRIES})...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return generateQuestionsForCategory(categoryName, categoryKey, difficulty, retries + 1);
                }

                let errorMessage = `<p class='text-red-600'>Произошла ошибка при генерации вопросов для категории "${categoryName}" (Уровень: ${difficulty === 'hard' ? 'Усложненный' : 'Облегченный'}). Пожалуйста, попробуйте еще раз.</p>`;

                if (error.message) {
                    if (error.message.includes("403") && error.message.includes("unregistered callers")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: Проблема с доступом к Gemini API (ошибка 403). Пожалуйста, убедитесь, что ваш API-ключ действителен и имеет необходимые разрешения для модели 'gemini-2.5-flash-preview-05-20' в Google Cloud Console.</p>";
                    } else if (error.message.includes("API key not valid")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: API ключ Gemini недействителен. Пожалуйста, убедитесь, что он правильно настроен в вашей среде.</p>";
                    } else if (error.message.includes("JSON")) {
                         errorMessage = `<p class='text-red-600'>Ошибка парсинга JSON для категории "${categoryName}". Модель вернула некорректный формат. Пожалуйста, попробуйте еще раз.</p>`;
                    }
                }
                loadingIndicator.innerHTML = errorMessage; // Display error message in loading indicator area
                hideLoading(); // Hide loading indicator (which now contains the error message)
                return null; // Return null if all retries fail
            }
        }

        // Function to display a single question
        function displayQuestion(questionData, categoryTitle, isReview = false) {
            if (!questionData) return;

            const questionCard = document.createElement('div');
            questionCard.className = isReview ? 'completed-test-details-question-card' : 'question-card';

            // Check if it's a figure-based question and display the SVG if it exists
            if (questionData.question_type === 'Figure based Questions' && questionData.svg_data) {
                const svgContainer = document.createElement('div');
                svgContainer.className = 'question-svg';
                
                // --- NEW LOGIC: Use a try-catch block for SVG injection ---
                try {
                    svgContainer.innerHTML = questionData.svg_data; // Inject the SVG code
                    questionCard.appendChild(svgContainer);
                } catch (svgError) {
                    console.error("Error injecting SVG data:", svgError);
                    const errorMsg = document.createElement('p');
                    errorMsg.className = 'text-red-500 font-semibold text-center mt-4';
                    errorMsg.textContent = 'Не удалось отобразить график.';
                    questionCard.appendChild(errorMsg);
                }
            }

            let passageContent = questionData.passage;

            // First, add tooltips for vocabulary words
            if (questionData.vocabulary && Array.isArray(questionData.vocabulary)) {
                questionData.vocabulary.forEach(vocabItem => {
                    // Use a regex with global and case-insensitive flags for whole word match
                    // Escape special characters in the word for regex safety
                    const escapedWord = vocabItem.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi'); 
                    // Use a replacement function to preserve the original casing of the matched word
                    if (passageContent) { // Check if passage exists before replacing
                        passageContent = passageContent.replace(regex, (matchedWord) => {
                            // Capitalize the first letter and make it bold for the tooltip display
                            const formattedWordInTooltip = `<strong>${matchedWord.charAt(0).toUpperCase() + matchedWord.slice(1)}</strong>`;
                            return `<span class="tooltip-container">${matchedWord}<span class="tooltip-text">${formattedWordInTooltip}: ${vocabItem.translation}: ${vocabItem.explanation}</span></span>`;
                        });
                    }
                });
            }

            // Then, apply highlighting for Craft and Structure / Standard English Conventions
            if (passageContent && (categoryTitle === "Craft and Structure" || categoryTitle === "Standard English Conventions")) {
                // For these categories, the model is instructed to use **...** for the highlighted part.
                passageContent = passageContent.replace(/\*\*(.*?)\*\*/g, `<span class="font-bold underline">$1</span>`);
            }
            
            // Display the passage only if it exists
            if (passageContent) {
                const passageDiv = document.createElement('div');
                passageDiv.className = 'question-passage';
                passageDiv.innerHTML = passageContent; // Use innerHTML to render bold/underline/tooltips
                questionCard.appendChild(passageDiv);
            }

            const questionTextDiv = document.createElement('div');
            questionTextDiv.className = 'question-text';
            questionTextDiv.textContent = questionData.question;

            const optionsList = document.createElement('div');
            optionsList.className = 'options-list';

            // Ensure questionData.options is an array before iterating
            let optionsToDisplay = questionData.options;
            if (typeof optionsToDisplay === 'string') {
                try {
                    optionsToDisplay = JSON.parse(optionsToDisplay);
                } catch (e) {
                    console.warn("Could not parse options string:", optionsToDisplay, e);
                    optionsToDisplay = []; // Fallback to empty array if parsing fails
                }
            }
            if (!Array.isArray(optionsToDisplay)) {
                console.warn("questionData.options is not an array after processing:", optionsToDisplay);
                optionsToDisplay = []; // Ensure it's an array for forEach
            }

            const explanationDiv = document.createElement('div');
            explanationDiv.className = 'explanation';
            explanationDiv.textContent = `Объяснение: ${questionData.explanation}`;
            
            if (isReview) {
                // In review mode, show the explanation by default
                explanationDiv.style.display = 'block';
            } else {
                // In quiz mode, hide explanation initially
                explanationDiv.style.display = 'none';
            }

            optionsToDisplay.forEach(option => {
                const optionItem = document.createElement('div');
                optionItem.className = `option-item px-4 py-2 cursor-pointer rounded-md transition duration-200 ease-in-out hover:bg-gray-100`;
                optionItem.textContent = `${option.label}. ${option.text}`;
                optionItem.dataset.label = option.label; // Store option label
                optionItem.dataset.correctAnswer = questionData.correct_answer; // Store correct answer

                if (isReview) {
                    // Review mode: highlight user's answer and correct answer
                    optionItem.classList.add('disabled');
                    optionItem.style.pointerEvents = 'none'; // Ensure options are not clickable

                    const userLabel = questionData.user_answer;
                    const correctLabel = questionData.correct_answer;

                    if (option.label === correctLabel) {
                        optionItem.classList.add('correct');
                    }
                    if (option.label === userLabel && userLabel !== correctLabel) {
                        optionItem.classList.add('incorrect');
                    }
                } else {
                    // Quiz mode: add click listener
                    optionItem.addEventListener('click', function() {
                        // Disable all options for this question after a choice is made
                        optionsList.querySelectorAll('.option-item').forEach(opt => {
                            opt.classList.add('disabled');
                            opt.style.pointerEvents = 'none'; // Ensure it's truly unclickable
                        });

                        const selectedLabel = this.dataset.label;
                        const correctAnswerLabel = this.dataset.correctAnswer;

                        // Записываем ответ пользователя в массив completedQuestions
                        const questionWithAnswer = {
                            ...questionData,
                            user_answer: selectedLabel
                        };
                        completedQuestions.push(questionWithAnswer);
                        
                        // Apply correct/incorrect styling and show explanation
                        optionsList.querySelectorAll('.option-item').forEach(opt => {
                            if (opt.dataset.label === correctAnswerLabel) {
                                opt.classList.add('correct');
                            } else if (opt.dataset.label === selectedLabel) { // This is the selected, but incorrect, option
                                opt.classList.add('incorrect');
                            }
                        });

                        // Show the explanation
                        explanationDiv.style.display = 'block'; // Make sure explanation is visible

                        // Enable next button after an answer is selected
                        nextBtn.disabled = false;
                        nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        resetInactivityTimer(); // Reset timer on interaction
                    });
                }
                optionsList.appendChild(optionItem);
            });

            questionCard.appendChild(questionTextDiv);
            questionCard.appendChild(optionsList);
            questionCard.appendChild(explanationDiv); // Append explanation after options

            return questionCard;
        }

        // Function to display the current question based on global indices
        function displayCurrentQuestion() {
            const currentCategoryTitle = categoriesArray[currentCategoryIndex];
            const currentCategoryKey = categories[currentCategoryTitle];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];

            if (questionsInCurrentCategory && questionsInCurrentCategory.length > currentQuestionIndex) {
                questionsContainer.innerHTML = ''; // Clear previous question
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'category-section mb-10';

                const sectionTitle = document.createElement('h2');
                sectionTitle.className = 'text-2xl font-semibold text-gray-700 mb-6 section-title';
                // Add Roman numeral to the category title
                const romanNumeral = romanNumerals[currentCategoryIndex] || '';
                sectionTitle.textContent = `${romanNumeral}. ${currentCategoryTitle} (Вопрос ${currentQuestionIndex + 1} из ${questionsInCurrentCategory.length})`;
                sectionDiv.appendChild(sectionTitle);

                const questionData = questionsInCurrentCategory[currentQuestionIndex];
                const questionCard = displayQuestion(questionData, currentCategoryTitle);
                if (questionCard) {
                    sectionDiv.appendChild(questionCard);
                }
                questionsContainer.appendChild(sectionDiv);

                // Disable next button until an answer is selected
                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                nextBtn.style.display = 'block'; // Ensure next button is visible
                saveAndExitBtn.style.display = 'block'; // Ensure save and exit button is visible

                // Update next button text and hide "Save and Exit" on the last question
                const isLastQuestion = (currentCategoryIndex === categoriesArray.length - 1 && currentQuestionIndex === questionsInCurrentCategory.length - 1);
                if (isLastQuestion) {
                    nextBtn.textContent = 'Завершить тест';
                    saveAndExitBtn.style.display = 'none'; // Hide "Сохранить и выйти" on the very last question
                } else {
                    nextBtn.textContent = 'Следующий вопрос';
                    saveAndExitBtn.style.display = 'block'; // Show "Сохранить и выйти" on other questions
                }

            } else {
                // This case should not be hit if logic is correct.
                // Call end quiz function directly as a fallback.
                endQuiz(); 
            }
        }

        // Main function to generate all questions and start the quiz
        async function generateAllQuestions() {
            showLoading(); // Show loading indicator at the start
            
            // Clear any existing session when starting a new test
            localStorage.removeItem('satQuizSession'); 
            completedQuestions = []; // Очищаем массив с ответами при начале нового теста

            isSessionActive = true;
            updateCompletedTestsBtnState();

            allGeneratedQuestions = {}; // Reset for new generation
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            categoriesArray = Object.keys(categories); // Update categories array

            // Create an array of promises, one for each category
            const generationPromises = categoriesArray.map(async (categoryTitle) => {
                const categoryKey = categories[categoryTitle];
                const selectedDifficulty = difficultySelect.value;
                return generateQuestionsForCategory(categoryTitle, categoryKey, selectedDifficulty);
            });

            try {
                // Wait for all promises to resolve in parallel
                const results = await Promise.all(generationPromises);
                let allSuccessful = true;
                
                // Process the results
                results.forEach((questionsForCategory, index) => {
                    const categoryTitle = categoriesArray[index];
                    const categoryKey = categories[categoryTitle];
                    if (questionsForCategory && questionsForCategory.length > 0) {
                        allGeneratedQuestions[categoryKey] = questionsForCategory;
                    } else {
                        allSuccessful = false;
                        // Add a visual error card for the user for the failed category
                        const errorCard = document.createElement('div');
                        errorCard.className = 'question-card bg-red-100 text-red-800';
                        errorCard.textContent = `Не удалось сгенерировать вопросы для категории "${categoryTitle}". Пожалуйста, попробуйте еще раз.`;
                        questionsContainer.appendChild(errorCard);
                    }
                });

                hideLoading(); // Hide loading indicator after all generations are complete

                if (allSuccessful && categoriesArray.length > 0) {
                    // Check if the first category has questions, as a minimal check to start the quiz
                    if (allGeneratedQuestions[categories[categoriesArray[0]]]) {
                        nextBtn.style.display = 'block';
                        saveAndExitBtn.style.display = 'block';
                        displayCurrentQuestion(); // Display the first question
                        resetInactivityTimer(); // Reset timer after generation
                    } else {
                         nextBtn.style.display = 'none';
                         saveAndExitBtn.style.display = 'none';
                    }
                } else {
                    // All generations failed or some failed, so we can't start the quiz
                    nextBtn.style.display = 'none';
                    saveAndExitBtn.style.display = 'none';
                }

            } catch (error) {
                console.error("An error occurred during parallel question generation:", error);
                loadingIndicator.innerHTML = `<p class='text-red-600'>Произошла общая ошибка при генерации вопросов. Пожалуйста, попробуйте еще раз.</p>`;
                hideLoading();
                nextBtn.style.display = 'none';
                saveAndExitBtn.style.display = 'none';
            }
        }

        // Function to handle navigation to the next question
        function handleNextQuestion() {
            const currentCategoryKey = categories[categoriesArray[currentCategoryIndex]];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];

            currentQuestionIndex++;
            if (currentQuestionIndex >= questionsInCurrentCategory.length) {
                currentQuestionIndex = 0;
                currentCategoryIndex++;
            }

            if (currentCategoryIndex >= categoriesArray.length) {
                // All questions and categories are exhausted
                endQuiz();
            } else {
                displayCurrentQuestion();
                resetInactivityTimer(); // Reset timer on next question
            }
        }
        
        // Function to handle quiz completion
        function endQuiz() {
            // Сохраняем завершенный тест в локальное хранилище
            const completedTests = JSON.parse(localStorage.getItem('satCompletedTests') || '[]');
            const newCompletedTest = {
                timestamp: new Date().toISOString(),
                difficulty: difficultySelect.value,
                questions: completedQuestions
            };
            completedTests.push(newCompletedTest);
            localStorage.setItem('satCompletedTests', JSON.stringify(completedTests));
            console.log('Completed test saved locally.');
            
            // Сбрасываем состояние
            isSessionActive = false;
            updateCompletedTestsBtnState();
            localStorage.removeItem('satQuizSession'); // Clear session when test is fully completed
            completedQuestions = []; // Очищаем массив после сохранения
            allGeneratedQuestions = {}; // Очищаем сгенерированные вопросы, чтобы гарантировать новый тест

            // Возвращаемся на главный экран приложения
            questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Тест завершен. Нажмите "Сгенерировать вопросы", чтобы начать новый тест.</p>';
            
            // Сбрасываем кнопки
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            generateBtn.style.display = 'block'; 
            generateBtn.disabled = false; 
            generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            nextBtn.textContent = 'Следующий вопрос'; 
            clearTimeout(inactivityTimer); 
        }

        // Function to handle saving and exiting the test
        function handleSaveAndExit() {
            logoutUser(); // Call logoutUser, which will save the current session by default
            questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Тест сохранен. Вы можете сгенерировать новые вопросы.</p>';
        }

        // --- New functions for Completed Tests feature ---
        function showCompletedTests() {
            appContent.style.display = 'none';
            completedTestsScreen.style.display = 'block';
            testsListContainer.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            
            const completedTests = JSON.parse(localStorage.getItem('satCompletedTests') || '[]');
            testsListContainer.innerHTML = ''; // Clear previous list

            if (completedTests.length === 0) {
                testsListContainer.innerHTML = '<p class="text-center text-gray-600">У вас пока нет завершенных тестов.</p>';
                return;
            }

            completedTests.reverse().forEach((test, index) => {
                const testCard = document.createElement('div');
                testCard.className = 'completed-test-card';
                testCard.innerHTML = `
                    <p class="text-lg font-semibold text-gray-800">Тест от ${new Date(test.timestamp).toLocaleString('ru-RU')}</p>
                    <p class="text-sm text-gray-600">Сложность: ${test.difficulty === 'hard' ? 'Усложненный' : 'Облегченный'}</p>
                `;
                testCard.addEventListener('click', () => displayCompletedTestDetails(test));
                testsListContainer.appendChild(testCard);
            });
        }

        function displayCompletedTestDetails(testData) {
            // Store the currently viewed test data for the delete button
            currentReviewingTest = testData;

            testsListContainer.style.display = 'none';
            completedTestDetailsContainer.style.display = 'block';
            testReviewContainer.innerHTML = ''; // Clear previous review

            const reviewTitle = document.createElement('h2');
            reviewTitle.className = 'text-3xl font-bold text-gray-800 mb-6';
            reviewTitle.textContent = `Обзор теста от ${new Date(testData.timestamp).toLocaleString('ru-RU')}`;
            testReviewContainer.appendChild(reviewTitle);

            const allQuestions = testData.questions;
            const categoriesMap = {};
            // Group questions by category
            allQuestions.forEach(q => {
                const category = q.category || 'Information and Ideas'; // Fallback if category is missing
                if (!categoriesMap[category]) {
                    categoriesMap[category] = [];
                }
                categoriesMap[category].push(q);
            });

            let questionCounter = 0;
            // Iterate over categories and display questions with Roman numerals
            Object.keys(categoriesMap).forEach((categoryTitle, categoryIndex) => {
                const sectionTitle = document.createElement('h3');
                sectionTitle.className = 'text-2xl font-semibold text-gray-700 mt-8 mb-4';
                // Add Roman numeral to the category title
                const romanNumeral = romanNumerals[categoryIndex] || '';
                sectionTitle.textContent = `${romanNumeral}. ${categoryTitle}`;
                testReviewContainer.appendChild(sectionTitle);

                categoriesMap[categoryTitle].forEach(question => {
                    questionCounter++;
                    const questionCard = displayQuestion(question, categoryTitle, true); // `true` for review mode
                    const questionNumberText = document.createElement('p');
                    questionNumberText.className = 'font-semibold text-lg text-gray-800 mb-2';
                    questionNumberText.textContent = `Вопрос ${questionCounter}.`;
                    
                    // Display user's answer and correct answer
                    const userAndCorrectAnswerDiv = document.createElement('div');
                    userAndCorrectAnswerDiv.className = 'completed-test-card-details';
                    
                    const userAnswerText = document.createElement('p');
                    const isCorrect = question.user_answer === question.correct_answer;
                    userAnswerText.className = `user-answer ${isCorrect ? 'text-green-600' : 'text-red-600'}`;
                    userAnswerText.innerHTML = `Ваш ответ: <span class="font-bold">${question.user_answer}</span> ${isCorrect ? '(Правильно)' : '(Неправильно)'}`;

                    const correctAnswerText = document.createElement('p');
                    correctAnswerText.className = 'font-medium text-green-600';
                    correctAnswerText.textContent = `Правильный ответ: ${question.correct_answer}`;

                    userAndCorrectAnswerDiv.appendChild(userAnswerText);
                    userAndCorrectAnswerDiv.appendChild(correctAnswerText);

                    testReviewContainer.appendChild(questionNumberText);
                    testReviewContainer.appendChild(questionCard);
                    testReviewContainer.appendChild(userAndCorrectAnswerDiv);
                });
            });
        }
        
        // Function to go back to the main app screen from completed tests
        function backToMainScreen() {
            completedTestsScreen.style.display = 'none';
            appContent.style.display = 'block';
            updateCompletedTestsBtnState(); // Ensure button state is correct on return
        }

        // Function to delete the currently reviewed test
        function deleteCurrentTest() {
            if (!currentReviewingTest) {
                console.error("No test selected for deletion.");
                return;
            }

            // Show a custom confirmation dialog before deleting
            showCustomConfirm('Вы уверены, что хотите удалить этот тест? Это действие необратимо.').then(wantsToDelete => {
                if (wantsToDelete) {
                    let completedTests = JSON.parse(localStorage.getItem('satCompletedTests') || '[]');
                    const filteredTests = completedTests.filter(test => test.timestamp !== currentReviewingTest.timestamp);
                    localStorage.setItem('satCompletedTests', JSON.stringify(filteredTests));
                    console.log('Test deleted successfully.');
                    // Go back to the list of completed tests after deletion
                    showCompletedTests();
                }
            });
        }


        // Attach event listeners
        generateBtn.addEventListener('click', generateAllQuestions);
        nextBtn.addEventListener('click', () => {
            const isLastQuestion = (currentCategoryIndex === categoriesArray.length - 1 && 
                                   currentQuestionIndex === allGeneratedQuestions[categories[categoriesArray[currentCategoryIndex]]].length - 1);
            if (isLastQuestion) {
                endQuiz();
            } else {
                handleNextQuestion();
            }
        });
        saveAndExitBtn.addEventListener('click', handleSaveAndExit);
        
        // New event listeners for completed tests feature
        showCompletedTestsBtn.addEventListener('click', showCompletedTests);
        backToTestsBtn.addEventListener('click', () => {
            testsListContainer.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            currentReviewingTest = null; // Clear the reviewing test when going back
        });
        backToMainBtn.addEventListener('click', backToMainScreen); // New event listener
        deleteTestBtn.addEventListener('click', deleteCurrentTest); // New event listener for the delete button

        // Initial check for a saved session and update the button state
        const savedSession = localStorage.getItem('satQuizSession');
        if (savedSession) {
            isSessionActive = true;
        }
        updateCompletedTestsBtnState();
    </script>
</body>
</html>
