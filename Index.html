<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор вопросов SAT</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%; /* Ensure container takes full width on smaller screens */
        }
        .section-title {
            border-bottom: 2px solid #cbd5e1; /* Light gray border */
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .question-card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0; /* Light border */
        }
        .question-passage {
            font-style: italic;
            color: #4a5568; /* Dark gray text */
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .question-text {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2d3748; /* Darker gray text */
        }
        .option-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            border-radius: 0.5rem;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 1px solid transparent; /* Default transparent border */
        }
        .option-item:hover:not(.disabled) {
            background-color: #f3f4f6; /* Light gray on hover */
        }
        .option-item.correct {
            background-color: #d1fae5; /* Light green for correct answer */
            border-color: #34d399; /* Green border */
            font-weight: 500;
        }
        .option-item.incorrect {
            background-color: #fee2e2; /* Light red for incorrect answer */
            border-color: #ef4444; /* Red border */
            font-weight: 500;
        }
        .option-item.disabled {
            pointer-events: none; /* Disable clicks */
            opacity: 0.8; /* Slightly dim disabled options */
        }
        .explanation {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #e2e8f0;
            font-size: 0.9rem;
            color: #4a5568;
            display: none; /* Hidden by default */
        }
        /* New: Style for tooltips */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #94a3b8; /* Dotted underline for tooltip words */
        }
        .tooltip-text {
            visibility: hidden;
            width: auto; /* Adjust width based on content */
            max-width: 500px; /* Increased max-width for more words */
            background-color: #333;
            color: #fff;
            text-align: left; /* Align text to left for multi-line */
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 100; /* Ensure tooltip is on top */
            bottom: 125%; /* Position above the text */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Allow text wrapping */
            word-wrap: break-word; /* Ensure long words break */
            font-size: 0.85rem;
            pointer-events: none; /* Allow clicks to pass through tooltip when not hovered */
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .login-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .login-button {
            width: 100%;
            background-color: #4299e1; /* Blue */
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #3182ce; /* Darker blue */
        }
        .error-message {
            color: #ef4444;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        /* New: Style for completed tests screen */
        .completed-tests-screen {
            background-color: #f0f4f8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }
        .completed-test-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .completed-test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .completed-test-card-details {
            border-left: 4px solid #3b82f6; /* Blue border for details */
            padding-left: 1rem;
            margin-top: 1rem;
        }
        .completed-test-details-question-card {
            background-color: #f8fafc;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
        }
        .user-answer {
            font-weight: 500;
        }
        /* Style for SVG container to ensure responsiveness */
        .svg-container {
            width: 100%;
            height: auto;
            max-width: 600px; /* New: Limit max width on large screens */
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            margin-left: auto; /* New: Center the container */
            margin-right: auto; /* New: Center the container */
        }
        /* New: Style for text inside the SVG */
        .svg-container svg text {
            font-family: 'Inter', sans-serif;
            font-size: 12px; /* Set a default font size */
        }
        /* Styles for the new modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
        }
        /* Loading overlay for Firestore operations */
        .firestore-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .firestore-loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loginScreen" class="login-container">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">Welcome to Jaleel's Verbal SAT Question Generator</h2>
        <input type="password" id="passwordInput" class="login-input" placeholder="Введите пароль">
        <button id="loginBtn" class="login-button">Войти</button>
        <p id="loginError" class="error-message" style="display: none;">Неверный пароль. Попробуйте снова.</p>
    </div>

    <div id="appContent" class="container" style="display: none;">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Генератор вопросов SAT (Verbal Section)</h1>
        
        <div id="questionInfo" class="text-center text-lg text-gray-600 mb-4"></div>
        
        <div class="mb-6">
            <label for="difficultySelect" class="block text-gray-700 text-sm font-bold mb-2">Выберите уровень сложности:</label>
            <select id="difficultySelect" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500">
                <option value="easy">Облегченный уровень (Easier Module)</option>
                <option value="hard">Усложненный уровень (Harder Module 2)</option>
                <option value="gre_gmat">Сложный уровень (GRE/GMAT-level)</option>
            </select>
        </div>
        
        <!-- UPDATED: Moved and styled the "Exclude Topics" button -->
        <div class="mb-4">
            <button id="excludeTopicsBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
                Исключить темы
            </button>
        </div>

        <div id="categoryButtonsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <!-- Buttons for each category will be inserted here by JavaScript -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mb-4">
            <button id="showCompletedTestsBtn" class="w-full sm:w-1/2 bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                Завершенные тесты
            </button>
            <button id="logoutBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75">
                Выйти
            </button>
        </div>
        
        <div id="loadingIndicator" class="loading-indicator text-center" style="display: none;">
            <!-- Questions will be loaded here -->
        </div>
        
        <div id="questionsContainer" class="space-y-10">
            <!-- Questions will be loaded here -->
        </div>

        <!-- Corrected button order -->
        <div class="flex flex-col sm:flex-row justify-between gap-4 mt-4">
            <button id="nextBtn" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                Следующий вопрос
            </button>
            <button id="saveAndExitBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" style="display: none;">
                Сохранить и выйти
            </button>
        </div>
    </div>

    <div id="completedTestsScreen" class="completed-tests-screen" style="display: none;">
        <button id="backToMainBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
            &larr; Назад в главное окно
        </button>
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Завершенные тесты</h1>
        <div id="testsListContainer" class="space-y-4">
            <!-- Completed tests will be listed here -->
        </div>
        <div id="completedTestDetailsContainer" class="mt-8" style="display: none;">
            <button id="backToTestsBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
                &larr; Назад к списку тестов
            </button>
            <!-- New delete button added here -->
            <button id="deleteTestBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mb-4 ml-4 transition duration-200 ease-in-out">
                Удалить тест
            </button>
            <div id="testReviewContainer">
                <!-- Detailed test review will be displayed here -->
            </div>
        </div>
    </div>

    <!-- NEW: Exclude Topics Modal -->
    <div id="excludeTopicsModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Исключить темы</h2>
            <div class="flex items-center space-x-2 mb-4">
                <input type="text" id="topicInput" class="login-input flex-grow" placeholder="Введите тему для исключения">
                <button id="addTopicBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Добавить</button>
            </div>
            <div id="excludedTopicsList" class="space-y-2 mb-4 max-h-40 overflow-y-auto p-2 bg-gray-100 rounded-md">
                <!-- Excluded topics will be listed here -->
            </div>
            <div class="flex justify-end space-x-4">
                <button id="cancelExcludeBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Ок</button>
            </div>
        </div>
    </div>

    <!-- NEW: Loading overlay for Firestore operations -->
    <div id="firestoreLoadingOverlay" class="firestore-loading-overlay" style="display: none;">
        <div class="firestore-loading-spinner"></div>
        <p class="mt-4 text-lg font-semibold text-gray-700">Сохранение данных...</p>
    </div>

    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, deleteDoc, collection, query, onSnapshot, getDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // ===================================================================================================
        // === ИСПРАВЛЕНО: КОНФИГУРАЦИЯ FIREBASE =============================================================
        // === Теперь используются переменные, предоставленные средой Canvas. ================================
        // ===================================================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyBF1CIivfHlX8O1a3bFO8aIEHwwdTxnUtA",
            authDomain: "jaleels-verbalsat-generator.firebaseapp.com",
            projectId: "jaleels-verbalsat-generator",
            storageBucket: "jaleels-verbalsat-generator.firebasestorage.app",
            messagingSenderId: "274566149454",
            appId: "1:274566149454:web:094849957d81ec3af91a1f",
            measurementId: "G-4RG9BE0BB3"
        };
        const appId = "default-app-id";
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        // ===================================================================================================
        // === НЕ МЕНЯЙТЕ НИЧЕГО НИЖЕ ЭТОЙ СТРОКИ =============================================================
        // ===================================================================================================

        const apiKey = "";
        
        // Get all the DOM elements
        const loginScreen = document.getElementById('loginScreen');
        const passwordInput = document.getElementById('passwordInput');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const appContent = document.getElementById('appContent');
        const categoryButtonsContainer = document.getElementById('categoryButtonsContainer');
        const questionsContainer = document.getElementById('questionsContainer');
        const showCompletedTestsBtn = document.getElementById('showCompletedTestsBtn');
        const completedTestsScreen = document.getElementById('completedTestsScreen');
        const testsListContainer = document.getElementById('testsListContainer');
        const completedTestDetailsContainer = document.getElementById('completedTestDetailsContainer');
        const testReviewContainer = document.getElementById('testReviewContainer');
        const backToTestsBtn = document.getElementById('backToTestsBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const difficultySelect = document.getElementById('difficultySelect');
        const nextBtn = document.getElementById('nextBtn');
        const saveAndExitBtn = document.getElementById('saveAndExitBtn');
        const deleteTestBtn = document.getElementById('deleteTestBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const questionInfoDiv = document.getElementById('questionInfo');
        
        // NEW: Exclude topics modal elements
        const excludeTopicsBtn = document.getElementById('excludeTopicsBtn');
        const excludeTopicsModal = document.getElementById('excludeTopicsModal');
        const topicInput = document.getElementById('topicInput');
        const addTopicBtn = document.getElementById('addTopicBtn');
        const excludedTopicsList = document.getElementById('excludedTopicsList');
        const cancelExcludeBtn = document.getElementById('cancelExcludeBtn');
        
        // NEW: Firestore loading overlay
        const firestoreLoadingOverlay = document.getElementById('firestoreLoadingOverlay');

        const categories = {
            "Information and Ideas": "information_ideas",
            "Craft and Structure": "craft_structure",
            "Expression of Ideas": "expression_ideas",
            "Standard English Conventions": "standard_english_conventions"
        };
        const labels = ['A', 'B', 'C', 'D'];

        // Global state to manage questions and current position
        let allGeneratedQuestions = {};
        let completedQuestions = [];
        let categoriesArray = [];
        let currentCategoryIndex = 0;
        let currentQuestionIndex = 0;
        let isSessionActive = false;
        let currentReviewingTest = null;
        let questionStartTime = 0; 
        let isAuthReady = false;
        let db;
        let auth;
        let userId;

        // Hardcoded password array for client-side authentication
        const CORRECT_PASSWORDS = ["Jaleel2010", "Janiya2010", "ThirdPassword"];

        // Inactivity timer variables
        let inactivityTimer;
        const INACTIVITY_TIMEOUT = 5 * 60 * 1000;
        
        // Countdown timer variables
        let generationCountdownInterval;
        const GENERATION_COUNTDOWN_SECONDS = 90;

        // --- Firebase Initialization and Auth ---
        
        let isSetupComplete = false;
        let app;
        
        if (firebaseConfig) {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    console.log("Firebase Auth State Changed: User is signed in.", userId);
                } else {
                    try {
                         if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                         } else {
                            await signInAnonymously(auth);
                         }
                    } catch (error) {
                        console.error("Firebase authentication failed:", error);
                    }
                }
                isAuthReady = true;
                if (!isSetupComplete) {
                    setupAppUI();
                    isSetupComplete = true;
                }
            });
        } else {
            console.error("Firebase config is missing.");
            appContent.innerHTML = `<div class="text-center p-8 bg-red-100 border-l-4 border-red-500 text-red-700">
                <p class="font-bold text-lg mb-2">Критическая ошибка Firebase</p>
                <p>Не удалось инициализировать Firebase. Возможно, проблема с сетью или ваша конфигурация неверна.</p>
                <p class="mt-2 text-sm text-red-600">Пожалуйста, проверьте консоль разработчика для получения подробной информации об ошибке.</p>
            </div>`;
        }

        // --- NEW: Function to robustly parse the API response to handle non-JSON text ---
        function parseApiResponse(text) {
            try {
                // Try to find the JSON array part of the string.
                // This regex looks for the content between the first '[' and the last ']'.
                const jsonMatch = text.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                } else {
                    // If no array is found, it might be a single JSON object.
                    const objectMatch = text.match(/\{[\s\S]*\}/);
                    if (objectMatch) {
                        return JSON.parse(objectMatch[0]);
                    }
                }
            } catch (e) {
                console.error("Failed to parse JSON even after cleaning:", e);
                throw new Error("Invalid JSON format from API.");
            }
            throw new Error("No valid JSON found in API response.");
        }

        // Function to reset the inactivity timer
        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(logoutUser, INACTIVITY_TIMEOUT);
        }

        // Function to save the current session state to localStorage (still needed for unfinished tests)
        function saveSession() {
            if (Object.keys(allGeneratedQuestions).length > 0) {
                const sessionData = {
                    categoryIndex: currentCategoryIndex,
                    questionIndex: currentQuestionIndex,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value,
                    completedQuestions: completedQuestions,
                    categoriesArray: categoriesArray
                };
                localStorage.setItem('satQuizSession', JSON.stringify(sessionData));
                console.log('Session saved to localStorage.');
            }
        }

        // Function to load a saved session state from localStorage
        async function loadSession() {
            const savedSession = localStorage.getItem('satQuizSession');
            if (savedSession) {
                const sessionData = JSON.parse(savedSession);
                
                if (!sessionData || !sessionData.questions || Object.keys(sessionData.questions).length === 0) {
                    localStorage.removeItem('satQuizSession');
                    console.error("Invalid or empty session data found. Clearing session.");
                    return false;
                }

                const confirmation = await showCustomConfirm('Обнаружена незавершенная сессия. Хотите продолжить с того места, где остановились?');
                
                if (confirmation) {
                    currentCategoryIndex = sessionData.categoryIndex;
                    currentQuestionIndex = sessionData.questionIndex;
                    allGeneratedQuestions = sessionData.questions;
                    difficultySelect.value = sessionData.difficulty;
                    completedQuestions = sessionData.completedQuestions || [];
                    categoriesArray = sessionData.categoriesArray || Object.keys(categories);
                    isSessionActive = true;
                    console.log('Session loaded from localStorage. Resuming test.');
                    return true;
                } else {
                    localStorage.removeItem('satQuizSession');
                    isSessionActive = false;
                    return false;
                }
            }
            return false;
        }

        // Custom confirmation dialog (replaces alert/confirm)
        function showCustomConfirm(message) {
            return new Promise(resolve => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modalOverlay.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <p class="text-lg font-semibold mb-4">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                            <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('confirmYes').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });
                document.getElementById('confirmNo').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(false);
                });
            });
        }

        // Function to update the disabled state of the buttons
        function updateMainButtonsState(isDisabled) {
            document.querySelectorAll('#categoryButtonsContainer button').forEach(button => {
                button.disabled = isDisabled;
                button.classList.toggle('opacity-50', isDisabled);
                button.classList.toggle('cursor-not-allowed', isDisabled);
                button.classList.toggle('hover:bg-blue-700', !isDisabled);
                button.classList.toggle('hover:scale-105', !isDisabled);
            });
            showCompletedTestsBtn.disabled = isDisabled;
            showCompletedTestsBtn.classList.toggle('opacity-50', isDisabled);
            showCompletedTestsBtn.classList.toggle('cursor-not-allowed', isDisabled);
            showCompletedTestsBtn.classList.toggle('hover:bg-gray-600', !isDisabled);
            showCompletedTestsBtn.classList.toggle('hover:scale-105', !isDisabled);
            excludeTopicsBtn.disabled = isDisabled;
            excludeTopicsBtn.classList.toggle('opacity-50', isDisabled);
            excludeTopicsBtn.classList.toggle('cursor-not-allowed', isDisabled);
            excludeTopicsBtn.classList.toggle('hover:bg-purple-700', !isDisabled);
            logoutBtn.disabled = isDisabled;
            logoutBtn.classList.toggle('opacity-50', isDisabled);
            logoutBtn.classList.toggle('cursor-not-allowed', isDisabled);
        }

        // Function to log out the user and reset the app state
        async function logoutUser(saveCurrent = true) {
            if (isSessionActive && saveCurrent) {
                await saveCompletedTest();
            } else if (!saveCurrent) {
                localStorage.removeItem('satQuizSession');
            }

            isSessionActive = false;
            updateMainButtonsState(false);
            
            // Re-render the UI to show the login screen
            appContent.style.display = 'none';
            loginScreen.style.display = 'block';
            passwordInput.value = '';
            loginError.style.display = 'none';

            // Reset application state
            allGeneratedQuestions = {};
            completedQuestions = [];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            currentReviewingTest = null;
            categoriesArray = [];
            questionStartTime = 0;

            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            questionsContainer.innerHTML = '';
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';

            clearTimeout(inactivityTimer);
            clearInterval(generationCountdownInterval);
        }

        // Event listeners for user activity to reset the timer
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        document.addEventListener('scroll', resetInactivityTimer);

        // Initial check for activity when the page loads
        resetInactivityTimer();

        // Function to generate the category buttons
        function createCategoryButtons() {
            categoryButtonsContainer.innerHTML = '';
            Object.keys(categories).forEach(categoryTitle => {
                const categoryKey = categories[categoryTitle];
                const button = document.createElement('button');
                button.id = `generateBtn-${categoryKey}`;
                button.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75';
                button.textContent = categoryTitle;
                button.addEventListener('click', () => handleNewTest(categoryKey));
                categoryButtonsContainer.appendChild(button);
            });
        }

        // Main function to set up the app UI after successful login
        async function setupAppUI() {
            loginScreen.style.display = 'none';
            appContent.style.display = 'block';
            
            createCategoryButtons();
            const sessionResumed = await loadSession();
            if (sessionResumed) {
                displayCurrentQuestion();
                nextBtn.style.display = 'block';
                saveAndExitBtn.style.display = 'block';
                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите на кнопку категории, чтобы начать новый тест.</p>';
            }
            updateMainButtonsState(isSessionActive);
            resetInactivityTimer();
        }

        // Login function
        loginBtn.addEventListener('click', async () => {
            if (CORRECT_PASSWORDS.includes(passwordInput.value)) {
                loginError.style.display = 'none';
                
                // Show a loading message while we wait for auth to complete
                questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Выполняется вход...</p>';
                loginScreen.style.display = 'none';
                appContent.style.display = 'block';
                
                if (isAuthReady) {
                    setupAppUI();
                } else {
                    const checkAuth = setInterval(() => {
                        if (isAuthReady) {
                            clearInterval(checkAuth);
                            setupAppUI();
                        }
                    }, 100);
                }
            } else {
                loginError.style.display = 'block';
            }
        });
        
        // New logout button listener
        logoutBtn.addEventListener('click', async () => {
            if (isSessionActive) {
                const confirmation = await showCustomConfirm('У вас есть незавершенный тест. Вы уверены, что хотите выйти? Прогресс будет потерян.');
                if (confirmation) {
                    logoutUser(false); // Do not save current session
                }
            } else {
                logoutUser(false);
            }
        });

        // Allow pressing Enter key to login
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loginBtn.click();
            }
        });
        
        // Function to start the generation countdown timer
        function startGenerationCountdown() {
            let timeLeft = GENERATION_COUNTDOWN_SECONDS;
            const timerElement = document.getElementById('timer');
            timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;

            generationCountdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;
                } else {
                    clearInterval(generationCountdownInterval);
                    timerElement.textContent = 'Время вышло, генерация продолжается...';
                }
            }, 1000);
        }

        // Function to show loading indicator
        function showLoading(message) {
            questionsContainer.innerHTML = '';
            loadingIndicator.innerHTML = `
                <p class="text-xl font-semibold mb-4 text-gray-700">${message}</p>
                <div id="timer" class="text-md font-medium text-gray-500 mb-4"></div>
                <div class="mt-4">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-gray-900 mx-auto"></div>
                    </div>
                `;
            loadingIndicator.style.display = 'block';
            
            updateMainButtonsState(true);

            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            
            clearInterval(generationCountdownInterval);
            startGenerationCountdown();
        }

        // Function to hide loading indicator
        function hideLoading() {
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            clearInterval(generationCountdownInterval);
        }
        
        // NEW: Functions for managing excluded topics
        function getExcludedTopics() {
            const excludedTopics = localStorage.getItem('excludedTopics');
            return excludedTopics ? JSON.parse(excludedTopics) : [];
        }

        function saveExcludedTopics(topics) {
            localStorage.setItem('excludedTopics', JSON.stringify(topics));
        }

        function renderExcludedTopicsList() {
            const topics = getExcludedTopics();
            excludedTopicsList.innerHTML = '';
            if (topics.length === 0) {
                excludedTopicsList.innerHTML = '<p class="text-gray-500 text-center text-sm">Нет исключенных тем.</p>';
                return;
            }

            topics.forEach(topic => {
                const topicItem = document.createElement('div');
                topicItem.className = 'flex items-center justify-between p-2 bg-white rounded-md shadow-sm border border-gray-200';
                topicItem.innerHTML = `
                    <span class="text-gray-800">${topic}</span>
                    <button class="delete-topic-btn bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-2 rounded-full transition duration-200" data-topic="${topic}">
                        Удалить
                    </button>
                `;
                excludedTopicsList.appendChild(topicItem);
            });
        }
        
        // Event listeners for the new modal
        excludeTopicsBtn.addEventListener('click', () => {
            renderExcludedTopicsList();
            excludeTopicsModal.classList.remove('hidden');
        });

        // FIX: Use the correct variable name
        cancelExcludeBtn.addEventListener('click', () => {
            excludeTopicsModal.classList.add('hidden');
        });
        
        addTopicBtn.addEventListener('click', () => {
            const topic = topicInput.value.trim();
            if (topic) {
                const topics = getExcludedTopics();
                if (!topics.includes(topic)) {
                    topics.push(topic);
                    saveExcludedTopics(topics);
                    renderExcludedTopicsList();
                }
                topicInput.value = '';
            }
        });
        
        excludedTopicsList.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-topic-btn')) {
                const topicToDelete = event.target.dataset.topic;
                const topics = getExcludedTopics();
                const updatedTopics = topics.filter(t => t !== topicToDelete);
                saveExcludedTopics(updatedTopics);
                renderExcludedTopicsList();
            }
        });
        
        // Helper function to get the correct number of vocabulary words
        function getVocabCount(difficulty) {
            switch(difficulty) {
                case 'easy':
                    return 4;
                case 'hard':
                    return 6;
                    case 'gre_gmat':
                        return 8;
                    default:
                        return 4; // Default to easy
                    }
                }

                // Function to generate multiple questions for a given category with exponential backoff
                async function generateQuestionsForCategory(categoryTitle, categoryKey, difficulty) {
                    const MAX_RETRIES = 5;
                    const BASE_DELAY_MS = 1000;
                    const numberOfQuestions = 10; // UPDATED to 10
                    const vocabCount = getVocabCount(difficulty);
                    const excludedTopics = getExcludedTopics();
                    let questionsArray = null;
                    let retries = 0;

                    let difficultyModifier;
                    let wordCountRange;
                    if (difficulty === 'easy') {
                        difficultyModifier = 'straightforward';
                        wordCountRange = '40-60';
                    } else if (difficulty === 'hard') {
                        difficultyModifier = 'challenging';
                        wordCountRange = '60-80';
                    } else if (difficulty === 'gre_gmat') {
                        difficultyModifier = 'highly challenging';
                        wordCountRange = '100-150';
                    }
                    
                    const excludeText = excludedTopics && excludedTopics.length > 0 ? `Explicitly and strictly avoid passages and questions on the following topics: ${excludedTopics.join(', ')}. It is critical that no generated content relates to these topics.` : '';

                    // Updated prompt logic to conditionally request graphics
                    const graphicInstruction = categoryKey === "information_ideas" ? 
                        `7. For one of the questions, also provide an SVG code string for a simple graph (e.g., a bar chart, line graph, or pie chart) that illustrates data mentioned in the passage. The graphic should be directly relevant to the question and passage content. For all other questions, provide an empty string for the graphic property.` : 
                        `7. For all questions, strictly provide an empty string for the graphic property.`;

                    const responseSchema = {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                passage: { type: "STRING" },
                                graphic: { type: "STRING" }, // New property for SVG graphics
                                question: { type: "STRING" },
                                options: {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            label: { type: "STRING" },
                                            text: { type: "STRING" }
                                        },
                                        required: ["label", "text"]
                                    }
                                },
                                correct_answer: { type: "STRING" },
                                explanation: { type: "STRING" },
                                vocabulary: {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            word: { "type": "STRING" },
                                            translation: { "type": "STRING" },
                                            synonyms: { "type": "STRING" },
                                        },
                                        required: ["word", "translation", "synonyms"]
                                    }
                                },
                                question_type: { type: "STRING" }
                            },
                            required: ["passage", "question", "options", "correct_answer", "explanation", "question_type"]
                        }
                    };
                    
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${firebaseConfig.apiKey}`;

                    let prompt;
                    switch (categoryKey) {
                        case "information_ideas":
                            prompt = `
                                Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Information and Ideas" questions in English, each based on a new and distinct topic. ${excludeText}
                                For each question, provide:
                                1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. Passages must be fresh and not repeat previous topics within this generation request.
                                2. A specific SAT-style question in English based on the passage, designed to test a particular skill.
                                3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. The "NO CHANGE" option must not be included.
                                4. The correct answer label (e.g., "A").
                                5. A brief explanation in Russian for the correct answer.
                                6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                                ${graphicInstruction}
                                8. Classify each question with one of these types: "Direct Questions", "Inference Questions", "Main Idea Questions", "Figure based Questions", "Strengthen Weaken Questions", "Poem based Questions", "Character Descriptions".
                                Return the response in a JSON array format.
                            `;
                            break;
                        case "craft_structure":
                            prompt = `
                                Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Craft and Structure" questions in English, each based on a new and distinct topic. ${excludeText}
                                For each question, provide:
                                1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. For Cross-text Connection questions, provide two distinct, short passages. The passages must be fresh and not repeat previous topics within this generation request.
                                2. A specific SAT-style question in English based on the passage(s).
                                3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. The "NO CHANGE" option must not be included.
                                4. The correct answer label (e.g., "A").
                                5. A brief explanation in Russian for the correct answer.
                                6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                                ${graphicInstruction}
                                8. Classify each question with one of these types: "Vocabulary in Context", "Primary Purpose Questions", "Purpose of a portion Questions", "Structure Questions", "Cross-text Connection Questions", "Quotes Illustrate Questions".
                                Return the response in a JSON array format.
                            `;
                            break;
                        case "expression_ideas":
                            prompt = `
                                Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Expression of Ideas" questions in English, each based on a new and distinct topic, such as a student's essay draft about the social impact of a new technology, an analysis of a classic piece of music, or a research proposal on a historical event. The passages must be fresh and not repeat previous topics within this generation request.
                                For each question, provide:
                                1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. One sentence in the passage must have a blank space for a transition, represented by exactly three underscores (e.g., "People often speak of the philosophy of the ancient Greeks or what the Greeks believed, as though they had a single shared opinion. ___ Greek philosophers held a great diversity of opinions...").
                                2. A specific SAT-style question in English, with the exact wording: "Which choice completes the text with the most logical transition?" for Transition Questions and a specific goal-oriented prompt for Goal based Questions.
                                3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. Each choice should be a single transition word or phrase (e.g., "Ancient", "Meanwhile, ancient", "Consequently, ancient", "However, ancient"). The "NO CHANGE" option must not be included.
                            4. The correct answer label (e.g., "A").
                            5. A brief explanation in Russian for the correct answer.
                            6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                            ${graphicInstruction}
                            8. Classify each question with one of these types: "Transition Question", "Goal based Questions".
                            Return the response in a JSON array format.
                        `;
                        break;
                    case "standard_english_conventions":
                        // Обновленный запрос: явно указывает не использовать "NO CHANGE".
                        prompt = `
                            Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Standard English Conventions" questions in English, each based on a new and distinct topic. ${excludeText} For each question, provide:
                            1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, such as a historical account of a battle, a technical manual for a tool, or a biographical sketch of an artist. Each passage must contain a specific grammatical or punctuation error. The passages must be fresh and not repeat previous topics within this generation request.
                            2. A SAT-style question in English that asks the user to correct the error. The questions must cover a variety of the following rules:
                               - Subject-verb agreement
                               - Subject pronoun agreement
                               - Comma subject rule
                               - Punctuation on the SAT
                               - Apostrophe
                               - Listing
                               - Introduction of a list or description
                               - Comparison
                               - Tense
                            3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. None of the options should be "NO CHANGE". The correct answer will always be one of the provided revisions.
                            4. The correct answer label (e.g., "A").
                            5. A brief explanation in Russian for the correct answer.
                            6. Identify exactly ${vocabCount} English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a comma-separated list of 2-3 English synonyms in a 'vocabulary' array.
                            
                            The part of the passage with the grammatical error should be replaced with a blank line, represented by three underscores (e.g., ___). It is critical that you use exactly three underscores, nothing more and nothing less.
                            ${graphicInstruction}
                            8. Classify each question with one of these types: "Subject verb agreement", "Subject pronoun agreement", "Comma subject rule", "Punctuation on the SAT", "Apostrophe", "Listing", "Introduction of a list or description", "Comparison", "Tense".
                            Return the response in a JSON array format.
                        `;
                        break;
                }

                do {
                    try {
                        const payload = {
                            contents: [{ role: "user", parts: [{ text: prompt }] }],
                            generationConfig: {
                                responseMimeType: "application/json",
                                responseSchema: responseSchema
                            }
                        };
                        
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        
                        if (!response.ok) {
                            const errorDetails = await response.text();
                            throw new Error(`HTTP Error: ${response.status} ${response.statusText}. Details: ${errorDetails}`);
                        }
                        
                        const result = await response.json();
                        questionsArray = parseApiResponse(result?.candidates?.[0]?.content?.parts?.[0]?.text || "[]");
                        
                        if (Array.isArray(questionsArray) && questionsArray.length === numberOfQuestions) {
                            return questionsArray;
                        } else {
                            throw new Error(`API не вернул ровно ${numberOfQuestions} вопросов. Получено: ${questionsArray.length}.`);
                        }
                    } catch (error) {
                        console.error(`Ошибка генерации вопросов для ${categoryTitle} (Уровень: ${difficulty}):`, error);
                        retries++;
                        if (retries >= MAX_RETRIES) {
                            throw new Error(`Не удалось сгенерировать правильное количество вопросов после ${MAX_RETRIES} попыток.`);
                        }
                        const delay = BASE_DELAY_MS * Math.pow(2, retries) + (Math.random() * 100);
                        console.warn(`Повторная попытка генерации вопросов для ${categoryTitle} через ${delay} мс (попытка ${retries + 1}/${MAX_RETRIES})...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                } while (retries < MAX_RETRIES);

                return null; // Should not be reached due to the throw above, but as a fallback.
            }

            // --- Core Quiz Logic ---
            
            // This function handles a single category quiz or one module of the full test
            async function handleNewTest(categoryKey) {
                categoriesArray = [categoryKey];
                currentCategoryIndex = 0;
                currentQuestionIndex = 0;
                isSessionActive = true;
                completedQuestions = [];
                
                showLoading("Генерация вопросов... Пожалуйста, подождите.");
                
                try {
                    const questions = await generateQuestionsForCategory(Object.keys(categories).find(key => categories[key] === categoryKey), categoryKey, difficultySelect.value);
                    if (questions) {
                        allGeneratedQuestions = { [categoryKey]: questions };
                        hideLoading();
                        displayCurrentQuestion();
                        nextBtn.style.display = 'block';
                        saveAndExitBtn.style.display = 'block';
                        updateMainButtonsState(true);
                    }
                } catch (error) {
                    hideLoading();
                    questionsContainer.innerHTML = `<p class="text-center text-red-600 font-bold text-lg">Ошибка при загрузке вопросов: ${error.message}</p>`;
                    updateMainButtonsState(false);
                }
            }
            
            // Full test button and logic removed
            
            function displayCurrentQuestion() {
                if (!isSessionActive) {
                    return;
                }
                
                // Check if we have questions for the current category
                const currentCategory = categoriesArray[currentCategoryIndex];
                if (!allGeneratedQuestions[currentCategory] || allGeneratedQuestions[currentCategory].length === 0) {
                    console.error("No questions for the current category.");
                    endQuiz();
                    return;
                }

                const questions = allGeneratedQuestions[currentCategory];

                // Check if we are at the end of the current module
                if (currentQuestionIndex >= questions.length) {
                    // Single category test completed
                    endQuiz();
                    return;
                }
                
                const questionData = questions[currentQuestionIndex];
                questionsContainer.innerHTML = renderQuestion(questionData, currentQuestionIndex + 1, questions.length);
                questionStartTime = Date.now();
                
                // Enable the 'Next' button after a selection is made
                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                
                // Условное отображение кнопки "Завершить тест"
                if (currentQuestionIndex === questions.length - 1) {
                    nextBtn.textContent = 'Завершить тест';
                    saveAndExitBtn.style.display = 'none'; // Скрываем кнопку "Сохранить и выйти"
                } else {
                    nextBtn.textContent = 'Следующий вопрос';
                    saveAndExitBtn.style.display = 'block'; // Показываем кнопку "Сохранить и выйти"
                }
                logoutBtn.disabled = true;
                logoutBtn.classList.toggle('opacity-50', true);
                logoutBtn.classList.toggle('cursor-not-allowed', true);
            }

            // Handles user selecting an answer
            function handleAnswerSelection(event, questionIndex, categoryKey) {
                const selectedOption = event.target.closest('.option-item');
                if (!selectedOption) return;

                const userChoice = selectedOption.dataset.label;
                const questionData = allGeneratedQuestions[categoryKey][questionIndex];
                
                // Save the user's answer and time taken
                const timeTaken = (Date.now() - questionStartTime) / 1000;
                
                // Ensure we don't save duplicate answers if user clicks multiple times
                if (!completedQuestions.find(q => q.question.question === questionData.question)) {
                    completedQuestions.push({
                        question: questionData,
                        userAnswer: userChoice,
                        timeTaken: timeTaken,
                        isCorrect: userChoice === questionData.correct_answer
                    });
                }

                // Apply visual feedback and disable other options
                const options = selectedOption.parentNode.querySelectorAll('.option-item');
                options.forEach(option => {
                    option.classList.add('disabled');
                    const label = option.dataset.label;
                    if (label === questionData.correct_answer) {
                        option.classList.add('correct');
                    }
                    if (label === userChoice && userChoice !== questionData.correct_answer) {
                        option.classList.add('incorrect');
                    }
                });

                // Show explanation
                const explanationElement = document.getElementById(`explanation-${questionIndex}`);
                if (explanationElement) {
                    explanationElement.style.display = 'block';
                }

                // Enable next button
                nextBtn.disabled = false;
                nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }

            function renderQuestion(questionData, number, total) {
                let passageHtml = questionData.passage;
                let questionText = questionData.question;
                
                // FIX: Remove the logic that adds the word after the blank.
                // The prompt for 'Expression of Ideas' still includes the blank space (___)
                // which needs to be handled.
                if (passageHtml.includes('___') && questionData.question.startsWith("Which choice completes the text with the most logical transition?")) {
                    // The question is already formatted correctly by the model, so we don't need to append anything.
                }

                // Handle vocabulary tooltips
                if (questionData.vocabulary && questionData.vocabulary.length > 0) {
                    questionData.vocabulary.forEach(vocab => {
                        const regex = new RegExp(`\\b${vocab.word}\\b`, 'g');
                        passageHtml = passageHtml.replace(regex, `<span class="tooltip-container">${vocab.word}<span class="tooltip-text">${vocab.translation}<br>Синонимы: ${vocab.synonyms}</span></span>`);
                    });
                }
                
                // Handle SVG graphics
                let graphicHtml = '';
                if (questionData.graphic) {
                    graphicHtml = `<div class="svg-container">${questionData.graphic}</div>`;
                }

                const optionsHtml = questionData.options.map((option, index) => {
                    const label = labels[index];
                    return `
                        <div class="option-item flex items-start space-x-2 p-2" data-label="${label}">
                            <div class="font-bold w-6">${label}.</div>
                            <div class="flex-1">${option.text}</div>
                        </div>
                    `;
                }).join('');

                return `
                    <div id="question-card-${number - 1}" class="question-card">
                        <div class="flex items-center justify-between mb-2">
                           <p class="text-lg font-semibold text-gray-800">Вопрос ${number} из ${total}</p>
                           <p class="text-md text-gray-600">${Object.keys(categories).find(key => categories[key] === categoriesArray[currentCategoryIndex])}: ${questionData.question_type}</p>
                        </div>
                        ${graphicHtml}
                        <p class="question-passage">${passageHtml}</p>
                        <p class="question-text">${questionData.question}</p>
                        <div class="options-container">
                            ${optionsHtml}
                        </div>
                        <div id="explanation-${number - 1}" class="explanation">
                            <p class="font-semibold">Объяснение:</p>
                            <p>${questionData.explanation}</p>
                        </div>
                    </div>
                `;
            }
            
            questionsContainer.addEventListener('click', (event) => {
                const optionItem = event.target.closest('.option-item');
                if (optionItem && !optionItem.classList.contains('disabled')) {
                    const questionCard = event.target.closest('.question-card');
                    const questionIndex = parseInt(questionCard.id.split('-')[2]);
                    const currentCategory = categoriesArray[currentCategoryIndex];
                    handleAnswerSelection(event, questionIndex, currentCategory);
                }
            });
            
            nextBtn.addEventListener('click', () => {
                const currentCategory = categoriesArray[currentCategoryIndex];
                const totalQuestions = allGeneratedQuestions[currentCategory].length;

                if (nextBtn.textContent === 'Завершить тест') {
                    // Если это последний вопрос, завершаем тест
                    endQuiz();
                } else {
                    // Иначе переходим к следующему вопросу
                    currentQuestionIndex++;
                    displayCurrentQuestion();
                }
            });


            saveAndExitBtn.addEventListener('click', () => {
                logoutUser(true); // Saves the session and resets the UI
            });


            // Function to handle the end of a quiz
            function endQuiz() {
                saveCompletedTest(); 
                
                isSessionActive = false;
                updateMainButtonsState(false);
                nextBtn.style.display = 'none';
                saveAndExitBtn.style.display = 'none';
                
                localStorage.removeItem('satQuizSession');

                showSummaryScreen();
            }

            function showSummaryScreen() {
                const correctCount = completedQuestions.filter(q => q.isCorrect).length;
                const totalQuestions = completedQuestions.length;
                const completionMessage = `Вы завершили тест. Правильных ответов: ${correctCount} из ${totalQuestions}.`;
                
                questionsContainer.innerHTML = `
                    <div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4 mb-6 rounded-lg shadow-md" role="alert">
                        <p class="font-bold text-lg">Тест завершен!</p>
                        <p>${completionMessage}</p>
                    </div>
                    <p class="text-center text-gray-600">Вы можете просмотреть свои результаты и объяснения в разделе "Завершенные тесты".</p>
                `;
            }

            // --- Completed Tests Functionality (UPDATED TO USE FIRESTORE) ---
            showCompletedTestsBtn.addEventListener('click', showCompletedTestsList);
            backToMainBtn.addEventListener('click', () => {
                completedTestsScreen.style.display = 'none';
                appContent.style.display = 'block';
                updateMainButtonsState(isSessionActive);
            });

            // Function to save a completed test to Firestore
            async function saveCompletedTest() {
                if (!isAuthReady || !userId || completedQuestions.length === 0) {
                    console.warn("Auth not ready, no user ID, or no questions to save. Aborting save.");
                    return;
                }

                const newTest = {
                    id: Date.now().toString(),
                    date: new Date().toLocaleString(),
                    questions: completedQuestions,
                    difficulty: difficultySelect.value,
                    isFullTest: false, // Always false now that full test is removed
                    category: Object.keys(categories).find(key => categories[key] === categoriesArray[0]),
                    correctCount: completedQuestions.filter(q => q.isCorrect).length,
                    totalQuestions: completedQuestions.length,
                    createdAt: new Date()
                };

                const testRef = doc(db, `artifacts/${appId}/users/${userId}/completedTests`, newTest.id);
                firestoreLoadingOverlay.style.display = 'flex';
                try {
                    await setDoc(testRef, newTest);
                    console.log("Тест успешно сохранен в Firestore!");
                } catch (e) {
                    console.error("Error removing test from Firestore:", e);
                } finally {
                    firestoreLoadingOverlay.style.display = 'none';
                }
            }

            // Function to get completed tests from Firestore and display them in real-time
            function showCompletedTestsList() {
                appContent.style.display = 'none';
                completedTestsScreen.style.display = 'block';
                completedTestDetailsContainer.style.display = 'none';
                testsListContainer.innerHTML = `<p class="text-center text-gray-500">Загрузка тестов...</p>`;
                
                if (!isAuthReady || !userId) {
                    testsListContainer.innerHTML = `<p class="text-center text-red-600">Пожалуйста, подождите, пока приложение подключится к базе данных.</p>`;
                    return;
                }

                const q = query(collection(db, `artifacts/${appId}/users/${userId}/completedTests`));
                
                // Use onSnapshot for real-time updates
                onSnapshot(q, (querySnapshot) => {
                    const tests = [];
                    querySnapshot.forEach((doc) => {
                        tests.push(doc.data());
                    });
                    // Sort by creation date descending
                    tests.sort((a, b) => b.createdAt.toDate() - a.createdAt.toDate());

                    testsListContainer.innerHTML = '';
                    if (tests.length === 0) {
                        testsListContainer.innerHTML = `<p class="text-center text-gray-500">Пока нет завершенных тестов.</p>`;
                        return;
                    }
                    
                    tests.forEach(test => {
                        const testCard = document.createElement('div');
                        testCard.className = 'completed-test-card';
                        testCard.innerHTML = `
                            <p class="text-lg font-bold text-gray-800">${test.category} - ${test.date}</p>
                            <p class="text-sm text-gray-600">Сложность: ${test.difficulty}</p>
                            <p class="text-md font-semibold mt-2">Правильных ответов: ${test.correctCount} из ${test.totalQuestions}</p>
                        `;
                        testCard.addEventListener('click', () => showTestReview(test));
                        testsListContainer.appendChild(testCard);
                    });
                }, (error) => {
                    console.error("Error fetching completed tests:", error);
                    testsListContainer.innerHTML = `<p class="text-center text-red-600">Ошибка при загрузке тестов. Пожалуйста, попробуйте еще раз.</p>`;
                });
            }
            
            function showTestReview(test) {
                currentReviewingTest = test;
                testsListContainer.style.display = 'none';
                completedTestDetailsContainer.style.display = 'block';
                
                const reviewHtml = test.questions.map((q, index) => {
                    const questionData = q.question;
                    const userChoice = q.userAnswer;
                    const isCorrect = q.isCorrect;
                    
                    // Construct the passage HTML with vocabulary tooltips and bolding
                    let passageHtml = questionData.passage;
                    if (questionData.vocabulary && questionData.vocabulary.length > 0) {
                        questionData.vocabulary.forEach(vocab => {
                            const regex = new RegExp(`\\b${vocab.word}\\b`, 'g');
                            passageHtml = passageHtml.replace(regex, `<span class="tooltip-container">${vocab.word}<span class="tooltip-text">${vocab.translation}<br>Синонимы: ${vocab.synonyms}</span></span>`);
                        });
                    }
                    
                    // Handle SVG graphics
                    let graphicHtml = '';
                    if (questionData.graphic) {
                        graphicHtml = `<div class="svg-container">${questionData.graphic}</div>`;
                    }

                    const optionsHtml = questionData.options.map((option, optionIndex) => {
                        const label = labels[optionIndex];
                        let optionClasses = 'p-2 rounded-md';
                        if (label === questionData.correct_answer) {
                            optionClasses += ' bg-green-200 border-green-500';
                        }
                        if (label === userChoice && !isCorrect) {
                            optionClasses += ' bg-red-200 border-red-500';
                        }
                        
                        return `
                            <div class="${optionClasses}">
                                <span class="font-bold">${label}.</span> ${option.text}
                                ${label === userChoice ? '<span class="user-answer ml-2">(Ваш ответ)</span>' : ''}
                            </div>
                        `;
                    }).join('');
                    
                    return `
                        <div id="question-card-${number - 1}" class="completed-test-details-question-card">
                            <p class="text-md font-semibold mb-2">Вопрос ${index + 1}:</p>
                            ${graphicHtml}
                            <p class="question-passage">${passageHtml}</p>
                            <p class="question-text">${questionData.question}</p>
                            <div class="space-y-2 mb-4">
                                ${optionsHtml}
                            </div>
                            <div id="explanation-${index}" class="explanation">
                                <p class="font-semibold">Объяснение:</p>
                                <p>${questionData.explanation}</p>
                            </div>
                        </div>
                    `;
                }).join('');

                testReviewContainer.innerHTML = `
                    <h2 class="text-3xl font-bold text-gray-800 mb-4">${test.category} Тест - Результаты</h5>
                    <div class="bg-gray-100 p-4 rounded-lg mb-6">
                        <p class="font-semibold">Дата: ${test.date}</p>
                        <p class="font-semibold">Сложность: ${test.difficulty}</p>
                        <p class="font-semibold">Правильных ответов: ${test.correctCount} из ${test.totalQuestions}</p>
                        <p class="text-xs text-gray-500 mt-2">ID Теста: ${test.id}</p>
                    </div>
                    ${reviewHtml}
                `;
            }
            
            backToTestsBtn.addEventListener('click', () => {
                testsListContainer.style.display = 'block';
                completedTestDetailsContainer.style.display = 'none';
                showCompletedTestsList();
            });

            deleteTestBtn.addEventListener('click', async () => {
                if (!isAuthReady || !userId) {
                    console.error("Auth not ready or no user ID. Aborting delete.");
                    return;
                }

                if (currentReviewingTest) {
                    const confirmation = await showCustomConfirm('Вы уверены, что хотите удалить этот тест? Это действие необратимо.');
                    if (confirmation) {
                        const testRef = doc(db, `artifacts/${appId}/users/${userId}/completedTests`, currentReviewingTest.id);
                        firestoreLoadingOverlay.style.display = 'flex';
                        try {
                            await deleteDoc(testRef);
                            console.log("Test successfully deleted from Firestore.");
                        } catch (e) {
                            console.error("Error removing test from Firestore:", e);
                        } finally {
                            firestoreLoadingOverlay.style.display = 'none';
                        }
                    }
                }
            });
            
            // Initially display the login screen. The setupAppUI function will hide it later if auth is ready.
            loginScreen.style.display = 'block';
            appContent.style.display = 'none';
        })();
    </script>
</body>
</html>
