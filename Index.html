<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор вопросов SAT</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%; /* Ensure container takes full width on smaller screens */
        }
        .section-title {
            border-bottom: 2px solid #cbd5e1; /* Light gray border */
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .question-card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0; /* Light border */
        }
        .question-passage {
            font-style: italic;
            color: #4a5568; /* Dark gray text */
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .question-text {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2d3748; /* Darker gray text */
        }
        .option-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            border-radius: 0.5rem;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 1px solid transparent; /* Default transparent border */
        }
        .option-item:hover:not(.disabled) {
            background-color: #f3f4f6; /* Light gray on hover */
        }
        .option-item.correct {
            background-color: #d1fae5; /* Light green for correct answer */
            border-color: #34d399; /* Green border */
            font-weight: 500;
        }
        .option-item.incorrect {
            background-color: #fee2e2; /* Light red for incorrect answer */
            border-color: #ef4444; /* Red border */
            font-weight: 500;
        }
        .option-item.disabled {
            pointer-events: none; /* Disable clicks */
            opacity: 0.8; /* Slightly dim disabled options */
        }
        .explanation {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #e2e8f0;
            font-size: 0.9rem;
            color: #4a5568;
            display: none; /* Hidden by default */
        }
        /* New: Style for tooltips */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #94a3b8; /* Dotted underline for tooltip words */
        }
        .tooltip-text {
            visibility: hidden;
            width: auto; /* Adjust width based on content */
            max-width: 500px; /* Increased max-width for more words */
            background-color: #333;
            color: #fff;
            text-align: left; /* Align text to left for multi-line */
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 100; /* Ensure tooltip is on top */
            bottom: 125%; /* Position above the text */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Allow text wrapping */
            word-wrap: break-word; /* Ensure long words break */
            font-size: 0.85rem;
            pointer-events: none; /* Allow clicks to pass through tooltip when not hovered */
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .login-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .login-button {
            width: 100%;
            background-color: #4299e1; /* Blue */
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #3182ce; /* Darker blue */
        }
        .error-message {
            color: #ef4444;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        /* New: Style for completed tests screen */
        .completed-tests-screen {
            background-color: #f0f4f8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }
        .completed-test-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .completed-test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .completed-test-card-details {
            border-left: 4px solid #3b82f6; /* Blue border for details */
            padding-left: 1rem;
            margin-top: 1rem;
        }
        .completed-test-details-question-card {
            background-color: #f8fafc;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
        }
        .user-answer {
            font-weight: 500;
        }
        /* Style for SVG container to ensure responsiveness */
        .svg-container {
            width: 100%;
            height: auto;
            max-width: 600px; /* New: Limit max width on large screens */
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            margin-left: auto; /* New: Center the container */
            margin-right: auto; /* New: Center the container */
        }
        /* New: Style for text inside the SVG */
        .svg-container svg text {
            font-family: 'Inter', sans-serif;
            font-size: 12px; /* Set a default font size */
        }
        /* Styles for the new modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
        }
    </style>
</head>
<body>
    <div id="loginScreen" class="login-container">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">Welcome to Jaleel's Verbal SAT Question Generator</h2>
        <input type="password" id="passwordInput" class="login-input" placeholder="Введите пароль">
        <button id="loginBtn" class="login-button">Войти</button>
        <p id="loginError" class="error-message" style="display: none;">Неверный пароль. Попробуйте снова.</p>
    </div>

    <div id="appContent" class="container" style="display: none;">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Генератор вопросов SAT (Verbal Section)</h1>
        
        <div class="mb-6">
            <label for="difficultySelect" class="block text-gray-700 text-sm font-bold mb-2">Выберите уровень сложности:</label>
            <select id="difficultySelect" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500">
                <option value="easy">Облегченный уровень (Easier Module)</option>
                <option value="hard">Усложненный уровень (Harder Module 2)</option>
                <option value="gre_gmat">Сложный уровень (GRE/GMAT-level)</option>
            </select>
        </div>
        
        <div class="mb-4">
            <button id="excludeTopicsBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75">
                Исключить темы
            </button>
        </div>

        <div id="categoryButtonsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <!-- Buttons for each category will be inserted here by JavaScript -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mb-4">
            <button id="showCompletedTestsBtn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                Завершенные тесты
            </button>
        </div>
        
        <div id="loadingIndicator" class="loading-indicator text-center" style="display: none;">
            <!-- Questions will be loaded here -->
        </div>
        
        <div id="questionsContainer" class="space-y-10">
            <!-- Questions will be loaded here -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mt-4">
            <button id="nextBtn" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                Следующий вопрос
            </button>
            <button id="saveAndExitBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" style="display: none;">
                Сохранить и выйти
            </button>
        </div>
    </div>

    <div id="completedTestsScreen" class="completed-tests-screen" style="display: none;">
        <button id="backToMainBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
            &larr; Назад в главное окно
        </button>
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Завершенные тесты</h1>
        <div id="testsListContainer" class="space-y-4">
            <!-- Completed tests will be listed here -->
        </div>
        <div id="completedTestDetailsContainer" class="mt-8" style="display: none;">
            <button id="backToTestsBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
                &larr; Назад к списку тестов
            </button>
            <button id="deleteTestBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mb-4 ml-4 transition duration-200 ease-in-out">
                Удалить тест
            </button>
            <div id="testReviewContainer">
                <!-- Detailed test review will be displayed here -->
            </div>
        </div>
    </div>

    <div id="excludeTopicsModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Исключить темы</h2>
            <div class="flex items-center space-x-2 mb-4">
                <input type="text" id="topicInput" class="login-input flex-grow" placeholder="Введите тему для исключения">
                <button id="addTopicBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Добавить</button>
            </div>
            <div id="excludedTopicsList" class="space-y-2 mb-4 max-h-40 overflow-y-auto p-2 bg-gray-100 rounded-md">
                <!-- Excluded topics will be listed here -->
            </div>
            <div class="flex justify-end space-x-4">
                <button id="cancelExcludeBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Ок</button>
            </div>
        </div>
    </div>

    <script type="module">
        const apiKey = "AIzaSyB6HddnRBVrrDWv_ujKlFx7ZQST1RzvcZs";
        
        const loginScreen = document.getElementById('loginScreen');
        const passwordInput = document.getElementById('passwordInput');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const appContent = document.getElementById('appContent');
        const categoryButtonsContainer = document.getElementById('categoryButtonsContainer');
        const questionsContainer = document.getElementById('questionsContainer');
        const showCompletedTestsBtn = document.getElementById('showCompletedTestsBtn');
        const completedTestsScreen = document.getElementById('completedTestsScreen');
        const testsListContainer = document.getElementById('testsListContainer');
        const completedTestDetailsContainer = document.getElementById('completedTestDetailsContainer');
        const testReviewContainer = document.getElementById('testReviewContainer');
        const backToTestsBtn = document.getElementById('backToTestsBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const difficultySelect = document.getElementById('difficultySelect');
        const nextBtn = document.getElementById('nextBtn');
        const saveAndExitBtn = document.getElementById('saveAndExitBtn');
        const deleteTestBtn = document.getElementById('deleteTestBtn');
        const excludeTopicsBtn = document.getElementById('excludeTopicsBtn');
        const excludeTopicsModal = document.getElementById('excludeTopicsModal');
        const topicInput = document.getElementById('topicInput');
        const addTopicBtn = document.getElementById('addTopicBtn');
        const excludedTopicsList = document.getElementById('excludedTopicsList');
        const cancelExcludeBtn = document.getElementById('cancelExcludeBtn');

        const categories = {
            "Information and Ideas": "information_ideas",
            "Craft and Structure": "craft_structure",
            "Expression of Ideas": "expression_ideas",
            "Standard English Conventions": "standard_english_conventions"
        };
        const labels = ['A', 'B', 'C', 'D'];

        let allGeneratedQuestions = {};
        let completedQuestions = [];
        let categoriesArray = [];
        let currentCategoryIndex = 0;
        let currentQuestionIndex = 0;
        let isSessionActive = false;
        let currentReviewingTest = null;
        let questionStartTime = 0; 

        const CORRECT_PASSWORDS = ["Jaleel2010", "Janiya2010", "Islam2008"];
        let inactivityTimer;
        const INACTIVITY_TIMEOUT = 5 * 60 * 1000;
        let generationCountdownInterval;
        const GENERATION_COUNTDOWN_SECONDS = 90;

        function parseApiResponse(text) {
            try {
                const jsonMatch = text.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                } else {
                    const objectMatch = text.match(/\{[\s\S]*\}/);
                    if (objectMatch) {
                        return JSON.parse(objectMatch[0]);
                    }
                }
            } catch (e) {
                console.error("Failed to parse JSON even after cleaning:", e);
                throw new Error("Invalid JSON format from API.");
            }
            throw new Error("No valid JSON found in API response.");
        }

        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(logoutUser, INACTIVITY_TIMEOUT);
        }

        function saveSession() {
            if (Object.keys(allGeneratedQuestions).length > 0) {
                const sessionData = {
                    categoryIndex: currentCategoryIndex,
                    questionIndex: currentQuestionIndex,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value,
                    completedQuestions: completedQuestions,
                    categoriesArray: categoriesArray,
                };
                localStorage.setItem('satQuizSession', JSON.stringify(sessionData));
                console.log('Session saved to localStorage.');
            }
        }

        async function loadSession() {
            const savedSession = localStorage.getItem('satQuizSession');
            if (savedSession) {
                const sessionData = JSON.parse(savedSession);
                
                if (!sessionData || !sessionData.questions || Object.keys(sessionData.questions).length === 0) {
                    localStorage.removeItem('satQuizSession');
                    console.error("Invalid or empty session data found. Clearing session.");
                    return false;
                }

                const confirmation = await showCustomConfirm('Обнаружена незавершенная сессия. Хотите продолжить с того места, где остановились?');
                
                if (confirmation) {
                    currentCategoryIndex = sessionData.categoryIndex;
                    currentQuestionIndex = sessionData.questionIndex;
                    allGeneratedQuestions = sessionData.questions;
                    difficultySelect.value = sessionData.difficulty;
                    completedQuestions = sessionData.completedQuestions || [];
                    categoriesArray = sessionData.categoriesArray || Object.keys(categories);
                    isSessionActive = true;
                    console.log('Session loaded from localStorage. Resuming test.');
                    return true;
                } else {
                    localStorage.removeItem('satQuizSession');
                    isSessionActive = false;
                    return false;
                }
            }
            return false;
        }

        function showCustomConfirm(message) {
            return new Promise(resolve => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modalOverlay.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <p class="text-lg font-semibold mb-4">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                            <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('confirmYes').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });
                document.getElementById('confirmNo').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(false);
                });
            });
        }

        function updateMainButtonsState(isDisabled) {
            document.querySelectorAll('#categoryButtonsContainer button, #showCompletedTestsBtn, #excludeTopicsBtn').forEach(button => {
                button.disabled = isDisabled;
                button.classList.toggle('opacity-50', isDisabled);
                button.classList.toggle('cursor-not-allowed', isDisabled);
            });
        }

        function logoutUser(saveCurrent = true) {
            if (saveCurrent) {
                saveSession();
            } else {
                localStorage.removeItem('satQuizSession');
            }
            
            isSessionActive = false;
            appContent.style.display = 'none';
            loginScreen.style.display = 'block';
            passwordInput.value = '';
            loginError.style.display = 'none';

            allGeneratedQuestions = {};
            completedQuestions = [];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            currentReviewingTest = null;
            categoriesArray = [];
            questionStartTime = 0;

            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            questionsContainer.innerHTML = '';
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';

            clearTimeout(inactivityTimer);
            clearInterval(generationCountdownInterval);
        }

        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        document.addEventListener('scroll', resetInactivityTimer);

        function createCategoryButtons() {
            categoryButtonsContainer.innerHTML = '';
            Object.keys(categories).forEach(categoryTitle => {
                const categoryKey = categories[categoryTitle];
                const button = document.createElement('button');
                button.id = `generateBtn-${categoryKey}`;
                button.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75';
                button.textContent = categoryTitle;
                button.addEventListener('click', () => handleNewTest(categoryKey));
                categoryButtonsContainer.appendChild(button);
            });
        }

        async function onAppReady() {
            console.log("App is ready.");
            const sessionResumed = await loadSession();
            if (sessionResumed) {
                displayCurrentQuestion();
                nextBtn.style.display = 'block';
                saveAndExitBtn.style.display = 'block';
                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите на кнопку категории, чтобы начать новый тест.</p>';
            }
        }

        loginBtn.addEventListener('click', async () => {
            if (CORRECT_PASSWORDS.includes(passwordInput.value)) {
                loginScreen.style.display = 'none';
                appContent.style.display = 'block';
                loginError.style.display = 'none';
                
                createCategoryButtons();
                await onAppReady();
                resetInactivityTimer();
            } else {
                loginError.style.display = 'block';
            }
        });

        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loginBtn.click();
            }
        });
        
        function startGenerationCountdown() {
            let timeLeft = GENERATION_COUNTDOWN_SECONDS;
            const timerElement = document.getElementById('timer');
            timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;

            generationCountdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;
                } else {
                    clearInterval(generationCountdownInterval);
                    timerElement.textContent = 'Время вышло, генерация продолжается...';
                }
            }, 1000);
        }

        function showLoading(message) {
            questionsContainer.innerHTML = '';
            loadingIndicator.innerHTML = `
                <p class="text-xl font-semibold mb-4 text-gray-700">${message}</p>
                <div id="timer" class="text-md font-medium text-gray-500 mb-4"></div>
                <div class="mt-4">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-gray-900 mx-auto"></div>
                </div>
            `;
            loadingIndicator.style.display = 'block';
            updateMainButtonsState(true);
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            clearInterval(generationCountdownInterval);
            startGenerationCountdown();
        }

        function hideLoading() {
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            clearInterval(generationCountdownInterval);
        }
        
        function getExcludedTopics() {
            const excludedTopics = localStorage.getItem('excludedTopics');
            return excludedTopics ? JSON.parse(excludedTopics) : [];
        }

        function saveExcludedTopics(topics) {
            localStorage.setItem('excludedTopics', JSON.stringify(topics));
        }

        function renderExcludedTopicsList() {
            const topics = getExcludedTopics();
            excludedTopicsList.innerHTML = '';
            if (topics.length === 0) {
                excludedTopicsList.innerHTML = '<p class="text-gray-500 text-center text-sm">Нет исключенных тем.</p>';
                return;
            }

            topics.forEach(topic => {
                const topicItem = document.createElement('div');
                topicItem.className = 'flex items-center justify-between p-2 bg-white rounded-md shadow-sm border border-gray-200';
                topicItem.innerHTML = `
                    <span class="text-gray-800">${topic}</span>
                    <button class="delete-topic-btn bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-2 rounded-full transition duration-200" data-topic="${topic}">
                        Удалить
                    </button>
                `;
                excludedTopicsList.appendChild(topicItem);
            });
        }
        
        excludeTopicsBtn.addEventListener('click', () => {
            renderExcludedTopicsList();
            excludeTopicsModal.classList.remove('hidden');
        });

        cancelExcludeBtn.addEventListener('click', () => {
            excludeTopicsModal.classList.add('hidden');
        });
        
        addTopicBtn.addEventListener('click', () => {
            const topic = topicInput.value.trim();
            if (topic) {
                const topics = getExcludedTopics();
                if (!topics.includes(topic)) {
                    topics.push(topic);
                    saveExcludedTopics(topics);
                    renderExcludedTopicsList();
                }
                topicInput.value = '';
            }
        });
        
        excludedTopicsList.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-topic-btn')) {
                const topicToDelete = event.target.dataset.topic;
                const topics = getExcludedTopics();
                const updatedTopics = topics.filter(t => t !== topicToDelete);
                saveExcludedTopics(updatedTopics);
                renderExcludedTopicsList();
            }
        });
        
        function getVocabCount(difficulty) {
            switch(difficulty) {
                case 'easy': return 4;
                case 'hard': return 6;
                case 'gre_gmat': return 8;
                default: return 4;
            }
        }

        async function generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, retries = 0) {
            const MAX_RETRIES = 5;
            const BASE_DELAY_MS = 1000;
            const numberOfQuestions = 10; 
            const vocabCount = getVocabCount(difficulty);
            const excludedTopics = getExcludedTopics();
            let prompt = "";
            
            let difficultyModifier;
            let wordCountRange;
            if (difficulty === 'easy') {
                difficultyModifier = 'straightforward';
                wordCountRange = '40-60';
            } else if (difficulty === 'hard') {
                difficultyModifier = 'challenging';
                wordCountRange = '60-80';
            } else if (difficulty === 'gre_gmat') {
                difficultyModifier = 'highly challenging';
                wordCountRange = '100-150';
            }
            
            const excludeText = excludedTopics.length > 0 ? `Explicitly and strictly avoid passages and questions on the following topics: ${excludedTopics.join(', ')}. It is critical that no generated content relates to these topics.` : '';
            
            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        passage: { type: "STRING" },
                        graphic: { type: "STRING" },
                        question: { type: "STRING" },
                        question_type: { type: "STRING" },
                        options: { type: "ARRAY", items: { type: "OBJECT", properties: { label: { type: "STRING" }, text: { type: "STRING" } }, required: ["label", "text"] } },
                        correct_answer: { type: "STRING" },
                        explanation: { type: "STRING" },
                        vocabulary: { type: "ARRAY", items: { type: "OBJECT", properties: { word: { "type": "STRING" }, translation: { "type": "STRING" }, synonyms: { "type": "STRING" } }, required: ["word", "translation", "synonyms"] } }
                    },
                    required: ["passage", "question", "question_type", "options", "correct_answer", "explanation"]
                }
            };
            
            switch (categoryKey) {
                case "information_ideas":
                    prompt = `Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Information and Ideas" questions in English, following this specific structure:
                        - 1 "Direct Question".
                        - 1 "Inference Question".
                        - 2 "Main Idea Questions".
                        - 1 "Figure-based Question" (MUST have an SVG graphic).
                        - 2 "Strengthen/Weaken Questions".
                        - 1 "Poem-based Question".
                        - 2 "Character Description Questions".
                        ${excludeText}
                        For each question, provide:
                        1. A 'question_type' field with the exact name from the list above.
                        2. A short, ${difficultyModifier} passage (${wordCountRange} words).
                        3. A specific SAT-style question.
                        4. Four answer choices (A, B, C, D). None of the options should be "NO CHANGE".
                        5. The correct answer label.
                        6. A brief explanation in Russian.
                        7. Identify ${vocabCount} complex English words with translations and synonyms.
                        8. For the "Figure-based Question", provide an SVG code string. For all others, provide an empty string.`;
                    break;
                case "craft_structure":
                    prompt = `Generate exactly ${numberOfQuestions} unique and diverse SAT-style "Craft and Structure" questions in English, following this structure:
                        - 2 "Vocabulary in Context" questions. For these, the passage must contain a blank space represented by exactly six underscores (______), and the question must be "Which choice completes the text with the most logical and precise word or phrase?".
                        - 2 "Primary Purpose" questions.
                        - 2 "Purpose of a Portion" questions.
                        - 2 "Structure" questions, asking about the overall structure or function of an underlined portion of the text.
                        - 1 "Cross-text Connection" question (requires two short passages).
                        - 1 "Quotes Illustrate" question.
                        ${excludeText}
                        For each question, provide:
                        1. A 'question_type' field with the exact name from the list above.
                        2. A short, ${difficultyModifier} passage (${wordCountRange} words). For "Cross-text Connection", provide two passages.
                        3. A specific SAT-style question.
                        4. Four answer choices (A, B, C, D). None of the options should be "NO CHANGE".
                        5. The correct answer label.
                        6. A brief explanation in Russian.
                        7. Identify ${vocabCount} complex English words with translations and synonyms.
                        8. For all questions, provide an empty string for the graphic property.`;
                    break;
                case "expression_ideas":
                    prompt = `Generate exactly ${numberOfQuestions} unique SAT-style "Expression of Ideas" questions in English, with this structure:
                        - 5 "Transition Questions". For these, the passage must contain a blank space represented by exactly six underscores (______), where a transition word or phrase is missing.
                        - 5 "Goal-based Questions".
                        ${excludeText}
                        For each question, provide:
                        1. A 'question_type' field with the exact name from the list above.
                        2. A short, ${difficultyModifier} passage (${wordCountRange} words) from a student's draft.
                        3. A specific SAT-style question.
                        4. Four answer choices (A, B, C, D). None of the options should be "NO CHANGE".
                        5. The correct answer label.
                        6. A brief explanation in Russian.
                        7. Identify ${vocabCount} complex English words with translations and synonyms.
                        8. For all questions, provide an empty string for the graphic property.`;
                    break;
                case "standard_english_conventions":
                    prompt = `Generate exactly ${numberOfQuestions} unique SAT-style "Standard English Conventions" questions, each focusing on a different rule:
                        - 1 "Subject-verb agreement".
                        - 1 "Subject pronoun agreement".
                        - 1 "Comma subject rule".
                        - 1 "Punctuation on the SAT".
                        - 1 "Apostrophe".
                        - 1 "Listing".
                        - 1 "Introduction of a list or description".
                        - 1 "Comparison".
                        - 2 "Tense".
                        ${excludeText}
                        For each question, provide:
                        1. A 'question_type' field with the exact name of the rule from the list above.
                        2. A short, ${difficultyModifier} passage (${wordCountRange} words). The part of the passage with the grammatical error must be replaced with a blank space represented by exactly six underscores (______).
                        3. The question "Which choice completes the text so that it conforms to the conventions of Standard English?".
                        4. Four answer choices (A, B, C, D), where one choice correctly fills the blank according to the specified grammatical rule, and the others are plausible distractors. None of the options should be "NO CHANGE".
                        5. The correct answer label.
                        6. A brief explanation in Russian.
                        7. Identify ${vocabCount} complex English words with translations and synonyms.
                        8. For all questions, provide an empty string for the graphic property.`;
                    break;
            }

            try {
                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema: responseSchema } };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) {
                    const errorDetails = await response.text();
                    throw new Error(`HTTP Error: ${response.status} ${response.statusText}. Details: ${errorDetails}`);
                }
                const result = await response.json();
                const questionsArray = parseApiResponse(result?.candidates?.[0]?.content?.parts?.[0]?.text || "[]");
                if (!Array.isArray(questionsArray) || questionsArray.length !== numberOfQuestions) {
                    throw new Error(`API returned ${questionsArray.length} questions instead of ${numberOfQuestions}.`);
                }
                return questionsArray;
            } catch (error) {
                console.error(`Error generating questions for ${categoryTitle} (Difficulty: ${difficulty}):`, error);
                if (retries < MAX_RETRIES) {
                    const delay = BASE_DELAY_MS * Math.pow(2, retries) + (Math.random() * 100);
                    console.warn(`Retrying generation for ${categoryTitle} in ${delay}ms (Attempt ${retries + 1}/${MAX_RETRIES})...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, retries + 1);
                } else {
                    hideLoading();
                    questionsContainer.innerHTML = `<p class="text-center text-red-600 font-bold text-lg">Ошибка генерации вопросов. Пожалуйста, попробуйте еще раз.</p>`;
                    updateMainButtonsState(false);
                    return null;
                }
            }
        }

        async function handleNewTest(categoryKey) {
            categoriesArray = [categoryKey];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            isSessionActive = true;
            completedQuestions = [];
            showLoading("Генерация вопросов... Пожалуйста, подождите.");
            try {
                const questions = await generateQuestionsForCategory(Object.keys(categories).find(key => categories[key] === categoryKey), categoryKey, difficultySelect.value);
                if (questions) {
                    allGeneratedQuestions = { [categoryKey]: questions };
                    hideLoading();
                    displayCurrentQuestion();
                    nextBtn.style.display = 'block';
                    saveAndExitBtn.style.display = 'block';
                    updateMainButtonsState(true);
                }
            } catch (error) {
                hideLoading();
                questionsContainer.innerHTML = `<p class="text-center text-red-600 font-bold text-lg">Ошибка при загрузке вопросов: ${error.message}</p>`;
                updateMainButtonsState(false);
            }
        }
        
        function displayCurrentQuestion() {
            if (!isSessionActive) return;
            const currentCategoryKey = categoriesArray[currentCategoryIndex];
            if (!allGeneratedQuestions[currentCategoryKey] || allGeneratedQuestions[currentCategoryKey].length === 0) {
                endQuiz();
                return;
            }
            const questions = allGeneratedQuestions[currentCategoryKey];
            if (currentQuestionIndex >= questions.length) {
                endQuiz();
                return;
            }
            const questionData = questions[currentQuestionIndex];
            questionsContainer.innerHTML = renderQuestion(questionData, currentQuestionIndex + 1, questions.length, currentCategoryKey);
            questionStartTime = Date.now();
            nextBtn.disabled = true;
            nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }

        function handleAnswerSelection(event, questionIndex, categoryKey) {
            const selectedOption = event.target.closest('.option-item');
            if (!selectedOption) return;
            const userChoice = selectedOption.dataset.label;
            const questionData = allGeneratedQuestions[categoryKey][questionIndex];
            
            // This check is removed as it was causing issues with duplicate question texts.
            // The UI disabling the options is sufficient to prevent multiple answers for the same question instance.
            completedQuestions.push({
                question: questionData,
                userAnswer: userChoice,
                timeTaken: (Date.now() - questionStartTime) / 1000,
                isCorrect: userChoice === questionData.correct_answer
            });
            
            const options = selectedOption.parentNode.querySelectorAll('.option-item');
            options.forEach(option => {
                option.classList.add('disabled');
                const label = option.dataset.label;
                if (label === questionData.correct_answer) option.classList.add('correct');
                if (label === userChoice && userChoice !== questionData.correct_answer) option.classList.add('incorrect');
            });
            const explanationElement = document.getElementById(`explanation-${questionIndex}`);
            if (explanationElement) explanationElement.style.display = 'block';
            nextBtn.disabled = false;
            nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        }

        function renderQuestion(questionData, number, total, categoryKey) {
            const categoryName = Object.keys(categories).find(key => categories[key] === categoryKey);
            let passageHtml = questionData.passage;
            let questionText = questionData.question;
            if (passageHtml.includes('______')) {
                 passageHtml = passageHtml.replace('______', '<span class="font-bold">______</span>');
            }
            if (questionData.vocabulary && questionData.vocabulary.length > 0) {
                questionData.vocabulary.forEach(vocab => {
                    const regex = new RegExp(`\\b${vocab.word}\\b`, 'g');
                    passageHtml = passageHtml.replace(regex, `<span class="tooltip-container">${vocab.word}<span class="tooltip-text">${vocab.translation}<br>Синонимы: ${vocab.synonyms}</span></span>`);
                });
            }
            let graphicHtml = questionData.graphic ? `<div class="svg-container">${questionData.graphic}</div>` : '';
            const optionsHtml = questionData.options.map((option, index) => {
                const label = labels[index];
                return `<div class="option-item flex items-start space-x-2 p-2" data-label="${label}"><div class="font-bold w-6">${label}.</div><div class="flex-1">${option.text}</div></div>`;
            }).join('');
            return `<div id="question-card-${number - 1}" class="question-card">
                    <div class="flex justify-between items-center mb-2">
                        <p class="text-lg font-semibold text-gray-800">Вопрос ${number} из ${total}</p>
                        <p class="text-sm font-medium text-gray-500">${categoryName} (${questionData.question_type})</p>
                    </div>
                    ${graphicHtml}
                    <p class="question-passage">${passageHtml}</p>
                    <p class="question-text">${questionText}</p>
                    <div class="options-container">${optionsHtml}</div>
                    <div id="explanation-${number - 1}" class="explanation"><p class="font-semibold">Объяснение:</p><p>${questionData.explanation}</p></div>
                </div>`;
        }
        
        questionsContainer.addEventListener('click', (event) => {
            const optionItem = event.target.closest('.option-item');
            if (optionItem && !optionItem.classList.contains('disabled')) {
                const questionCard = event.target.closest('.question-card');
                const questionIndex = parseInt(questionCard.id.split('-')[2]);
                const currentCategory = categoriesArray[currentCategoryIndex];
                handleAnswerSelection(event, questionIndex, currentCategory);
            }
        });
        
        nextBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            displayCurrentQuestion();
        });

        saveAndExitBtn.addEventListener('click', () => {
            logoutUser(true);
        });

        function endQuiz() {
            saveCompletedTest(); 
            isSessionActive = false;
            updateMainButtonsState(false);
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            localStorage.removeItem('satQuizSession');
            showSummaryScreen();
        }

        function showSummaryScreen() {
            const correctCount = completedQuestions.filter(q => q.isCorrect).length;
            const totalQuestions = completedQuestions.length;
            questionsContainer.innerHTML = `<div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4 mb-6 rounded-lg shadow-md" role="alert">
                    <p class="font-bold text-lg">Тест завершен!</p>
                    <p>Вы завершили тест. Правильных ответов: ${correctCount} из ${totalQuestions}.</p>
                </div>
                <p class="text-center text-gray-600">Вы можете просмотреть свои результаты и объяснения в разделе "Завершенные тесты".</p>`;
        }

        showCompletedTestsBtn.addEventListener('click', showCompletedTestsList);
        backToMainBtn.addEventListener('click', () => {
            completedTestsScreen.style.display = 'none';
            appContent.style.display = 'block';
            updateMainButtonsState(isSessionActive);
        });

        function saveCompletedTest() {
            if (completedQuestions.length === 0) return;
            const newTest = {
                id: Date.now().toString(),
                date: new Date().toLocaleString(),
                questions: completedQuestions,
                difficulty: difficultySelect.value,
                category: Object.keys(categories).find(key => categories[key] === categoriesArray[0]),
                correctCount: completedQuestions.filter(q => q.isCorrect).length,
                totalQuestions: completedQuestions.length,
                createdAt: new Date().toISOString()
            };
            const completedTests = JSON.parse(localStorage.getItem('completedSatTests')) || [];
            completedTests.push(newTest);
            localStorage.setItem('completedSatTests', JSON.stringify(completedTests));
            console.log("Тест успешно сохранен в localStorage!");
        }

        function showCompletedTestsList() {
            appContent.style.display = 'none';
            completedTestsScreen.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            const tests = JSON.parse(localStorage.getItem('completedSatTests')) || [];
            tests.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            testsListContainer.innerHTML = '';
            if (tests.length === 0) {
                testsListContainer.innerHTML = `<p class="text-center text-gray-500">Пока нет завершенных тестов.</p>`;
                return;
            }
            tests.forEach(test => {
                const testCard = document.createElement('div');
                testCard.className = 'completed-test-card';
                testCard.innerHTML = `<p class="text-lg font-bold text-gray-800">${test.category} - ${test.date}</p>
                    <p class="text-sm text-gray-600">Сложность: ${test.difficulty}</p>
                    <p class="text-md font-semibold mt-2">Правильных ответов: ${test.correctCount} из ${test.totalQuestions}</p>`;
                testCard.addEventListener('click', () => showTestReview(test));
                testsListContainer.appendChild(testCard);
            });
        }
        
        function showTestReview(test) {
            currentReviewingTest = test;
            testsListContainer.style.display = 'none';
            completedTestDetailsContainer.style.display = 'block';
            const reviewHtml = test.questions.map((q, index) => {
                const questionData = q.question;
                const userChoice = q.userAnswer;
                const isCorrect = q.isCorrect;
                let passageHtml = questionData.passage;
                if (questionData.vocabulary && questionData.vocabulary.length > 0) {
                    questionData.vocabulary.forEach(vocab => {
                        const regex = new RegExp(`\\b${vocab.word}\\b`, 'g');
                        passageHtml = passageHtml.replace(regex, `<span class="tooltip-container">${vocab.word}<span class="tooltip-text">${vocab.translation}<br>Синонимы: ${vocab.synonyms}</span></span>`);
                    });
                }
                let graphicHtml = questionData.graphic ? `<div class="svg-container">${questionData.graphic}</div>` : '';
                const optionsHtml = questionData.options.map((option, optionIndex) => {
                    const label = labels[optionIndex];
                    let optionClasses = 'p-2 rounded-md';
                    if (label === questionData.correct_answer) optionClasses += ' bg-green-200 border-green-500';
                    if (label === userChoice && !isCorrect) optionClasses += ' bg-red-200 border-red-500';
                    return `<div class="${optionClasses}"><span class="font-bold">${label}.</span> ${option.text}${label === userChoice ? '<span class="user-answer ml-2">(Ваш ответ)</span>' : ''}</div>`;
                }).join('');
                return `<div class="completed-test-details-question-card">
                        <p class="text-md font-semibold mb-2">Вопрос ${index + 1}:</p>
                        ${graphicHtml}
                        <p class="question-passage">${passageHtml}</p>
                        <p class="question-text">${questionData.question}</p>
                        <div class="space-y-2 mb-4">${optionsHtml}</div>
                        <div class="explanation"><p class="font-semibold">Объяснение:</p><p>${questionData.explanation}</p></div>
                    </div>`;
            }).join('');
            testReviewContainer.innerHTML = `<h2 class="text-3xl font-bold text-gray-800 mb-4">${test.category} Тест - Результаты</h2>
                <div class="bg-gray-100 p-4 rounded-lg mb-6">
                    <p class="font-semibold">Дата: ${test.date}</p>
                    <p class="font-semibold">Сложность: ${test.difficulty}</p>
                    <p class="font-semibold">Правильных ответов: ${test.correctCount} из ${test.totalQuestions}</p>
                    <p class="text-xs text-gray-500 mt-2">ID Теста: ${test.id}</p>
                </div>
                ${reviewHtml}`;
        }
        
        backToTestsBtn.addEventListener('click', () => {
            testsListContainer.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            showCompletedTestsList();
        });

        deleteTestBtn.addEventListener('click', async () => {
            if (currentReviewingTest) {
                const confirmation = await showCustomConfirm('Вы уверены, что хотите удалить этот тест? Это действие необратимо.');
                if (confirmation) {
                    let tests = JSON.parse(localStorage.getItem('completedSatTests')) || [];
                    tests = tests.filter(test => test.id !== currentReviewingTest.id);
                    localStorage.setItem('completedSatTests', JSON.stringify(tests));
                    backToTestsBtn.click();
                }
            }
        });

    </script>
</body>
</html>


