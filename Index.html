<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор вопросов SAT</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }
        .section-title {
            border-bottom: 2px solid #cbd5e1;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .question-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0;
        }
        .question-passage {
            font-style: italic;
            color: #4a5568;
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .question-text {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2d3748;
        }
        .option-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .option-item:hover:not(.disabled) {
            background-color: #f3f4f6;
        }
        .option-item.correct {
            background-color: #d1fae5;
            border-color: #34d399;
            font-weight: 500;
        }
        .option-item.incorrect {
            background-color: #fee2e2;
            border-color: #ef4444;
            font-weight: 500;
        }
        .option-item.disabled {
            pointer-events: none;
            opacity: 0.8;
        }
        .explanation {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #e2e8f0;
            font-size: 0.9rem;
            color: #4a5568;
            display: none;
        }
        .start-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .start-button {
            width: 100%;
            background-color: #4299e1;
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .start-button:hover {
            background-color: #3182ce;
        }
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #94a3b8;
        }
        .tooltip-text {
            visibility: hidden;
            width: auto;
            min-width: 180px;
            max-width: 500px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal;
            word-wrap: break-word;
            font-size: 0.85rem;
            pointer-events: none;
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            text-align: center;
        }
        .modal-button {
            background-color: #4299e1;
            color: white;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .modal-button:hover {
            background-color: #3182ce;
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-container">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">Добро пожаловать в Генератор вопросов SAT</h2>
        <p class="text-gray-600 mb-6">Нажмите кнопку ниже, чтобы начать.</p>
        <button id="startBtn" class="start-button">Начать</button>
    </div>

    <div id="appContent" class="container" style="display: none;">
        <div class="flex items-center justify-between mb-4 flex-wrap">
            <h1 class="text-4xl font-bold text-gray-800 mb-2 sm:mb-0">Генератор вопросов SAT</h1>
            <div id="userIdDisplay" class="text-sm text-gray-600">ID пользователя: <span class="font-mono text-gray-800 break-all"></span></div>
        </div>

        <div class="mb-6">
            <label for="difficultySelect" class="block text-gray-700 text-sm font-bold mb-2">Выберите уровень сложности:</label>
            <select id="difficultySelect" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500">
                <option value="easy" selected>Облегченный уровень (Easier Module)</option>
                <option value="hard">Усложненный уровень (Harder Module 2)</option>
            </select>
        </div>

        <div class="flex flex-col sm:flex-row gap-4 mb-8">
            <button id="generateBtn" class="w-full sm:w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75">
                Сгенерировать вопросы
            </button>
            <button id="viewResultsBtn" class="w-full sm:w-1/2 bg-gray-400 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out cursor-not-allowed" disabled>
                Посмотреть завершённые тесты
            </button>
        </div>
        
        <div id="loadingIndicator" class="loading-indicator" style="display: none;">
        </div>

        <div id="questionsContainer" class="space-y-10">
        </div>

        <div id="resultsContainer" class="space-y-4" style="display:none;">
            <h2 class="text-2xl font-bold text-gray-800 section-title mb-4">Завершённые тесты</h2>
            <div id="resultsList" class="flex flex-col gap-2">
                <!-- Completed test results will be loaded here -->
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mt-4">
            <button id="nextBtn" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                Следующий вопрос
            </button>
            <button id="saveAndExitBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" style="display: none;">
                Сохранить и выйти
            </button>
        </div>
        <div id="saveStatus" class="mt-4 text-center text-sm font-semibold text-gray-700" style="display: none;"></div>
    </div>

    <script type="module">
        // Import all necessary Firebase and Gemini modules in a single block for better management
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, where, getDocs, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { GoogleGenerativeAI } from 'https://esm.sh/@google/generative-ai';

        // ==========================================================================================================
        //  The code has been updated to use a more robust initialization flow within a single module script.
        //  This should resolve any potential timing or loading issues that may have prevented the 'Start' button
        //  from working. Added console logs for better debugging.
        // ==========================================================================================================
        
        // Canvas environment variables are provided automatically
        const firebaseConfig = JSON.parse(__firebase_config);
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Gemini API key is also provided automatically
        const apiKey = "";
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let app, auth, db; // Declare variables for global access
        let userId = null;
        let isAuthReady = false;
        
        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-preview-05-20" });

        // Get DOM elements
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const appContent = document.getElementById('appContent');
        const userIdDisplay = document.getElementById('userIdDisplay').querySelector('span');
        const generateBtn = document.getElementById('generateBtn');
        const viewResultsBtn = document.getElementById('viewResultsBtn');
        const questionsContainer = document.getElementById('questionsContainer');
        const resultsContainer = document.getElementById('resultsContainer');
        const resultsList = document.getElementById('resultsList');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const difficultySelect = document.getElementById('difficultySelect');
        const nextBtn = document.getElementById('nextBtn');
        const saveAndExitBtn = document.getElementById('saveAndExitBtn');
        const saveStatus = document.getElementById('saveStatus');

        const categories = {
            "Information and Ideas": "information_ideas",
            "Craft and Structure": "craft_structure",
            "Expression of Ideas": "expression_ideas",
            "Standard English Conventions": "standard_english_conventions"
        };

        let allGeneratedQuestions = {};
        let categoriesArray = Object.keys(categories);
        let currentCategoryIndex = 0;
        let currentQuestionIndex = 0;

        let inactivityTimer;
        const INACTIVITY_TIMEOUT = 30 * 60 * 1000;
        let countdownIntervalId;
        const COUNTDOWN_DURATION = 90;

        // Function to display a simple modal for errors or confirmations
        function showModal(message, isError = false) {
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.innerHTML = `
                <div class="modal-content">
                    <p class="text-lg font-semibold mb-4 text-gray-800">${message}</p>
                    <button id="modalCloseBtn" class="modal-button">ОК</button>
                </div>
            `;
            document.body.appendChild(modalOverlay);
            document.getElementById('modalCloseBtn').addEventListener('click', () => {
                document.body.removeChild(modalOverlay);
            });
            console.error(message);
        }

        function updateViewResultsButtonState(disabled) {
            viewResultsBtn.disabled = disabled;
            if (disabled) {
                viewResultsBtn.classList.add('bg-gray-400', 'cursor-not-allowed', 'hover:bg-gray-400', 'transform-none');
                viewResultsBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'transform', 'hover:scale-105');
            } else {
                viewResultsBtn.classList.remove('bg-gray-400', 'cursor-not-allowed', 'hover:bg-gray-400', 'transform-none');
                viewResultsBtn.classList.add('bg-blue-600', 'hover:bg-blue-700', 'transform', 'hover:scale-105');
            }
        }

        function showStatus(message, isError = false) {
            saveStatus.textContent = message;
            saveStatus.style.display = 'block';
            saveStatus.className = `mt-4 text-center text-sm font-semibold ${isError ? 'text-red-600' : 'text-green-600'}`;
            setTimeout(() => {
                saveStatus.style.display = 'none';
            }, 3000);
        }
        
        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(logoutUser, INACTIVITY_TIMEOUT);
        }

        async function saveSessionToFirestore() {
            if (!isAuthReady || Object.keys(allGeneratedQuestions).length === 0) {
                return;
            }

            try {
                const sessionDocRef = doc(db, `artifacts/${appId}/public/data/sat_sessions`, userId);
                const sessionData = {
                    userId: userId,
                    categoryIndex: currentCategoryIndex,
                    questionIndex: currentQuestionIndex,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value,
                    timestamp: new Date().toISOString()
                };
                
                await setDoc(sessionDocRef, sessionData);
                showStatus('Прогресс сохранён!');
            } catch (error) {
                console.error('Error saving session to Firestore:', error);
                showStatus('Ошибка сохранения прогресса.', true);
            }
        }

        async function checkForActiveSession() {
            if (!isAuthReady) {
                return false;
            }
            try {
                const sessionDocRef = doc(db, `artifacts/${appId}/public/data/sat_sessions`, userId);
                const docSnap = await getDoc(sessionDocRef);
                return docSnap.exists() && Object.keys(docSnap.data()).length > 0;
            } catch (error) {
                console.error('Error checking for active session:', error);
                return false;
            }
        }

        async function loadSessionFromFirestore() {
            if (!isAuthReady) {
                return false;
            }
            try {
                const sessionDocRef = doc(db, `artifacts/${appId}/public/data/sat_sessions`, userId);
                const docSnap = await getDoc(sessionDocRef);

                if (docSnap.exists() && Object.keys(docSnap.data()).length > 0) {
                    const confirmation = showCustomConfirm('Обнаружена незавершенная сессия. Хотите продолжить с того места, где остановились?');
                    
                    const resume = await confirmation;
                    if (resume) {
                        const sessionData = docSnap.data();
                        currentCategoryIndex = sessionData.categoryIndex;
                        currentQuestionIndex = sessionData.questionIndex;
                        allGeneratedQuestions = sessionData.questions;
                        difficultySelect.value = sessionData.difficulty;
                        console.log('Session loaded from Firestore. Resuming test.');
                        return true;
                    } else {
                        await setDoc(sessionDocRef, {});
                        console.log('Saved session discarded from Firestore.');
                        return false;
                    }
                }
            } catch (error) {
                console.error('Error loading session from Firestore:', error);
            }
            return false;
        }

        async function saveCompletedTestToFirestore() {
            if (!isAuthReady || Object.keys(allGeneratedQuestions).length === 0) {
                return;
            }

            try {
                const completedTestColRef = collection(db, `artifacts/${appId}/public/data/sat_completed_tests`);
                const completedTestData = {
                    userId: userId,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value,
                    timestamp: new Date().toISOString()
                };
                
                await addDoc(completedTestColRef, completedTestData);
                
                const sessionDocRef = doc(db, `artifacts/${appId}/public/data/sat_sessions`, userId);
                await setDoc(sessionDocRef, {});

                showStatus('Тест сохранён в историю!');
            } catch (error) {
                console.error('Error saving completed test to Firestore:', error);
                showStatus('Ошибка сохранения завершённого теста.', true);
            }
        }

        async function loadCompletedTests() {
            if (!isAuthReady) {
                showStatus('Ошибка: Не авторизован.', true);
                return;
            }
            
            questionsContainer.style.display = 'none';
            resultsContainer.style.display = 'block';
            resultsList.innerHTML = '<p class="text-center text-gray-500">Загрузка...</p>';
            generateBtn.style.display = 'none';
            viewResultsBtn.style.display = 'none';
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';

            try {
                const completedTestColRef = collection(db, `artifacts/${appId}/public/data/sat_completed_tests`);
                const q = query(completedTestColRef, where("userId", "==", userId));
                const querySnapshot = await getDocs(q);

                const tests = [];
                querySnapshot.forEach((doc) => {
                    tests.push({ id: doc.id, ...doc.data() });
                });

                resultsList.innerHTML = '';
                if (tests.length === 0) {
                    resultsList.innerHTML = '<p class="text-center text-gray-500">Нет завершённых тестов.</p>';
                } else {
                    tests.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    tests.forEach(test => {
                        const testCard = document.createElement('div');
                        testCard.className = 'bg-white p-4 rounded-lg shadow-md cursor-pointer hover:bg-gray-100 transition duration-200';
                        const date = new Date(test.timestamp).toLocaleString('ru-RU');
                        const difficulty = test.difficulty === 'hard' ? 'Усложненный' : 'Облегченный';
                        testCard.innerHTML = `<p class="font-semibold">Тест от ${date}</p><p class="text-sm text-gray-600">Сложность: ${difficulty}</p>`;
                        testCard.addEventListener('click', () => {
                            loadSpecificCompletedTest(test.id);
                        });
                        resultsList.appendChild(testCard);
                    });
                }
            } catch (error) {
                console.error('Error loading completed tests:', error);
                resultsList.innerHTML = `<p class="text-center text-red-600">Ошибка при загрузке результатов.</p>`;
            } finally {
                generateBtn.style.display = 'block';
                viewResultsBtn.style.display = 'block';
                updateViewResultsButtonState(await checkForActiveSession());
            }
        }

        async function loadSpecificCompletedTest(testId) {
            if (!isAuthReady) return;
            showLoading();
            questionsContainer.style.display = 'block';
            resultsContainer.style.display = 'none';
            generateBtn.style.display = 'none';
            viewResultsBtn.style.display = 'none';
            
            try {
                const docRef = doc(db, `artifacts/${appId}/public/data/sat_completed_tests`, testId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const testData = docSnap.data();
                    allGeneratedQuestions = testData.questions;
                    questionsContainer.innerHTML = '';
                    renderCompletedTestResults(allGeneratedQuestions, testData.difficulty, testData.timestamp);
                } else {
                    questionsContainer.innerHTML = `<p class="text-center text-red-600">Тест не найден.</p>`;
                }
            } catch (error) {
                console.error('Error loading specific completed test:', error);
                questionsContainer.innerHTML = `<p class="text-center text-red-600">Ошибка при загрузке теста.</p>`;
            } finally {
                hideLoading();
                generateBtn.style.display = 'block';
                viewResultsBtn.style.display = 'block';
                updateViewResultsButtonState(await checkForActiveSession());
            }
        }

        function renderCompletedTestResults(questions, difficulty, timestamp) {
            questionsContainer.innerHTML = '';
            const testDate = new Date(timestamp).toLocaleString('ru-RU');
            const difficultyText = difficulty === 'hard' ? 'Усложненный' : 'Облегченный';
            
            let correctAnswers = 0;
            let totalQuestions = 0;

            const resultsHeader = document.createElement('div');
            resultsHeader.className = 'mb-8 text-center';
            resultsHeader.innerHTML = `
                <h2 class="text-3xl font-bold text-gray-800">Результаты теста</h2>
                <p class="text-lg text-gray-600 mt-2">Дата: ${testDate} | Сложность: ${difficultyText}</p>
            `;
            questionsContainer.appendChild(resultsHeader);

            for (const categoryTitle of Object.keys(questions)) {
                const categoryQuestions = questions[categoryTitle];
                
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'category-section mb-10';
                
                const sectionTitle = document.createElement('h2');
                sectionTitle.className = 'text-2xl font-semibold text-gray-700 mb-6 section-title';
                sectionTitle.textContent = categoryTitle;
                sectionDiv.appendChild(sectionTitle);

                categoryQuestions.forEach((q, index) => {
                    const questionCard = createQuestionCard(q, categoryTitle, `Вопрос ${index + 1}`);
                    sectionDiv.appendChild(questionCard);
                    totalQuestions++;
                    if (q.user_answer === q.correct_answer) {
                        correctAnswers++;
                    }
                });

                questionsContainer.appendChild(sectionDiv);
            }
            
            const scoreCard = document.createElement('div');
            scoreCard.className = 'question-card text-center';
            scoreCard.innerHTML = `<p class="text-xl font-bold">Ваш результат: ${correctAnswers} из ${totalQuestions}</p>`;
            questionsContainer.insertBefore(scoreCard, resultsHeader.nextSibling);
        }

        function createQuestionCard(questionData, categoryTitle, questionNumberText, isInteractive = false) {
            const questionCard = document.createElement('div');
            questionCard.className = 'question-card';

            let passageContent = questionData.passage;
            if (questionData.vocabulary && Array.isArray(questionData.vocabulary)) {
                questionData.vocabulary.forEach(vocabItem => {
                    const escapedWord = vocabItem.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi'); 
                    passageContent = passageContent.replace(regex, (matchedWord) => {
                        const formattedWordInTooltip = `<strong>${matchedWord.charAt(0).toUpperCase() + matchedWord.slice(1)}</strong>`;
                        return `<span class="tooltip-container">${matchedWord}<span class="tooltip-text">${formattedWordInTooltip}: ${vocabItem.translation}: ${vocabItem.explanation}</span></span>`;
                    });
                });
            }

            if (categoryTitle === "Craft and Structure" && questionData.highlighted_word) {
                const escapedHighlightedWord = questionData.highlighted_word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const highlightRegex = new RegExp(`\\b${escapedHighlightedWord}\\b`, 'gi');
                passageContent = passageContent.replace(highlightRegex, `<span class="font-bold underline">${questionData.highlighted_word}</span>`);
            } else if (categoryTitle === "Standard English Conventions") {
                passageContent = passageContent.replace(/\*\*(.*?)\*\*/g, `<span class="font-bold underline text-red-600">$1</span>`);
            }

            const passageDiv = document.createElement('div');
            passageDiv.className = 'question-passage';
            passageDiv.innerHTML = passageContent;

            const questionTextDiv = document.createElement('div');
            questionTextDiv.className = 'question-text';
            questionTextDiv.textContent = questionNumberText ? `${questionNumberText}: ${questionData.question}` : questionData.question;
            
            const optionsList = document.createElement('div');
            optionsList.className = 'options-list';
            
            let optionsToDisplay = Array.isArray(questionData.options) ? questionData.options : [];
            
            optionsToDisplay.forEach(option => {
                const optionItem = document.createElement('div');
                optionItem.className = `option-item px-4 py-2 rounded-md transition duration-200 ease-in-out`;
                optionItem.textContent = `${option.label}. ${option.text}`;
                optionItem.dataset.label = option.label;

                if (isInteractive) {
                    optionItem.classList.add('cursor-pointer', 'hover:bg-gray-100');
                    optionItem.addEventListener('click', function() {
                        optionsList.querySelectorAll('.option-item').forEach(opt => {
                            opt.classList.add('disabled');
                            opt.style.pointerEvents = 'none';
                        });

                        const selectedLabel = this.dataset.label;
                        const correctAnswerLabel = questionData.correct_answer;

                        questionData.user_answer = selectedLabel;
                        
                        optionsList.querySelectorAll('.option-item').forEach(opt => {
                            if (opt.dataset.label === correctAnswerLabel) {
                                opt.classList.add('correct');
                            } else if (opt.dataset.label === selectedLabel) {
                                opt.classList.add('incorrect');
                            }
                        });

                        explanationDiv.style.display = 'block';
                        nextBtn.disabled = false;
                        nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        resetInactivityTimer();
                    });
                } else {
                    optionItem.classList.add('disabled');
                    if (option.label === questionData.correct_answer) {
                        optionItem.classList.add('correct');
                    } else if (option.label === questionData.user_answer) {
                        optionItem.classList.add('incorrect');
                    }
                }
                optionsList.appendChild(optionItem);
            });
            
            const explanationDiv = document.createElement('div');
            explanationDiv.className = 'explanation';
            explanationDiv.textContent = `Объяснение: ${questionData.explanation}`;
            
            if (!isInteractive) {
                 explanationDiv.style.display = 'block';
            } else {
                explanationDiv.style.display = 'none';
            }

            questionCard.appendChild(passageDiv);
            questionCard.appendChild(questionTextDiv);
            questionCard.appendChild(optionsList);
            questionCard.appendChild(explanationDiv);

            return questionCard;
        }

        function displayCurrentQuestion() {
            const currentCategoryTitle = categoriesArray[currentCategoryIndex];
            const currentCategoryKey = categories[currentCategoryTitle];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];

            if (questionsInCurrentCategory && questionsInCurrentCategory.length > currentQuestionIndex) {
                questionsContainer.innerHTML = '';
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'category-section mb-10';

                const sectionTitle = document.createElement('h2');
                sectionTitle.className = 'text-2xl font-semibold text-gray-700 mb-6 section-title';
                sectionTitle.textContent = `${currentCategoryTitle} (Вопрос ${currentQuestionIndex + 1} из ${questionsInCurrentCategory.length})`;
                sectionDiv.appendChild(sectionTitle);

                const questionData = questionsInCurrentCategory[currentQuestionIndex];
                const questionCard = createQuestionCard(questionData, currentCategoryTitle, null, true);
                if (questionCard) {
                    sectionDiv.appendChild(questionCard);
                }
                questionsContainer.appendChild(sectionDiv);

                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                nextBtn.style.display = 'block';
                saveAndExitBtn.style.display = 'block';

                if (currentCategoryIndex === categoriesArray.length - 1 && currentQuestionIndex === questionsInCurrentCategory.length - 1) {
                    nextBtn.textContent = 'Завершить тест';
                } else {
                    nextBtn.textContent = 'Следующий вопрос';
                }

            } else {
                questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Тест завершен!</p>';
                nextBtn.style.display = 'none';
                saveAndExitBtn.style.display = 'none';
                saveCompletedTestToFirestore();
            }
        }
        
        function customPrompt(message, onConfirm, onCancel = () => {}) {
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
            modalOverlay.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                    <p class="text-lg font-semibold mb-4">${message}</p>
                    <div class="flex justify-center space-x-4">
                        <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                        <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            document.getElementById('confirmYes').addEventListener('click', () => {
                document.body.removeChild(modalOverlay);
                onConfirm();
            });
            document.getElementById('confirmNo').addEventListener('click', () => {
                document.body.removeChild(modalOverlay);
                onCancel();
            });
        }

        function showCustomConfirm(message) {
            return new Promise(resolve => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modalOverlay.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <p class="text-lg font-semibold mb-4">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                            <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('confirmYes').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });
                document.getElementById('confirmNo').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(false);
                });
            });
        }

        async function logoutUser() {
            if (Object.keys(allGeneratedQuestions).length > 0) {
                 await saveSessionToFirestore();
            }
            
            appContent.style.display = 'none';
            startScreen.style.display = 'block';
            allGeneratedQuestions = {};
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            generateBtn.disabled = false;
            generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            questionsContainer.innerHTML = '';
            hideLoading();
            clearTimeout(inactivityTimer);
            updateViewResultsButtonState(false);
            console.log('User logged out and session saved.');
        }

        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        document.addEventListener('scroll', resetInactivityTimer);

        async function initializeAppContent() {
            console.log("Кнопка 'Начать' нажата! Инициализация приложения...");
            
            try {
                // Initialize Firebase services
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                // Sign in with the provided token or anonymously
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                console.log("Попытка входа в систему Firebase...");

                // Wait for the auth state to be confirmed
                await new Promise(resolve => onAuthStateChanged(auth, user => {
                    if (user) {
                        userId = user.uid;
                        userIdDisplay.textContent = userId;
                        isAuthReady = true;
                        console.log("Аутентификация успешна. ID пользователя:", userId);
                    }
                    resolve();
                }));

                console.log("Инициализация Firebase и вход в систему успешно завершены.");

                startScreen.style.display = 'none';
                appContent.style.display = 'block';
                
                const hasActive = await checkForActiveSession();
                
                // Check if an active session exists
                if (hasActive) {
                    const sessionResumed = await loadSessionFromFirestore();
                    if (sessionResumed) {
                        displayCurrentQuestion();
                        updateViewResultsButtonState(true); // Button is disabled because a session is in progress
                    } else {
                        // If the user declined to resume, the button should be active
                        questionsContainer.style.display = 'block';
                        resultsContainer.style.display = 'none';
                        questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите "Сгенерировать вопросы", чтобы начать новый тест.</p>';
                        nextBtn.style.display = 'none';
                        saveAndExitBtn.style.display = 'none';
                        updateViewResultsButtonState(false); // Explicitly enable the button
                    }
                } else {
                    // If no active session exists, the button should be active by default
                    questionsContainer.style.display = 'block';
                    resultsContainer.style.display = 'none';
                    questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите "Сгенерировать вопросы", чтобы начать новый тест.</p>';
                    nextBtn.style.display = 'none';
                    saveAndExitBtn.style.display = 'none';
                    updateViewResultsButtonState(false); // Explicitly enable the button
                }
                resetInactivityTimer();
            } catch (error) {
                console.error("Критическая ошибка при запуске приложения:", error);
                showModal("Критическая ошибка при запуске приложения. Проверьте консоль для получения подробной информации.");
            }
        }

        // Attach event listeners after the DOM is fully loaded to ensure elements exist
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM полностью загружен. Установка обработчиков событий.");
            startBtn.addEventListener('click', initializeAppContent);
            generateBtn.addEventListener('click', generateAllQuestions);
            nextBtn.addEventListener('click', handleNextQuestion);
            saveAndExitBtn.addEventListener('click', handleSaveAndExit);
            viewResultsBtn.addEventListener('click', loadCompletedTests);
        });

        function startCountdown() {
            let timeLeft = COUNTDOWN_DURATION;
            const countdownEl = document.getElementById('countdownTimer');
            countdownEl.textContent = `Приблизительное время: ${timeLeft} секунд`;

            countdownIntervalId = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    countdownEl.textContent = `Приблизительное время: ${timeLeft} секунд`;
                } else {
                    countdownEl.textContent = 'Генерация занимает больше времени, чем обычно...';
                    clearInterval(countdownIntervalId);
                }
            }, 1000);
        }

        function showLoading() {
            loadingIndicator.innerHTML = `
                <p>Генерация вопросов... это может занять несколько секунд.</p>
                <div class="mt-4">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-gray-900 mx-auto"></div>
                </div>
                <p id="countdownTimer" class="mt-4 text-sm text-gray-500"></p>
            `;
            loadingIndicator.style.display = 'block';
            generateBtn.disabled = true;
            viewResultsBtn.disabled = true;
            generateBtn.classList.add('opacity-50', 'cursor-not-allowed');
            updateViewResultsButtonState(true);
            questionsContainer.innerHTML = '';
            resultsContainer.style.display = 'none';
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            clearTimeout(inactivityTimer);
            startCountdown();
        }

        function hideLoading() {
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            generateBtn.disabled = false;
            generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            if (countdownIntervalId) {
                clearInterval(countdownIntervalId);
            }
        }

        async function generateQuestionsForCategory(categoryName, categoryKey, difficulty, retries = 0) {
            const MAX_RETRIES = 5;
            const BASE_DELAY_MS = 1000;

            let prompt = "";
            const numberOfQuestions = 4;
            const difficultyModifier = difficulty === 'hard' ? 'challenging' : 'straightforward';
            const wordCountRange = difficulty === 'hard' ? '60-80' : '40-60';
            const analyticalSkill = difficulty === 'hard' ? 'deep analytical skills' : 'basic comprehension';
            const grammaticalNuance = difficulty === 'hard' ? 'complex grammatical error' : 'common grammatical error';
            const rhetoricalEffect = difficulty === 'hard' ? 'advanced rhetorical effect' : 'clear and concise expression';

            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        passage: { type: "STRING" },
                        question: { type: "STRING" },
                        options: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    label: { type: "STRING" },
                                    text: { type: "STRING" }
                                },
                                required: ["label", "text"]
                            }
                        },
                        correct_answer: { type: "STRING" },
                        explanation: { type: "STRING" },
                        vocabulary: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    word: { "type": "STRING" },
                                    translation: { "type": "STRING" },
                                    explanation: { "type": "STRING" }
                                },
                                required: ["word", "translation", "explanation"]
                            }
                        },
                        highlighted_word: { type: "STRING" },
                        user_answer: { type: "STRING" }
                    },
                    required: ["passage", "question", "options", "correct_answer", "explanation"]
                }
            };

            const basePrompt = (passageType, questionType, highlightInstruction = '') => `
                Generate ${numberOfQuestions} highly unique and diverse SAT-style "${categoryName}" questions.
                For each question, provide:
                1. A short, ${difficultyModifier} academic-style passage (${wordCountRange} words) on a distinct topic (e.g., ${passageType}). Ensure maximal variation in topics, themes, and specific phrasing across all generated passages and questions. Avoid any direct repetition of concepts, exact wording, or similar narrative structures from previously generated content within the same batch.
                2. A SAT-style "${questionType}" question based on the passage that requires ${analyticalSkill} to answer.
                3. Four answer choices (A, B, C, D), one correct and three plausible distractors.
                4. The correct answer label (e.g., "A").
                5. A brief explanation (1-2 sentences) in Russian for the correct answer.
                6. Identify ${difficulty === 'hard' ? '6-7' : '4-5'} English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form (preserving its original casing from the passage), its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                ${highlightInstruction}
            `;

            switch (categoryKey) {
                case "information_ideas":
                    prompt = basePrompt('advanced science, philosophy, nuanced history, art criticism, economic theory', 'Information and Ideas (e.g., main idea, detail, or inference)');
                    break;
                case "craft_structure":
                    prompt = basePrompt('literary analysis, rhetorical strategy, stylistic choices, author\'s intent', 'Vocabulary in Context or Rhetorical Purpose', `
                    For "Craft and Structure" questions, one ${difficulty === 'hard' ? 'nuanced word or phrase with subtle meanings or a complex rhetorical device' : 'common word or phrase with a clear meaning in context'} in the passage should be highlighted by enclosing it in double asterisks (e.g., **word**). Also, provide the highlighted word in a new 'highlighted_word' field in the JSON response. Ensure variety in highlighted elements and passage themes.
                    `);
                    break;
                case "expression_ideas":
                    prompt = basePrompt('research methodology, policy analysis, argumentation, essay structure', 'Expression of Ideas (e.g., best revision, addition, or transition to improve ${rhetoricalEffect})');
                    break;
                case "standard_english_conventions":
                    prompt = basePrompt('scientific principles, historical analysis, grammar rules, syntax', 'Standard English Conventions (asking to correct a ${grammaticalNuance})', `
                    For "Standard English Conventions" questions, the part with the grammatical error in the passage should be highlighted by enclosing it in double asterisks. Ensure variety in grammatical errors and passage themes.
                    `);
                    break;
            }

            try {
                const result = await model.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    }
                });
                
                const questionsArray = JSON.parse(result.response.text());
                
                if (!Array.isArray(questionsArray)) {
                    throw new Error("API did not return a JSON array of questions.");
                }
                return questionsArray;
            } catch (error) {
                console.error(`Error generating questions for ${categoryName} (Difficulty: ${difficulty}):`, error);
                
                if (retries < MAX_RETRIES) {
                    const delay = BASE_DELAY_MS * Math.pow(2, retries) + (Math.random() * 100);
                    console.warn(`Retrying ${categoryName} question generation in ${delay}ms (retry ${retries + 1}/${MAX_RETRIES})...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return generateQuestionsForCategory(categoryName, categoryKey, difficulty, retries + 1);
                }

                let errorMessage = `<p class='text-red-600'>Произошла ошибка при генерации вопросов для категории "${categoryName}". Пожалуйста, попробуйте еще раз.</p>`;
                if (error.message.includes("403")) {
                    errorMessage = "<p class='text-red-600'>Ошибка: Проблема с доступом к Gemini API (ошибка 403). Пожалуйста, убедитесь, что ваш API-ключ действителен.</p>";
                } else if (error.message.includes("JSON")) {
                    errorMessage = `<p class='text-red-600'>Ошибка парсинга JSON для категории "${categoryName}".</p>`;
                }
                loadingIndicator.innerHTML = errorMessage;
                hideLoading();
                return null;
            }
        }
        
        async function generateAllQuestions() {
            showLoading();
            
            if (isAuthReady) {
                await setDoc(doc(db, `artifacts/${appId}/public/data/sat_sessions`, userId), {});
            }
            updateViewResultsButtonState(true);

            allGeneratedQuestions = {};
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            categoriesArray = Object.keys(categories);

            let allSuccessful = true;
            for (const categoryTitle of categoriesArray) {
                const categoryKey = categories[categoryTitle];
                const selectedDifficulty = difficultySelect.value;
                const questionsForCategory = await generateQuestionsForCategory(categoryTitle, categoryKey, selectedDifficulty);
                
                if (questionsForCategory && questionsForCategory.length > 0) {
                    allGeneratedQuestions[categoryKey] = questionsForCategory;
                } else {
                    allSuccessful = false;
                    const errorCard = document.createElement('div');
                    errorCard.className = 'question-card bg-red-100 text-red-800';
                    errorCard.textContent = `Не удалось сгенерировать вопросы для категории "${categoryTitle}".`;
                    questionsContainer.appendChild(errorCard);
                }
            }
            hideLoading();
            questionsContainer.style.display = 'block';
            resultsContainer.style.display = 'none';

            if (allSuccessful && categoriesArray.length > 0 && allGeneratedQuestions[categories[categoriesArray[0]]]) {
                displayCurrentQuestion();
                resetInactivityTimer();
            } else {
                nextBtn.style.display = 'none';
                saveAndExitBtn.style.display = 'none';
            }
        }

        async function handleNextQuestion() {
            const currentCategoryKey = categories[categoriesArray[currentCategoryIndex]];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];

            currentQuestionIndex++;
            if (currentQuestionIndex >= questionsInCurrentCategory.length) {
                currentQuestionIndex = 0;
                currentCategoryIndex++;
            }

            if (currentCategoryIndex >= categoriesArray.length) {
                questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Тест завершен! Нажмите "Сгенерировать вопросы", чтобы начать заново.</p>';
                nextBtn.style.display = 'none';
                saveAndExitBtn.style.display = 'none';
                generateBtn.disabled = false;
                generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                clearTimeout(inactivityTimer);
                await saveCompletedTestToFirestore();
                updateViewResultsButtonState(false);
            } else {
                displayCurrentQuestion();
                resetInactivityTimer();
            }
        }

        async function handleSaveAndExit() {
            await logoutUser();
        }
    </script>
</body>
</html>
