<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор вопросов SAT</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%; /* Ensure container takes full width on smaller screens */
        }
        .section-title {
            border-bottom: 2px solid #cbd5e1; /* Light gray border */
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .question-card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0; /* Light border */
        }
        .question-passage {
            font-style: italic;
            color: #4a5568; /* Dark gray text */
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .question-text {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2d3748; /* Darker gray text */
        }
        .option-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            border-radius: 0.5rem;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 1px solid transparent; /* Default transparent border */
        }
        .option-item:hover:not(.disabled) {
            background-color: #f3f4f6; /* Light gray on hover */
        }
        .option-item.correct {
            background-color: #d1fae5; /* Light green for correct answer */
            border-color: #34d399; /* Green border */
            font-weight: 500;
        }
        .option-item.incorrect {
            background-color: #fee2e2; /* Light red for incorrect answer */
            border-color: #ef4444; /* Red border */
            font-weight: 500;
        }
        .option-item.disabled {
            pointer-events: none; /* Disable clicks */
            opacity: 0.8; /* Slightly dim disabled options */
        }
        .explanation {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #e2e8f0;
            font-size: 0.9rem;
            color: #4a5568;
            display: none; /* Hidden by default */
        }
        .login-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .login-button {
            width: 100%;
            background-color: #4299e1; /* Blue */
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #3182ce; /* Darker blue */
        }
        .error-message {
            color: #ef4444;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #94a3b8; /* Dotted underline for tooltip words */
        }
        .tooltip-text {
            visibility: hidden;
            width: auto; /* Adjust width based on content */
            max-width: 500px; /* Changed: Increased max-width for more words */
            background-color: #333;
            color: #fff;
            text-align: left; /* Changed: Align text to left for multi-line */
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 100; /* Ensure tooltip is on top */
            bottom: 125%; /* Position above the text */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Changed: Allow text wrapping */
            word-wrap: break-word; /* Added: Ensure long words break */
            font-size: 0.85rem;
            pointer-events: none; /* Allow clicks to pass through tooltip when not hovered */
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        /* New styles for completed tests screen */
        .completed-tests-screen {
            background-color: #f0f4f8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }
        .completed-test-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .completed-test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .completed-test-card-details {
            border-left: 4px solid #3b82f6; /* Blue border for details */
            padding-left: 1rem;
            margin-top: 1rem;
        }
        .completed-test-details-question-card {
            background-color: #f8fafc;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
        }
        .user-answer {
            font-weight: 500;
        }
        /* Style for SVG container to ensure responsiveness */
        .svg-container {
            width: 100%;
            height: auto;
            max-width: 600px; /* New: Limit max width on large screens */
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            margin-left: auto; /* New: Center the container */
            margin-right: auto; /* New: Center the container */
        }
        /* New: Style for text inside the SVG */
        .svg-container svg text {
            font-family: 'Inter', sans-serif;
            font-size: 12px; /* Set a default font size */
        }
    </style>
</head>
<body>
    <div id="loginScreen" class="login-container">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">Welcome to Jaleel's Verbal SAT Question Generator</h2>
        <input type="password" id="passwordInput" class="login-input" placeholder="Введите пароль">
        <button id="loginBtn" class="login-button">Войти</button>
        <p id="loginError" class="error-message" style="display: none;">Неверный пароль. Попробуйте снова.</p>
    </div>

    <div id="appContent" class="container" style="display: none;">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Генератор вопросов SAT (Verbal Section)</h1>

        <div class="mb-6">
            <label for="difficultySelect" class="block text-gray-700 text-sm font-bold mb-2">Выберите уровень сложности:</label>
            <select id="difficultySelect" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500">
                <option value="easy" selected>Облегченный уровень (Easier Module)</option>
                <option value="hard">Усложненный уровень (Harder Module 2)</option>
            </select>
        </div>

        <div id="categoryButtonsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <!-- Buttons for each category will be inserted here by JavaScript -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mb-4">
            <button id="showCompletedTestsBtn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75" disabled>
                Завершенные тесты
            </button>
        </div>
        
        <div id="loadingIndicator" class="loading-indicator text-center" style="display: none;">
            <!-- Questions will be loaded here -->
        </div>

        <div id="questionsContainer" class="space-y-10">
            <!-- Questions will be loaded here -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mt-4">
            <button id="nextBtn" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                Следующий вопрос
            </button>
            <button id="saveAndExitBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" style="display: none;">
                Сохранить и выйти
            </button>
        </div>
    </div>

    <div id="completedTestsScreen" class="completed-tests-screen" style="display: none;">
        <button id="backToMainBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
            &larr; Назад в главное окно
        </button>
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Завершенные тесты</h1>
        <div id="testsListContainer" class="space-y-4">
            <!-- Completed tests will be listed here -->
        </div>
        <div id="completedTestDetailsContainer" class="mt-8" style="display: none;">
            <button id="backToTestsBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
                &larr; Назад к списку тестов
            </button>
            <!-- New delete button added here -->
            <button id="deleteTestBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mb-4 ml-4 transition duration-200 ease-in-out">
                Удалить тест
            </button>
            <div id="testReviewContainer">
                <!-- Detailed test review will be displayed here -->
            </div>
        </div>
    </div>

    <script type="module">
        // Import the Google Generative AI library
        import { GoogleGenerativeAI } from 'https://esm.sh/@google/generative-ai';

        // Initialize Firebase (required for Canvas environment, even if not directly used for auth in this example)
        // This ensures __app_id and __firebase_config are handled correctly.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        const apiKey = "";
        
        // Initialize Google Generative AI
        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-preview-05-20" });

        const loginScreen = document.getElementById('loginScreen');
        const passwordInput = document.getElementById('passwordInput');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const appContent = document.getElementById('appContent');
        const categoryButtonsContainer = document.getElementById('categoryButtonsContainer');

        const questionsContainer = document.getElementById('questionsContainer');
        const showCompletedTestsBtn = document.getElementById('showCompletedTestsBtn');
        const completedTestsScreen = document.getElementById('completedTestsScreen');
        const testsListContainer = document.getElementById('testsListContainer');
        const completedTestDetailsContainer = document.getElementById('completedTestDetailsContainer');
        const testReviewContainer = document.getElementById('testReviewContainer');
        const backToTestsBtn = document.getElementById('backToTestsBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const difficultySelect = document.getElementById('difficultySelect');
        const nextBtn = document.getElementById('nextBtn');
        const saveAndExitBtn = document.getElementById('saveAndExitBtn');
        const deleteTestBtn = document.getElementById('deleteTestBtn');

        const categories = {
            "Information and Ideas": "information_ideas",
            "Craft and Structure": "craft_structure",
            "Expression of Ideas": "expression_ideas",
            "Standard English Conventions": "standard_english_conventions"
        };
        const romanNumerals = ['I', 'II', 'III', 'IV'];

        // Global state to manage questions and current position
        let allGeneratedQuestions = {};
        let completedQuestions = [];
        let categoriesArray = [];
        let currentCategoryIndex = 0;
        let currentQuestionIndex = 0;
        let isSessionActive = false;
        let currentReviewingTest = null;

        // Hardcoded password for client-side authentication
        const CORRECT_PASSWORD = "Jaleel2010";

        // Inactivity timer variables
        let inactivityTimer;
        const INACTIVITY_TIMEOUT = 5 * 60 * 1000;
        
        // Countdown timer variables
        let countdownInterval;
        const COUNTDOWN_SECONDS = 90;

        // Function to reset the inactivity timer
        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(logoutUser, INACTIVITY_TIMEOUT);
        }

        // Function to save the current session state
        function saveSession() {
            if (Object.keys(allGeneratedQuestions).length > 0) {
                const sessionData = {
                    categoryIndex: currentCategoryIndex,
                    questionIndex: currentQuestionIndex,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value,
                    completedQuestions: completedQuestions,
                    categoriesArray: categoriesArray // Save the active categories
                };
                localStorage.setItem('satQuizSession', JSON.stringify(sessionData));
                console.log('Session saved.');
            }
        }

        // Function to load a saved session state
        function loadSession() {
            const savedSession = localStorage.getItem('satQuizSession');
            if (savedSession) {
                const confirmation = showCustomConfirm('Обнаружена незавершенная сессия. Хотите продолжить с того места, где остановились?');
                
                return new Promise(resolve => {
                    confirmation.then(resume => {
                        if (resume) {
                            const sessionData = JSON.parse(savedSession);
                            currentCategoryIndex = sessionData.categoryIndex;
                            currentQuestionIndex = sessionData.questionIndex;
                            allGeneratedQuestions = sessionData.questions;
                            difficultySelect.value = sessionData.difficulty;
                            completedQuestions = sessionData.completedQuestions || [];
                            categoriesArray = sessionData.categoriesArray || Object.keys(categories);
                            isSessionActive = true;
                            console.log('Session loaded. Resuming test.');
                            resolve(true);
                        } else {
                            localStorage.removeItem('satQuizSession');
                            isSessionActive = false;
                            console.log('Saved session discarded.');
                            resolve(false);
                        }
                    });
                });
            }
            return Promise.resolve(false);
        }

        // Custom confirmation dialog (replaces alert/confirm)
        function showCustomConfirm(message) {
            return new Promise(resolve => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modalOverlay.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <p class="text-lg font-semibold mb-4">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                            <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('confirmYes').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });
                document.getElementById('confirmNo').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(false);
                });
            });
        }

        // Function to update the disabled state of the "Completed Tests" button
        function updateCompletedTestsBtnState() {
            if (isSessionActive) {
                showCompletedTestsBtn.disabled = true;
                showCompletedTestsBtn.classList.add('opacity-50', 'cursor-not-allowed');
                showCompletedTestsBtn.classList.remove('hover:bg-gray-600', 'hover:scale-105');
            } else {
                showCompletedTestsBtn.disabled = false;
                showCompletedTestsBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                showCompletedTestsBtn.classList.add('hover:bg-gray-600', 'hover:scale-105');
            }
        }

        // Function to log out the user and reset the app state
        function logoutUser(saveCurrent = true) {
            if (saveCurrent) {
                saveSession();
            } else {
                localStorage.removeItem('satQuizSession');
            }
            
            isSessionActive = false;
            updateCompletedTestsBtnState();

            // Hide app content and show login screen
            appContent.style.display = 'none';
            loginScreen.style.display = 'block';
            passwordInput.value = '';
            loginError.style.display = 'none';

            // Reset application state
            allGeneratedQuestions = {};
            completedQuestions = [];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            currentReviewingTest = null;
            categoriesArray = [];

            // Hide all buttons that appear after login/generation
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            questionsContainer.innerHTML = '';
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';

            // Stop any existing inactivity timer and countdown timer
            clearTimeout(inactivityTimer);
            clearInterval(countdownInterval);

            // Re-enable all category buttons
            document.querySelectorAll('#categoryButtonsContainer button').forEach(button => {
                button.disabled = false;
                button.classList.remove('opacity-50', 'cursor-not-allowed');
                button.classList.add('hover:bg-blue-700', 'hover:scale-105');
            });
        }

        // Event listeners for user activity to reset the timer
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        document.addEventListener('scroll', resetInactivityTimer);

        // Initial check for activity when the page loads
        resetInactivityTimer();

        // Function to generate the category buttons
        function createCategoryButtons() {
            categoryButtonsContainer.innerHTML = '';
            Object.keys(categories).forEach(categoryTitle => {
                const categoryKey = categories[categoryTitle];
                const button = document.createElement('button');
                button.id = `generateBtn-${categoryKey}`;
                button.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75';
                button.textContent = categoryTitle;
                button.addEventListener('click', () => handleNewTest(categoryKey));
                categoryButtonsContainer.appendChild(button);
            });
        }

        // Login function
        loginBtn.addEventListener('click', async () => {
            if (passwordInput.value === CORRECT_PASSWORD) {
                loginScreen.style.display = 'none';
                appContent.style.display = 'block';
                loginError.style.display = 'none';
                
                createCategoryButtons();
                const sessionResumed = await loadSession();
                if (sessionResumed) {
                    displayCurrentQuestion();
                    nextBtn.style.display = 'block';
                    saveAndExitBtn.style.display = 'block';
                    nextBtn.disabled = true;
                    nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите на кнопку категории, чтобы начать новый тест.</p>';
                }
                updateCompletedTestsBtnState();
                resetInactivityTimer();
            } else {
                loginError.style.display = 'block';
            }
        });

        // Allow pressing Enter key to login
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loginBtn.click();
            }
        });
        
        // Function to start the countdown timer
        function startCountdown() {
            let timeLeft = COUNTDOWN_SECONDS;
            const timerElement = document.getElementById('timer');
            timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;

            countdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;
                } else {
                    clearInterval(countdownInterval);
                    timerElement.textContent = 'Время вышло, генерация продолжается...';
                }
            }, 1000);
        }

        // Function to show loading indicator
        function showLoading(categoryTitle) {
            questionsContainer.innerHTML = '';
            loadingIndicator.innerHTML = `
                <p class="text-xl font-semibold mb-4 text-gray-700">Генерация вопросов для "${categoryTitle}"... это может занять несколько секунд.</p>
                <div id="timer" class="text-md font-medium text-gray-500 mb-4"></div>
                <div class="mt-4">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-gray-900 mx-auto"></div>
                </div>
            `;
            loadingIndicator.style.display = 'block';
            
            document.querySelectorAll('#categoryButtonsContainer button').forEach(button => {
                button.disabled = true;
                button.classList.add('opacity-50', 'cursor-not-allowed');
                button.classList.remove('hover:bg-blue-700', 'hover:scale-105');
            });

            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            
            clearInterval(countdownInterval);
            startCountdown();
        }

        // Function to hide loading indicator
        function hideLoading() {
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            clearInterval(countdownInterval);
        }

        // Function to generate multiple questions for a given category with exponential backoff
        async function generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, retries = 0) {
            const MAX_RETRIES = 5;
            const BASE_DELAY_MS = 1000;
            
            const numberOfQuestions = 7; 

            let prompt = "";
            
            const difficultyModifier = difficulty === 'hard' ? 'challenging' : 'straightforward';
            const wordCountRange = difficulty === 'hard' ? '60-80' : '40-60';
            const analyticalSkill = difficulty === 'hard' ? 'deep analytical skills' : 'basic comprehension';
            const grammaticalNuance = difficulty === 'hard' ? 'complex grammatical error' : 'common grammatical error';
            const rhetoricalEffect = difficulty === 'hard' ? 'advanced rhetorical effect' : 'clear and concise expression';

            // Define the JSON schema for the expected output
            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        passage: { type: "STRING" },
                        question: { type: "STRING" },
                        options: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    label: { type: "STRING" },
                                    text: { type: "STRING" }
                                },
                                required: ["label", "text"]
                            }
                        },
                        correct_answer: { type: "STRING" },
                        explanation: { type: "STRING" },
                        vocabulary: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    word: { "type": "STRING" },
                                    translation: { "type": "STRING" },
                                    explanation: { "type": "STRING" }
                                },
                                required: ["word", "translation", "explanation"]
                            }
                        },
                        category: { type: "STRING" },
                        graphic: { type: "STRING" } // NEW: Add a field for the SVG graphic
                    },
                    required: ["passage", "question", "options", "correct_answer", "explanation", "category"]
                }
            };
            
            const basePrompt = (passageType, questionType, highlightInstruction = '') => `
                Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions.
                For each question, provide:
                1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, drawing from various styles and sources, such as: ${passageType}. The passages should be fresh and not repeat previous topics.
                2. A SAT-style "${questionType}" question based on the passage that requires ${analyticalSkill} to answer.
                3. Four answer choices (A, B, C, D), one correct and three plausible distractors.
                4. The correct answer label (e.g., "A").
                5. A brief explanation in Russian for the correct answer.
                6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                7. Include the category name "${categoryTitle}" in a 'category' field.
                ${highlightInstruction}
            `;

            switch (categoryKey) {
                case "information_ideas":
                    prompt = `
                        Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions, covering a wide range of analytical skills.
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. Passages should be fresh and not repeat previous topics.
                        2. A specific SAT-style question based on the passage, designed to test a particular skill.
                        3. Four answer choices (A, B, C, D), one correct and three plausible distractors.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.
                        
                        The 7 questions should be of the following types, in this order:
                        - Question 1 (Direct Question): Based on a historical document excerpt.
                        - Question 2 (Inference Question): Based on an excerpt from a literary text.
                        - Question 3 (Main Idea Question): Based on an excerpt from a scientific journal.
                        - Question 4 (Figure based Question): Based on a bar chart, line graph, or pie chart. The passage field should provide context for the data, and a new "graphic" field must contain a **complete and self-contained SVG string** for the chart. **Ensure the SVG is compact, and all text labels (titles, axes, data labels) are legible, do not overlap, are contained within the SVG's viewBox, and use the 'Inter, sans-serif' font family with a font-size of 12px to match the application's styling.** The SVG must be responsive, and all graphic components (bars, lines, slices) must use a color palette that excludes pure white and black.
                        - Question 5 (Strengthen Weaken Question): Based on a short argumentative essay.
                        - Question 6 (Poem based Question): Based on a short poem.
                        - Question 7 (Character Descriptions): Based on an an excerpt from a novel or a short story.
                    `;
                    break;
                case "craft_structure":
                    // NEW PROMPT: Generate 7 questions of the specified types
                    prompt = `
                        Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions.
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. For Cross-text Connection questions, provide two distinct, short passages. The passages should be fresh and not repeat previous topics.
                        2. A specific SAT-style question based on the passage(s).
                        3. Four answer choices (A, B, C, D), one correct and three plausible distractors.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.

                        The 7 questions should be of the following types, ensuring a good mix across the list:
                        - Vocabulary in Context
                        - Primary Purpose Questions
                        - Purpose of a portion Questions
                        - Structure Questions
                        - Cross-text Connection Questions (must include two passages)
                        - Quotes Illustrate Questions
                        - A seventh question which is a duplicate of one of the above types.
                        
                        For "Vocabulary in Context" and "Purpose of a portion" questions, highlight the specific word, phrase, or sentence in the passage by enclosing it in double asterisks (e.g., **word**).
                    `;
                    break;
                case "expression_ideas":
                    // UPDATED PROMPT: Specific question types and distribution as requested by the user
                    prompt = `
                        Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions. The questions must be split between Transition and Goal-based questions.
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, such as a student's essay draft or a research proposal. The passages should be fresh and not repeat previous topics.
                        2. A specific SAT-style question based on the passage. The questions must consist of:
                           - **3-4 Transition Questions**: Asks for the most logical transition to connect a paragraph to a previous one or to a specific sentence within the paragraph.
                           - **3-4 Goal-based Questions**: Asks which revision of a sentence best achieves a specified goal, such as making a point more precise or establishing a clearer tone.
                        3. Four answer choices (A, B, C, D), one correct and three plausible distractors.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.
                        
                        For "Transition Questions" and "Goal-based Questions", highlight the relevant part of the passage that needs revision by enclosing it in double asterisks (e.g., **The phrase to be revised**).
                    `;
                    break;
                case "standard_english_conventions":
                    prompt = basePrompt(
                        'a paragraph from a historical account, a technical manual, or a biographical sketch that contains a specific grammatical error (e.g., subject-verb agreement, pronoun use, punctuation)', 
                        'Standard English Conventions (asking to correct a ${grammaticalNuance})'
                    );
                    prompt += `\nFor these questions, the part of the passage with the grammatical error should be highlighted by enclosing it in double asterisks (e.g., **phrase with error**).`;
                    break;
            }

            try {
                const result = await model.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    }
                });
                
                const questionsArray = JSON.parse(result.response.text());
                
                if (!Array.isArray(questionsArray)) {
                    throw new Error("API did not return a JSON array of questions.");
                }
                return questionsArray;
            } catch (error) {
                console.error(`Error generating questions for ${categoryTitle} (Difficulty: ${difficulty}):`, error);
                
                if (retries < MAX_RETRIES) {
                    const delay = BASE_DELAY_MS * Math.pow(2, retries) + (Math.random() * 100);
                    console.warn(`Retrying ${categoryTitle} question generation in ${delay}ms (retry ${retries + 1}/${MAX_RETRIES})...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, retries + 1);
                }

                let errorMessage = `<p class='text-red-600'>Произошла ошибка при генерации вопросов для категории "${categoryTitle}" (Уровень: ${difficulty === 'hard' ? 'Усложненный' : 'Облегченный'}). Пожалуйста, попробуйте еще раз.</p>`;

                if (error.message) {
                    if (error.message.includes("403") && error.message.includes("unregistered callers")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: Проблема с доступом к Gemini API (ошибка 403). Пожалуйста, убедитесь, что ваш API-ключ действителен и имеет необходимые разрешения для модели 'gemini-2.5-flash-preview-05-20' в Google Cloud Console.</p>";
                    } else if (error.message.includes("API key not valid")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: API ключ Gemini недействителен. Пожалуйста, убедитесь, что он правильно настроен в вашей среде.</p>";
                    } else if (error.message.includes("JSON")) {
                         errorMessage = `<p class='text-red-600'>Ошибка парсинга JSON для категории "${categoryTitle}". Модель вернула некорректный формат. Пожалуйста, попробуйте еще раз.</p>`;
                    }
                }
                loadingIndicator.innerHTML = errorMessage;
                hideLoading();
                return null;
            }
        }

        // Function to display a single question
        function displayQuestion(questionData, categoryTitle, isReview = false) {
            if (!questionData) return;

            const questionCard = document.createElement('div');
            questionCard.className = isReview ? 'completed-test-details-question-card' : 'question-card';

            // NEW: Check for graphic data and add a container for it
            if (questionData.graphic) {
                const graphicContainer = document.createElement('div');
                graphicContainer.className = 'svg-container';
                graphicContainer.innerHTML = questionData.graphic;
                questionCard.appendChild(graphicContainer);
            }

            let passageContent = questionData.passage;

            // First, add tooltips for vocabulary words
            if (questionData.vocabulary && Array.isArray(questionData.vocabulary)) {
                questionData.vocabulary.forEach(vocabItem => {
                    const escapedWord = vocabItem.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi'); 
                    passageContent = passageContent.replace(regex, (matchedWord) => {
                        const formattedWordInTooltip = `<strong>${matchedWord.charAt(0).toUpperCase() + matchedWord.slice(1)}</strong>`;
                        return `<span class="tooltip-container">${matchedWord}<span class="tooltip-text">${formattedWordInTooltip}: ${vocabItem.translation}: ${vocabItem.explanation}</span></span>`;
                    });
                });
            }

            // Then, apply highlighting for Expression of Ideas, Craft and Structure, and Standard English Conventions
            if (categoryTitle === "Expression of Ideas" || categoryTitle === "Craft and Structure" || categoryTitle === "Standard English Conventions") {
                passageContent = passageContent.replace(/\*\*(.*?)\*\*/g, `<span class="font-bold underline">$1</span>`);
            }
            
            const passageDiv = document.createElement('div');
            passageDiv.className = 'question-passage';
            passageDiv.innerHTML = passageContent;

            const questionTextDiv = document.createElement('div');
            questionTextDiv.className = 'question-text';
            questionTextDiv.textContent = questionData.question;

            const optionsList = document.createElement('div');
            optionsList.className = 'options-list';

            let optionsToDisplay = questionData.options;
            if (typeof optionsToDisplay === 'string') {
                try {
                    optionsToDisplay = JSON.parse(optionsToDisplay);
                } catch (e) {
                    console.warn("Could not parse options string:", optionsToDisplay, e);
                    optionsToDisplay = [];
                }
            }
            if (!Array.isArray(optionsToDisplay)) {
                console.warn("questionData.options is not an array after processing:", optionsToDisplay);
                optionsToDisplay = [];
            }

            const explanationDiv = document.createElement('div');
            explanationDiv.className = 'explanation';
            explanationDiv.textContent = `Объяснение: ${questionData.explanation}`;
            
            if (isReview) {
                explanationDiv.style.display = 'block';
            } else {
                explanationDiv.style.display = 'none';
            }

            optionsToDisplay.forEach(option => {
                const optionItem = document.createElement('div');
                optionItem.className = `option-item px-4 py-2 cursor-pointer rounded-md transition duration-200 ease-in-out hover:bg-gray-100`;
                optionItem.textContent = `${option.label}. ${option.text}`;
                optionItem.dataset.label = option.label;
                optionItem.dataset.correctAnswer = questionData.correct_answer;

                if (isReview) {
                    optionItem.classList.add('disabled');
                    optionItem.style.pointerEvents = 'none';

                    const userLabel = questionData.user_answer;
                    const correctLabel = questionData.correct_answer;

                    if (option.label === correctLabel) {
                        optionItem.classList.add('correct');
                    }
                    if (option.label === userLabel && userLabel !== correctLabel) {
                        optionItem.classList.add('incorrect');
                    }
                } else {
                    optionItem.addEventListener('click', function() {
                        optionsList.querySelectorAll('.option-item').forEach(opt => {
                            opt.classList.add('disabled');
                            opt.style.pointerEvents = 'none';
                        });

                        const selectedLabel = this.dataset.label;
                        const correctAnswerLabel = this.dataset.correctAnswer;

                        const questionWithAnswer = {
                            ...questionData,
                            user_answer: selectedLabel
                        };
                        completedQuestions.push(questionWithAnswer);
                        
                        optionsList.querySelectorAll('.option-item').forEach(opt => {
                            if (opt.dataset.label === correctAnswerLabel) {
                                opt.classList.add('correct');
                            } else if (opt.dataset.label === selectedLabel) {
                                opt.classList.add('incorrect');
                            }
                        });

                        explanationDiv.style.display = 'block';

                        nextBtn.disabled = false;
                        nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        resetInactivityTimer();
                    });
                }
                optionsList.appendChild(optionItem);
            });

            if (passageDiv.innerHTML.trim() !== '') { // Only append if there's actual passage content
                questionCard.appendChild(passageDiv);
            }
            questionCard.appendChild(questionTextDiv);
            questionCard.appendChild(optionsList);
            questionCard.appendChild(explanationDiv);

            return questionCard;
        }

        // Function to display the current question based on global indices
        function displayCurrentQuestion() {
            const currentCategoryTitle = categoriesArray[currentCategoryIndex];
            const currentCategoryKey = categories[currentCategoryTitle];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];

            if (questionsInCurrentCategory && questionsInCurrentCategory.length > currentQuestionIndex) {
                questionsContainer.innerHTML = '';
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'category-section mb-10';

                const sectionTitle = document.createElement('h2');
                sectionTitle.className = 'text-2xl font-semibold text-gray-700 mb-6 section-title';
                const romanNumeral = romanNumerals[currentCategoryIndex] || '';
                sectionTitle.textContent = `${romanNumeral}. ${currentCategoryTitle} (Вопрос ${currentQuestionIndex + 1} из ${questionsInCurrentCategory.length})`;
                sectionDiv.appendChild(sectionTitle);

                const questionData = questionsInCurrentCategory[currentQuestionIndex];
                const questionCard = displayQuestion(questionData, currentCategoryTitle);
                if (questionCard) {
                    sectionDiv.appendChild(questionCard);
                }
                questionsContainer.appendChild(sectionDiv);

                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                nextBtn.style.display = 'block';
                saveAndExitBtn.style.display = 'block';

                const isLastQuestion = (currentCategoryIndex === categoriesArray.length - 1 && currentQuestionIndex === questionsInCurrentCategory.length - 1);
                if (isLastQuestion) {
                    nextBtn.textContent = 'Завершить тест';
                    saveAndExitBtn.style.display = 'none';
                } else {
                    nextBtn.textContent = 'Следующий вопрос';
                    saveAndExitBtn.style.display = 'block';
                }
            } else {
                endQuiz(); 
            }
        }

        // Main function to generate questions and start the quiz for a specific category
        async function handleNewTest(categoryKey) {
            if (isSessionActive) {
                const wantsToContinue = await showCustomConfirm('В настоящий момент у вас активен тест. Хотите начать новый тест и отменить текущий?');
                if (!wantsToContinue) {
                    return;
                }
            }
            
            const categoryTitle = Object.keys(categories).find(key => categories[key] === categoryKey);
            showLoading(categoryTitle);
            
            localStorage.removeItem('satQuizSession'); 
            completedQuestions = [];

            isSessionActive = true;
            updateCompletedTestsBtnState();

            allGeneratedQuestions = {};
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            categoriesArray = [categoryTitle]; // Set the active category

            const selectedDifficulty = difficultySelect.value;
            const questionsForCategory = await generateQuestionsForCategory(categoryTitle, categoryKey, selectedDifficulty);

            hideLoading();

            if (questionsForCategory && questionsForCategory.length > 0) {
                allGeneratedQuestions[categoryKey] = questionsForCategory;
                nextBtn.style.display = 'block';
                saveAndExitBtn.style.display = 'block';
                displayCurrentQuestion();
                resetInactivityTimer();
            } else {
                nextBtn.style.display = 'none';
                saveAndExitBtn.style.display = 'none';
                questionsContainer.innerHTML = `<p class="text-center text-red-600 text-lg">Не удалось сгенерировать вопросы для категории "${categoryTitle}". Пожалуйста, попробуйте еще раз.</p>`;
            }
        }

        // Function to handle navigation to the next question
        function handleNextQuestion() {
            const currentCategoryKey = categories[categoriesArray[currentCategoryIndex]];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];

            currentQuestionIndex++;
            if (currentQuestionIndex >= questionsInCurrentCategory.length) {
                currentQuestionIndex = 0;
                currentCategoryIndex++;
            }

            if (currentCategoryIndex >= categoriesArray.length) {
                endQuiz();
            } else {
                displayCurrentQuestion();
                resetInactivityTimer();
            }
        }
        
        // Function to handle quiz completion
        function endQuiz() {
            const completedTests = JSON.parse(localStorage.getItem('satCompletedTests') || '[]');
            const newCompletedTest = {
                timestamp: new Date().toISOString(),
                difficulty: difficultySelect.value,
                questions: completedQuestions
            };
            completedTests.push(newCompletedTest);
            localStorage.setItem('satCompletedTests', JSON.stringify(completedTests));
            console.log('Completed test saved locally.');
            
            isSessionActive = false;
            updateCompletedTestsBtnState();
            localStorage.removeItem('satQuizSession');
            completedQuestions = [];
            allGeneratedQuestions = {};
            categoriesArray = [];

            questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Тест завершен. Нажмите на кнопку категории, чтобы начать новый тест.</p>';
            
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            nextBtn.textContent = 'Следующий вопрос'; 
            clearTimeout(inactivityTimer); 
            
            document.querySelectorAll('#categoryButtonsContainer button').forEach(button => {
                button.disabled = false;
                button.classList.remove('opacity-50', 'cursor-not-allowed');
                button.classList.add('hover:bg-blue-700', 'hover:scale-105');
            });
        }

        // Function to handle saving and exiting the test
        function handleSaveAndExit() {
            logoutUser();
            questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Тест сохранен. Вы можете сгенерировать новые вопросы.</p>';
        }

        // --- New functions for Completed Tests feature ---
        function showCompletedTests() {
            appContent.style.display = 'none';
            completedTestsScreen.style.display = 'block';
            testsListContainer.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            
            const completedTests = JSON.parse(localStorage.getItem('satCompletedTests') || '[]');
            testsListContainer.innerHTML = '';

            if (completedTests.length === 0) {
                testsListContainer.innerHTML = '<p class="text-center text-gray-600">У вас пока нет завершенных тестов.</p>';
                return;
            }

            completedTests.reverse().forEach((test, index) => {
                const categoryTitle = test.questions[0].category || 'Неизвестная категория';
                const testCard = document.createElement('div');
                testCard.className = 'completed-test-card';
                testCard.innerHTML = `
                    <p class="text-lg font-semibold text-gray-800">Тест (${categoryTitle}) от ${new Date(test.timestamp).toLocaleString('ru-RU')}</p>
                    <p class="text-sm text-gray-600">Сложность: ${test.difficulty === 'hard' ? 'Усложненный' : 'Облегченный'}</p>
                `;
                testCard.addEventListener('click', () => displayCompletedTestDetails(test));
                testsListContainer.appendChild(testCard);
            });
        }

        function displayCompletedTestDetails(testData) {
            currentReviewingTest = testData;

            testsListContainer.style.display = 'none';
            completedTestDetailsContainer.style.display = 'block';
            testReviewContainer.innerHTML = '';

            const reviewTitle = document.createElement('h2');
            reviewTitle.className = 'text-3xl font-bold text-gray-800 mb-6';
            reviewTitle.textContent = `Обзор теста от ${new Date(testData.timestamp).toLocaleString('ru-RU')}`;
            testReviewContainer.appendChild(reviewTitle);

            const allQuestions = testData.questions;
            const categoriesMap = {};
            allQuestions.forEach(q => {
                const category = q.category || 'Information and Ideas';
                if (!categoriesMap[category]) {
                    categoriesMap[category] = [];
                }
                categoriesMap[category].push(q);
            });

            let questionCounter = 0;
            Object.keys(categoriesMap).forEach((categoryTitle, categoryIndex) => {
                const sectionTitle = document.createElement('h3');
                sectionTitle.className = 'text-2xl font-semibold text-gray-700 mt-8 mb-4';
                const romanNumeral = romanNumerals[categoryIndex] || '';
                sectionTitle.textContent = `${romanNumeral}. ${categoryTitle}`;
                testReviewContainer.appendChild(sectionTitle);

                categoriesMap[categoryTitle].forEach(question => {
                    questionCounter++;
                    const questionCard = displayQuestion(question, categoryTitle, true);
                    const questionNumberText = document.createElement('p');
                    questionNumberText.className = 'font-semibold text-lg text-gray-800 mb-2';
                    questionNumberText.textContent = `Вопрос ${questionCounter}.`;
                    
                    const userAndCorrectAnswerDiv = document.createElement('div');
                    userAndCorrectAnswerDiv.className = 'completed-test-card-details';
                    
                    const userAnswerText = document.createElement('p');
                    const isCorrect = question.user_answer === question.correct_answer;
                    userAnswerText.className = `user-answer ${isCorrect ? 'text-green-600' : 'text-red-600'}`;
                    userAnswerText.innerHTML = `Ваш ответ: <span class="font-bold">${question.user_answer}</span> ${isCorrect ? '(Правильно)' : '(Неправильно)'}`;

                    const correctAnswerText = document.createElement('p');
                    correctAnswerText.className = 'font-medium text-green-600';
                    correctAnswerText.textContent = `Правильный ответ: ${question.correct_answer}`;

                    userAndCorrectAnswerDiv.appendChild(userAnswerText);
                    userAndCorrectAnswerDiv.appendChild(correctAnswerText);

                    testReviewContainer.appendChild(questionNumberText);
                    testReviewContainer.appendChild(questionCard);
                    testReviewContainer.appendChild(userAndCorrectAnswerDiv);
                });
            });
        }
        
        function backToMainScreen() {
            completedTestsScreen.style.display = 'none';
            appContent.style.display = 'block';
            updateCompletedTestsBtnState();
        }

        function deleteCurrentTest() {
            if (!currentReviewingTest) {
                console.error("No test selected for deletion.");
                return;
            }

            showCustomConfirm('Вы уверены, что хотите удалить этот тест? Это действие необратимо.').then(wantsToDelete => {
                if (wantsToDelete) {
                    let completedTests = JSON.parse(localStorage.getItem('satCompletedTests') || '[]');
                    const filteredTests = completedTests.filter(test => test.timestamp !== currentReviewingTest.timestamp);
                    localStorage.setItem('satCompletedTests', JSON.stringify(filteredTests));
                    console.log('Test deleted successfully.');
                    showCompletedTests();
                }
            });
        }

        nextBtn.addEventListener('click', () => {
            const currentCategoryKey = categories[categoriesArray[currentCategoryIndex]];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];
            const isLastQuestion = (currentCategoryIndex === categoriesArray.length - 1 && 
                                   currentQuestionIndex === questionsInCurrentCategory.length - 1);
            if (isLastQuestion) {
                endQuiz();
            } else {
                handleNextQuestion();
            }
        });
        saveAndExitBtn.addEventListener('click', handleSaveAndExit);
        
        showCompletedTestsBtn.addEventListener('click', showCompletedTests);
        backToTestsBtn.addEventListener('click', () => {
            testsListContainer.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            currentReviewingTest = null;
        });
        backToMainBtn.addEventListener('click', backToMainScreen);
        deleteTestBtn.addEventListener('click', deleteCurrentTest);

        const savedSession = localStorage.getItem('satQuizSession');
        if (savedSession) {
            isSessionActive = true;
        }
        updateCompletedTestsBtnState();
    </script>
</body>
</html>
