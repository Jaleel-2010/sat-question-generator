<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор вопросов SAT</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%; /* Ensure container takes full width on smaller screens */
        }
        .section-title {
            border-bottom: 2px solid #cbd5e1; /* Light gray border */
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .question-card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0; /* Light border */
        }
        .question-passage {
            font-style: italic;
            color: #4a5568; /* Dark gray text */
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .question-text {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2d3748; /* Darker gray text */
        }
        .option-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            border-radius: 0.5rem;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 1px solid transparent; /* Default transparent border */
        }
        .option-item:hover:not(.disabled) {
            background-color: #f3f4f6; /* Light gray on hover */
        }
        .option-item.correct {
            background-color: #d1fae5; /* Light green for correct answer */
            border-color: #34d399; /* Green border */
            font-weight: 500;
        }
        .option-item.incorrect {
            background-color: #fee2e2; /* Light red for incorrect answer */
            border-color: #ef4444; /* Red border */
            font-weight: 500;
        }
        .option-item.disabled {
            pointer-events: none; /* Disable clicks */
            opacity: 0.8; /* Slightly dim disabled options */
        }
        .explanation {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #e2e8f0;
            font-size: 0.9rem;
            color: #4a5568;
            display: none; /* Hidden by default */
        }
        /* New: Style for tooltips */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #94a3b8; /* Dotted underline for tooltip words */
        }
        .tooltip-text {
            visibility: hidden;
            width: auto; /* Adjust width based on content */
            max-width: 500px; /* Increased max-width for more words */
            background-color: #333;
            color: #fff;
            text-align: left; /* Align text to left for multi-line */
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 100; /* Ensure tooltip is on top */
            bottom: 125%; /* Position above the text */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Allow text wrapping */
            word-wrap: break-word; /* Ensure long words break */
            font-size: 0.85rem;
            pointer-events: none; /* Allow clicks to pass through tooltip when not hovered */
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
        .login-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .login-button {
            width: 100%;
            background-color: #4299e1; /* Blue */
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #3182ce; /* Darker blue */
        }
        .error-message {
            color: #ef4444;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        /* New styles for completed tests screen */
        .completed-tests-screen {
            background-color: #f0f4f8;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%;
        }
        .completed-test-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .completed-test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .completed-test-card-details {
            border-left: 4px solid #3b82f6; /* Blue border for details */
            padding-left: 1rem;
            margin-top: 1rem;
        }
        .completed-test-details-question-card {
            background-color: #f8fafc;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #e2e8f0;
        }
        .user-answer {
            font-weight: 500;
        }
        /* Style for SVG container to ensure responsiveness */
        .svg-container {
            width: 100%;
            height: auto;
            max-width: 600px; /* New: Limit max width on large screens */
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            margin-left: auto; /* New: Center the container */
            margin-right: auto; /* New: Center the container */
        }
        /* New: Style for text inside the SVG */
        .svg-container svg text {
            font-family: 'Inter', sans-serif;
            font-size: 12px; /* Set a default font size */
        }
    </style>
</head>
<body>
    <div id="loginScreen" class="login-container">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">Welcome to Jaleel's Verbal SAT Question Generator</h2>
        <input type="password" id="passwordInput" class="login-input" placeholder="Введите пароль">
        <button id="loginBtn" class="login-button">Войти</button>
        <p id="loginError" class="error-message" style="display: none;">Неверный пароль. Попробуйте снова.</p>
    </div>

    <div id="appContent" class="container" style="display: none;">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Генератор вопросов SAT (Verbal Section)</h1>
        
        <div id="timerContainer" class="flex items-center justify-center mb-4 text-xl font-bold text-red-600" style="display: none;">
            <svg class="h-6 w-6 mr-2 animate-pulse" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span id="fullTestTimer"></span>
        </div>
        
        <!-- NEW: Exclusion Topics input field -->
        <div class="mb-6 p-4 bg-white rounded-lg shadow-sm border border-gray-200">
            <label for="exclusionTopics" class="block text-gray-700 text-sm font-bold mb-2">Исключить темы (через запятую):</label>
            <textarea id="exclusionTopics" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500" placeholder="Например: 'Вторая мировая война, глобальное потепление, биография Эйнштейна'"></textarea>
        </div>


        <div class="mb-6">
            <label for="difficultySelect" class="block text-gray-700 text-sm font-bold mb-2">Выберите уровень сложности:</label>
            <select id="difficultySelect" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500">
                <option value="easy" selected>Облегченный уровень (Easier Module)</option>
                <option value="hard">Усложненный уровень (Harder Module 2)</option>
            </select>
        </div>

        <div id="categoryButtonsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <!-- Buttons for each category will be inserted here by JavaScript -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mb-4">
            <button id="fullTestBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">
                Полный тест с контролем времени
            </button>
            <button id="showCompletedTestsBtn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                Завершенные тесты
            </button>
        </div>
        
        <div id="loadingIndicator" class="loading-indicator text-center" style="display: none;">
            <!-- Questions will be loaded here -->
        </div>

        <div id="questionsContainer" class="space-y-10">
            <!-- Questions will be loaded here -->
        </div>

        <!-- Corrected button order -->
        <div class="flex flex-col sm:flex-row justify-between gap-4 mt-4">
            <button id="nextBtn" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                Следующий вопрос
            </button>
            <button id="saveAndExitBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" style="display: none;">
                Сохранить и выйти
            </button>
        </div>
    </div>

    <div id="completedTestsScreen" class="completed-tests-screen" style="display: none;">
        <button id="backToMainBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
            &larr; Назад в главное окно
        </button>
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Завершенные тесты</h1>
        <div id="testsListContainer" class="space-y-4">
            <!-- Completed tests will be listed here -->
        </div>
        <div id="completedTestDetailsContainer" class="mt-8" style="display: none;">
            <button id="backToTestsBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg mb-4 transition duration-200 ease-in-out">
                &larr; Назад к списку тестов
            </button>
            <!-- New delete button added here -->
            <button id="deleteTestBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mb-4 ml-4 transition duration-200 ease-in-out">
                Удалить тест
            </button>
            <div id="testReviewContainer">
                <!-- Detailed test review will be displayed here -->
            </div>
        </div>
    </div>

    <script type="module">
        // Import the Google Generative AI library
        import { GoogleGenerativeAI } from 'https://esm.sh/@google/generative-ai';

        // Initialize Firebase (required for Canvas environment, even if not directly used for auth in this example)
        // This ensures __app_id and __firebase_config are handled correctly.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        // ---------------------------------------------------------------------------------------------------
        // ИСПРАВЛЕНО: Предыдущая ошибка возникала из-за использования 'import.meta.env', 
        // который не поддерживается в данной среде Canvas.
        // Чтобы код работал, мы напрямую используем пустую строку. В этой среде
        // Canvas автоматически предоставит API-ключ для разрешенных моделей, если
        // переменная 'apiKey' пуста.
        // ---------------------------------------------------------------------------------------------------
        const apiKey = "AIzaSyB6HddnRBVrrDWv_ujKlFx7ZQST1RzvcZs";
        
        // Initialize Google Generative AI
        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-preview-05-20" });

        const loginScreen = document.getElementById('loginScreen');
        const passwordInput = document.getElementById('passwordInput');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const appContent = document.getElementById('appContent');
        const categoryButtonsContainer = document.getElementById('categoryButtonsContainer');
        const fullTestBtn = document.getElementById('fullTestBtn');

        const questionsContainer = document.getElementById('questionsContainer');
        const showCompletedTestsBtn = document.getElementById('showCompletedTestsBtn');
        const completedTestsScreen = document.getElementById('completedTestsScreen');
        const testsListContainer = document.getElementById('testsListContainer');
        const completedTestDetailsContainer = document.getElementById('completedTestDetailsContainer');
        const testReviewContainer = document.getElementById('testReviewContainer');
        const backToTestsBtn = document.getElementById('backToTestsBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const difficultySelect = document.getElementById('difficultySelect');
        const nextBtn = document.getElementById('nextBtn');
        const saveAndExitBtn = document.getElementById('saveAndExitBtn');
        const deleteTestBtn = document.getElementById('deleteTestBtn');
        const timerContainer = document.getElementById('timerContainer');
        const fullTestTimer = document.getElementById('fullTestTimer');
        
        // NEW: Exclusion topics textarea
        const exclusionTopicsInput = document.getElementById('exclusionTopics');

        const categories = {
            "Information and Ideas": "information_ideas",
            "Craft and Structure": "craft_structure",
            "Expression of Ideas": "expression_ideas",
            "Standard English Conventions": "standard_english_conventions"
        };
        const romanNumerals = ['I', 'II', 'III', 'IV'];

        // Global state to manage questions and current position
        let allGeneratedQuestions = {};
        let completedQuestions = [];
        let categoriesArray = [];
        let currentCategoryIndex = 0;
        let currentQuestionIndex = 0;
        let isSessionActive = false;
        let isFullTest = false; 
        let currentReviewingTest = null;
        let questionStartTime = 0; 

        // Hardcoded password for client-side authentication
        const CORRECT_PASSWORD = "Jaleel2010";

        // Inactivity timer variables
        let inactivityTimer;
        const INACTIVITY_TIMEOUT = 5 * 60 * 1000;
        
        // Countdown timer variables
        let generationCountdownInterval;
        const GENERATION_COUNTDOWN_SECONDS = 90;

        // Full Test timer variables - UPDATED
        let fullTestInterval;
        const FULL_TEST_DURATION_MINUTES = 30; 
        const FULL_TEST_DURATION_SECONDS = FULL_TEST_DURATION_MINUTES * 60;
        let timeLeft = FULL_TEST_DURATION_SECONDS;
        
        // --- NEW: Function to robustly parse the API response to handle non-JSON text ---
        function parseApiResponse(text) {
            try {
                // Try to find the JSON array part of the string.
                // This regex looks for the content between the first '[' and the last ']'.
                const jsonMatch = text.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                } else {
                    // If no array is found, it might be a single JSON object.
                    const objectMatch = text.match(/\{[\s\S]*\}/);
                    if (objectMatch) {
                        return JSON.parse(objectMatch[0]);
                    }
                }
            } catch (e) {
                console.error("Failed to parse JSON even after cleaning:", e);
                throw new Error("Invalid JSON format from API.");
            }
            throw new Error("No valid JSON found in API response.");
        }

        // Function to reset the inactivity timer
        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(logoutUser, INACTIVITY_TIMEOUT);
        }

        // Function to save the current session state
        function saveSession() {
            if (Object.keys(allGeneratedQuestions).length > 0) {
                const sessionData = {
                    categoryIndex: currentCategoryIndex,
                    questionIndex: currentQuestionIndex,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value,
                    completedQuestions: completedQuestions,
                    categoriesArray: categoriesArray,
                    isFullTest: isFullTest,
                    timeLeft: timeLeft
                };
                localStorage.setItem('satQuizSession', JSON.stringify(sessionData));
                console.log('Session saved.');
            }
        }

        // Function to load a saved session state
        function loadSession() {
            const savedSession = localStorage.getItem('satQuizSession');
            if (savedSession) {
                const confirmation = showCustomConfirm('Обнаружена незавершенная сессия. Хотите продолжить с того места, где остановились?');
                
                return new Promise(resolve => {
                    confirmation.then(resume => {
                        if (resume) {
                            const sessionData = JSON.parse(savedSession);
                            currentCategoryIndex = sessionData.categoryIndex;
                            currentQuestionIndex = sessionData.questionIndex;
                            allGeneratedQuestions = sessionData.questions;
                            difficultySelect.value = sessionData.difficulty;
                            completedQuestions = sessionData.completedQuestions || [];
                            categoriesArray = sessionData.categoriesArray || Object.keys(categories);
                            isFullTest = sessionData.isFullTest || false;
                            timeLeft = sessionData.timeLeft || FULL_TEST_DURATION_SECONDS;
                            isSessionActive = true;
                            console.log('Session loaded. Resuming test.');
                            resolve(true);
                        } else {
                            localStorage.removeItem('satQuizSession');
                            isSessionActive = false;
                            resolve(false);
                        }
                    });
                });
            }
            return Promise.resolve(false);
        }

        // Custom confirmation dialog (replaces alert/confirm)
        function showCustomConfirm(message) {
            return new Promise(resolve => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modalOverlay.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <p class="text-lg font-semibold mb-4">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                            <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('confirmYes').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });
                document.getElementById('confirmNo').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(false);
                });
            });
        }

        // Function to update the disabled state of the buttons
        function updateMainButtonsState(isDisabled) {
            document.querySelectorAll('#categoryButtonsContainer button').forEach(button => {
                button.disabled = isDisabled;
                button.classList.toggle('opacity-50', isDisabled);
                button.classList.toggle('cursor-not-allowed', isDisabled);
                button.classList.toggle('hover:bg-blue-700', !isDisabled);
                button.classList.toggle('hover:scale-105', !isDisabled);
            });
            fullTestBtn.disabled = isDisabled;
            fullTestBtn.classList.toggle('opacity-50', isDisabled);
            fullTestBtn.classList.toggle('cursor-not-allowed', isDisabled);
            fullTestBtn.classList.toggle('hover:bg-indigo-700', !isDisabled);
            fullTestBtn.classList.toggle('hover:scale-105', !isDisabled);
            showCompletedTestsBtn.disabled = isDisabled;
            showCompletedTestsBtn.classList.toggle('opacity-50', isDisabled);
            showCompletedTestsBtn.classList.toggle('cursor-not-allowed', isDisabled);
            showCompletedTestsBtn.classList.toggle('hover:bg-gray-600', !isDisabled);
            showCompletedTestsBtn.classList.toggle('hover:scale-105', !isDisabled);
        }

        // Function to log out the user and reset the app state
        function logoutUser(saveCurrent = true) {
            if (saveCurrent) {
                saveSession();
            } else {
                localStorage.removeItem('satQuizSession');
            }
            
            isSessionActive = false;
            isFullTest = false;
            updateMainButtonsState(false);

            // Hide app content and show login screen
            appContent.style.display = 'none';
            loginScreen.style.display = 'block';
            passwordInput.value = '';
            loginError.style.display = 'none';

            // Reset application state
            allGeneratedQuestions = {};
            completedQuestions = [];
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            currentReviewingTest = null;
            categoriesArray = [];
            questionStartTime = 0;

            // Hide all buttons that appear after login/generation
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            questionsContainer.innerHTML = '';
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            timerContainer.style.display = 'none';

            // Stop any existing timers
            clearTimeout(inactivityTimer);
            clearInterval(generationCountdownInterval);
            clearInterval(fullTestInterval);
        }

        // Event listeners for user activity to reset the timer
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        document.addEventListener('scroll', resetInactivityTimer);

        // Initial check for activity when the page loads
        resetInactivityTimer();

        // Function to generate the category buttons
        function createCategoryButtons() {
            categoryButtonsContainer.innerHTML = '';
            Object.keys(categories).forEach(categoryTitle => {
                const categoryKey = categories[categoryTitle];
                const button = document.createElement('button');
                button.id = `generateBtn-${categoryKey}`;
                button.className = 'w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75';
                button.textContent = categoryTitle;
                button.addEventListener('click', () => handleNewTest(categoryKey));
                categoryButtonsContainer.appendChild(button);
            });
        }

        // Login function
        loginBtn.addEventListener('click', async () => {
            if (passwordInput.value === CORRECT_PASSWORD) {
                loginScreen.style.display = 'none';
                appContent.style.display = 'block';
                loginError.style.display = 'none';
                
                createCategoryButtons();
                const sessionResumed = await loadSession();
                if (sessionResumed) {
                    displayCurrentQuestion();
                    nextBtn.style.display = 'block';
                    // Conditional display for save/exit button
                    saveAndExitBtn.style.display = isFullTest ? 'none' : 'block';
                    nextBtn.disabled = true;
                    nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    if (isFullTest) {
                        startFullTestTimer();
                        timerContainer.style.display = 'flex';
                    }
                } else {
                    questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите на кнопку категории, чтобы начать новый тест, или "Полный тест с контролем времени".</p>';
                }
                updateMainButtonsState(isSessionActive);
                resetInactivityTimer();
            } else {
                loginError.style.display = 'block';
            }
        });

        // Allow pressing Enter key to login
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loginBtn.click();
            }
        });
        
        // Function to start the generation countdown timer
        function startGenerationCountdown() {
            let timeLeft = GENERATION_COUNTDOWN_SECONDS;
            const timerElement = document.getElementById('timer');
            timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;

            generationCountdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    timerElement.textContent = `Осталось времени: ${timeLeft} сек.`;
                } else {
                    clearInterval(generationCountdownInterval);
                    timerElement.textContent = 'Время вышло, генерация продолжается...';
                }
            }, 1000);
        }

        // Function to start the full test timer
        function startFullTestTimer() {
            clearInterval(fullTestInterval);
            timerContainer.style.display = 'flex';

            fullTestInterval = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                fullTestTimer.textContent = `Осталось: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    clearInterval(fullTestInterval);
                    endQuizTimedOut();
                }
            }, 1000);
        }

        // Function to show loading indicator
        function showLoading(message) {
            questionsContainer.innerHTML = '';
            loadingIndicator.innerHTML = `
                <p class="text-xl font-semibold mb-4 text-gray-700">${message}</p>
                <div id="timer" class="text-md font-medium text-gray-500 mb-4"></div>
                <div class="mt-4">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-gray-900 mx-auto"></div>
                </div>
            `;
            loadingIndicator.style.display = 'block';
            
            updateMainButtonsState(true);

            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            timerContainer.style.display = 'none';
            
            clearInterval(generationCountdownInterval);
            startGenerationCountdown();
        }

        // Function to hide loading indicator
        function hideLoading() {
            loadingIndicator.style.display = 'none';
            loadingIndicator.innerHTML = '';
            clearInterval(generationCountdownInterval);
        }

        // Function to generate multiple questions for a given category with exponential backoff
        async function generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, excludedTopics, retries = 0) {
            const MAX_RETRIES = 5;
            const BASE_DELAY_MS = 1000;
            
            const numberOfQuestions = 7; 

            let prompt = "";
            
            const difficultyModifier = difficulty === 'hard' ? 'challenging' : 'straightforward';
            const wordCountRange = difficulty === 'hard' ? '60-80' : '40-60';
            
            // NEW: Add excluded topics to the prompt
            const excludeText = excludedTopics && excludedTopics.length > 0 ? `Explicitly avoid passages and questions on the following topics: ${excludedTopics.join(', ')}.` : '';
            
            // Define the JSON schema for the expected output
            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        passage: { type: "STRING" },
                        question: { type: "STRING" },
                        options: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    label: { type: "STRING" },
                                    text: { type: "STRING" }
                                },
                                required: ["label", "text"]
                            }
                        },
                        correct_answer: { type: "STRING" },
                        explanation: { type: "STRING" },
                        vocabulary: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    word: { "type": "STRING" },
                                    translation: { "type": "STRING" },
                                    explanation: { "type": "STRING" }
                                },
                                required: ["word", "translation", "explanation"]
                            }
                        },
                        category: { type: "STRING" },
                        graphic: { type: "STRING" }
                    },
                    required: ["passage", "question", "options", "correct_answer", "explanation", "category"]
                }
            };
            
            switch (categoryKey) {
                case "information_ideas":
                    // UPDATED PROMPT: More specific source material instructions and excluded topics
                    prompt = `
                        Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions in English, each based on a new and distinct topic. ${excludeText}
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. Passages must be fresh and not repeat previous topics within this generation request.
                        2. A specific SAT-style question in English based on the passage, designed to test a particular skill.
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.
                        
                        The 7 questions should be of the following types, each with a unique source material and topic, explicitly avoiding the excluded topics:
                        - Question 1 (Direct Question): Based on an excerpt from an 18th-century philosophical text.
                        - Question 2 (Inference Question): Based on an excerpt from a 20th-century American novel.
                        - Question 3 (Main Idea Question): Based on a short essay about a recent astronomical discovery.
                        - Question 4 (Figure based Question): Based on a bar chart, line graph, or pie chart illustrating a historical demographic trend. The passage field should provide context for the data, and a new "graphic" field must contain a **complete and self-contained SVG string** for the chart. The SVG should be compact, and all text labels (titles, axes, data labels) must be legible, not overlap, be contained within the SVG's viewBox, and use the 'Inter, sans-serif' font family with a font-size of 12px to match the application's styling. The SVG must be responsive, and all graphic components (bars, lines, slices) must use a color palette that excludes pure white and black. The font inside the SVG must be the same as the font of the answers.
                        - Question 5 (Strengthen Weaken Question): Based on a short argumentative essay on an ethical issue concerning artificial intelligence.
                        - Question 6 (Poem based Question): Based on a short contemporary poem.
                        - Question 7 (Character Descriptions): Based on an an excerpt from a biography of a historical figure.
                    `;
                    break;
                case "craft_structure":
                    // UPDATED PROMPT: More specific source material instructions and excluded topics
                    prompt = `
                        Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions in English, each based on a new and distinct topic. ${excludeText}
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic. For Cross-text Connection questions, provide two distinct, short passages. The passages must be fresh and not repeat previous topics within this generation request.
                        2. A specific SAT-style question in English based on the passage(s).
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.

                        The 7 questions should be of the following types, ensuring a good mix across the list and using unique topics, explicitly avoiding the excluded topics:
                        - Vocabulary in Context (from a text about a specific art movement)
                        - Primary Purpose Questions (from an excerpt of a scientific research summary)
                        - Purpose of a portion Questions (from a philosophical text on logic)
                        - Structure Questions (from a detailed guide on computer programming)
                        - Cross-text Connection Questions (two passages on differing interpretations of a myth)
                        - Quotes Illustrate Questions (from an analysis of a psychological concept)
                        - A seventh question which is a duplicate of one of the above types, but with a different topic.
                        
                        For "Vocabulary in Context" and "Purpose of a portion" questions, highlight the specific word, phrase, or sentence in the passage by enclosing it in double asterisks (e.g., **word**).
                    `;
                    break;
                case "expression_ideas":
                    // UPDATED PROMPT: More specific source material instructions and excluded topics
                    prompt = `
                        Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions in English, each based on a new and distinct topic. ${excludeText}
                        For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, such as a student's essay draft about the social impact of a new technology, an analysis of a classic piece of music, or a research proposal on a historical event. The passages must be fresh and not repeat previous topics within this generation request.
                        2. A specific SAT-style question in English based on the passage. The questions must consist of:
                           - **3-4 Transition Questions**: Asks for the most logical transition to connect a paragraph to a previous one or to a specific sentence within the paragraph. The part of the passage that requires a transition should be highlighted by enclosing it in double asterisks (e.g., **The phrase to be revised**).
                           - **3-4 Goal-based Questions**: Asks which revision of a sentence best achieves a specified goal, such as making a point more precise or establishing a clearer tone.
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors.
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.
                        
                        For "Transition Questions" and "Goal-based Questions", highlight the relevant part of the passage that needs revision by enclosing it in double asterisks (e.g., **The phrase to be revised**).
                    `;
                    break;
                case "standard_english_conventions":
                    // UPDATED PROMPT: More specific source material instructions and excluded topics
                    prompt = `
                        Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryTitle}" questions in English, each based on a new and distinct topic. ${excludeText} For each question, provide:
                        1. A short, ${difficultyModifier} passage (${wordCountRange} words) on a distinct topic, such as a historical account of a battle, a technical manual for a tool, or a biographical sketch of an artist. Each passage must contain a specific grammatical or punctuation error. The passages must be fresh and not repeat previous topics within this generation request.
                        2. A SAT-style question in English that asks the user to correct the error. The questions must cover a variety of the following rules:
                           - Subject-verb agreement
                           - Subject pronoun agreement
                           - Comma subject rule
                           - Punctuation on the SAT
                           - Apostrophe
                           - Listing
                           - Introduction of a list or description
                           - Comparison
                           - Tense
                        3. Four answer choices (A, B, C, D) in English, one correct and three plausible distractors. One of the options must always be "NO CHANGE".
                        4. The correct answer label (e.g., "A").
                        5. A brief explanation in Russian for the correct answer.
                        6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9-grade student in a Russian-language secondary school. For each identified word, provide its exact English form, its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                        7. Include the category name "${categoryTitle}" in a 'category' field.
                        
                        The part of the passage with the grammatical error should be highlighted by enclosing it in double asterisks (e.g., **phrase with error**).
                    `;
                    break;
            }

            try {
                const result = await model.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    }
                });
                
                // Use the new robust parsing function
                const questionsArray = parseApiResponse(result.response.text());
                
                if (!Array.isArray(questionsArray)) {
                    throw new Error("API did not return a JSON array of questions.");
                }
                return questionsArray;
            } catch (error) {
                console.error(`Error generating questions for ${categoryTitle} (Difficulty: ${difficulty}):`, error);
                
                if (retries < MAX_RETRIES) {
                    const delay = BASE_DELAY_MS * Math.pow(2, retries) + (Math.random() * 100);
                    console.warn(`Retrying ${categoryTitle} question generation in ${delay}ms (retry ${retries + 1}/${MAX_RETRIES})...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return generateQuestionsForCategory(categoryTitle, categoryKey, difficulty, excludedTopics, retries + 1);
                }

                let errorMessage = `<p class='text-red-600'>Произошла ошибка при генерации вопросов для категории "${categoryTitle}" (Уровень: ${difficulty === 'hard' ? 'Усложненный' : 'Облегченный'}). Пожалуйста, попробуйте еще раз.</p>`;

                if (error.message) {
                    if (error.message.includes("403") && error.message.includes("unregistered callers")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: Проблема с доступом к Gemini API (ошибка 403). Пожалуйста, убедитесь, что ваш API-ключ действителен и имеет необходимые разрешения для модели 'gemini-2.5-flash-preview-05-20' в Google Cloud Console.</p>";
                    } else if (error.message.includes("API key not valid")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: API ключ Gemini недействителен. Пожалуйста, убедитесь, что он правильно настроен в вашей среде.</p>";
                    } else if (error.message.includes("JSON")) {
                         errorMessage = `<p class='text-red-600'>Ошибка парсинга JSON для категории "${categoryTitle}". Модель вернула некорректный формат. Пожалуйста, попробуйте еще раз.</p>`;
                    }
                }
                loadingIndicator.innerHTML = errorMessage;
                hideLoading();
                return null;
            }
        }

        // Function to display a single question
        function displayQuestion(questionData, categoryTitle, isReview = false) {
            if (!questionData) return;

            // NEW: Reset the question start time when a new question is displayed
            if (!isReview) {
                questionStartTime = Date.now();
            }

            const questionCard = document.createElement('div');
            questionCard.className = isReview ? 'completed-test-details-question-card' : 'question-card';

            // NEW: Check for graphic data and add a container for it
            if (questionData.graphic) {
                const graphicContainer = document.createElement('div');
                graphicContainer.className = 'svg-container';
                graphicContainer.innerHTML = questionData.graphic;
                questionCard.appendChild(graphicContainer);
            }

            let passageContent = questionData.passage;

            // First, add tooltips for vocabulary words
            if (questionData.vocabulary && Array.isArray(questionData.vocabulary)) {
                questionData.vocabulary.forEach(vocabItem => {
                    const escapedWord = vocabItem.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi'); 
                    passageContent = passageContent.replace(regex, (matchedWord) => {
                        const formattedWordInTooltip = `<strong>${matchedWord.charAt(0).toUpperCase() + matchedWord.slice(1)}</strong>`;
                        return `<span class="tooltip-container">${matchedWord}<span class="tooltip-text">${formattedWordInTooltip}: ${vocabItem.translation}: ${vocabItem.explanation}</span></span>`;
                    });
                });
            }

            // Then, apply highlighting for Expression of Ideas, Craft and Structure, and Standard English Conventions
            if (categoryTitle === "Expression of Ideas" || categoryTitle === "Craft and Structure" || categoryTitle === "Standard English Conventions") {
                passageContent = passageContent.replace(/\*\*(.*?)\*\*/g, `<span class="font-bold underline">$1</span>`);
            }
            
            const passageDiv = document.createElement('div');
            passageDiv.className = 'question-passage';
            passageDiv.innerHTML = passageContent;

            const questionTextDiv = document.createElement('div');
            questionTextDiv.className = 'question-text';
            questionTextDiv.textContent = questionData.question;

            const optionsList = document.createElement('div');
            optionsList.className = 'options-list';

            let optionsToDisplay = questionData.options;
            if (typeof optionsToDisplay === 'string') {
                try {
                    optionsToDisplay = JSON.parse(optionsToDisplay);
                } catch (e) {
                    console.warn("Could not parse options string:", optionsToDisplay, e);
                    optionsToDisplay = [];
                }
            }
            if (!Array.isArray(optionsToDisplay)) {
                console.warn("questionData.options is not an array after processing:", optionsToDisplay);
                optionsToDisplay = [];
            }

            const explanationDiv = document.createElement('div');
            explanationDiv.className = 'explanation';
            explanationDiv.textContent = `Объяснение: ${questionData.explanation}`;
            
            if (isReview) {
                explanationDiv.style.display = 'block';
            } else {
                explanationDiv.style.display = 'none';
            }

            optionsToDisplay.forEach(option => {
                const optionItem = document.createElement('div');
                optionItem.className = `option-item px-4 py-2 cursor-pointer rounded-md transition duration-200 ease-in-out hover:bg-gray-100`;
                optionItem.textContent = `${option.label}. ${option.text}`;
                optionItem.dataset.label = option.label;
                optionItem.dataset.correctAnswer = questionData.correct_answer;

                if (isReview) {
                    optionItem.classList.add('disabled');
                    optionItem.style.pointerEvents = 'none';

                    const userLabel = questionData.user_answer;
                    const correctLabel = questionData.correct_answer;

                    if (option.label === correctLabel) {
                        optionItem.classList.add('correct');
                    }
                    if (option.label === userLabel && userLabel !== correctLabel) {
                        optionItem.classList.add('incorrect');
                    }
                } else {
                    optionItem.addEventListener('click', function() {
                        optionsList.querySelectorAll('.option-item').forEach(opt => {
                            opt.classList.add('disabled');
                            opt.style.pointerEvents = 'none';
                        });

                        const selectedLabel = this.dataset.label;
                        const correctAnswerLabel = this.dataset.correctAnswer;
                        const timeTaken = (Date.now() - questionStartTime) / 1000; 

                        const questionWithAnswer = {
                            ...questionData,
                            user_answer: selectedLabel,
                            time_taken: timeTaken 
                        };
                        completedQuestions.push(questionWithAnswer);
                        
                        optionsList.querySelectorAll('.option-item').forEach(opt => {
                            if (opt.dataset.label === correctAnswerLabel) {
                                opt.classList.add('correct');
                            } else if (opt.dataset.label === selectedLabel) {
                                opt.classList.add('incorrect');
                            }
                        });

                        explanationDiv.style.display = 'block';

                        nextBtn.disabled = false;
                        nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        resetInactivityTimer();
                    });
                }
                optionsList.appendChild(optionItem);
            });

            if (passageDiv.innerHTML.trim() !== '') { // Only append if there's actual passage content
                questionCard.appendChild(passageDiv);
            }
            questionCard.appendChild(questionTextDiv);
            questionCard.appendChild(optionsList);
            questionCard.appendChild(explanationDiv);

            return questionCard;
        }

        // Function to display the current question based on global indices
        function displayCurrentQuestion() {
            const currentCategoryTitle = categoriesArray[currentCategoryIndex];
            const currentCategoryKey = categories[currentCategoryTitle];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];

            if (questionsInCurrentCategory && questionsInCurrentCategory.length > currentQuestionIndex) {
                questionsContainer.innerHTML = '';
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'category-section mb-10';

                const sectionTitle = document.createElement('h2');
                sectionTitle.className = 'text-2xl font-semibold text-gray-700 mb-6 section-title';
                const romanNumeral = romanNumerals[currentCategoryIndex] || '';
                const totalQuestions = isFullTest ? 28 : questionsInCurrentCategory.length;
                const overallQuestionIndex = completedQuestions.length + 1;
                
                sectionTitle.textContent = `${romanNumeral}. ${currentCategoryTitle} (Вопрос ${overallQuestionIndex} из ${totalQuestions})`;
                sectionDiv.appendChild(sectionTitle);

                const questionData = questionsInCurrentCategory[currentQuestionIndex];
                const questionCard = displayQuestion(questionData, currentCategoryTitle);
                if (questionCard) {
                    sectionDiv.appendChild(questionCard);
                }
                questionsContainer.appendChild(sectionDiv);

                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                nextBtn.style.display = 'block';
                // Only show save/exit button if it's not a full test
                saveAndExitBtn.style.display = isFullTest ? 'none' : 'block';

                const isLastQuestion = (currentCategoryIndex === categoriesArray.length - 1 && currentQuestionIndex === questionsInCurrentCategory.length - 1);
                if (isLastQuestion) {
                    nextBtn.textContent = 'Завершить тест';
                } else {
                    nextBtn.textContent = 'Следующий вопрос';
                }
            } else {
                endQuiz(); 
            }
        }

        // Main function to generate questions and start the quiz for a specific category
        async function handleNewTest(categoryKey) {
            if (isSessionActive) {
                const wantsToContinue = await showCustomConfirm('В настоящий момент у вас активен тест. Хотите начать новый тест и отменить текущий?');
                if (!wantsToContinue) {
                    return;
                }
                clearInterval(fullTestInterval);
            }
            
            const categoryTitle = Object.keys(categories).find(key => categories[key] === categoryKey);
            showLoading(`Генерация вопросов для "${categoryTitle}"...`);
            
            localStorage.removeItem('satQuizSession'); 
            completedQuestions = [];

            isSessionActive = true;
            isFullTest = false;
            updateMainButtonsState(true);

            allGeneratedQuestions = {};
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            categoriesArray = [categoryTitle]; // Set the active category
            
            // NEW: Get excluded topics from the input field
            const excludedTopics = exclusionTopicsInput.value.split(',').map(topic => topic.trim()).filter(Boolean);

            const selectedDifficulty = difficultySelect.value;
            const questionsForCategory = await generateQuestionsForCategory(categoryTitle, categoryKey, selectedDifficulty, excludedTopics);

            hideLoading();

            if (questionsForCategory && questionsForCategory.length > 0) {
                allGeneratedQuestions[categoryKey] = questionsForCategory;
                nextBtn.style.display = 'block';
                saveAndExitBtn.style.display = 'block';
                displayCurrentQuestion();
                resetInactivityTimer();
            } else {
                nextBtn.style.display = 'none';
                saveAndExitBtn.style.display = 'none';
                questionsContainer.innerHTML = `<p class="text-center text-red-600 text-lg">Не удалось сгенерировать вопросы для категории "${categoryTitle}". Пожалуйста, попробуйте еще раз.</p>`;
            }
        }
        
        // New function to handle full test generation
        async function handleFullTest() {
            if (isSessionActive) {
                const wantsToContinue = await showCustomConfirm('В настоящий момент у вас активен тест. Хотите начать новый тест и отменить текущий?');
                if (!wantsToContinue) {
                    return;
                }
                clearInterval(fullTestInterval);
            }

            showLoading(`Генерация полного теста (28 вопросов)...`);

            localStorage.removeItem('satQuizSession'); 
            completedQuestions = [];
            isSessionActive = true;
            isFullTest = true;
            updateMainButtonsState(true);

            allGeneratedQuestions = {};
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;
            categoriesArray = Object.keys(categories);
            
            const selectedDifficulty = difficultySelect.value;
            // NEW: Get excluded topics from the input field
            const excludedTopics = exclusionTopicsInput.value.split(',').map(topic => topic.trim()).filter(Boolean);
            
            try {
                const generationPromises = Object.keys(categories).map(categoryTitle => 
                    generateQuestionsForCategory(categoryTitle, categories[categoryTitle], selectedDifficulty, excludedTopics)
                );
                const results = await Promise.all(generationPromises);
                
                hideLoading();

                const hasError = results.some(result => !result);
                if (hasError) {
                    isSessionActive = false;
                    isFullTest = false;
                    updateMainButtonsState(false);
                    questionsContainer.innerHTML = `<p class="text-center text-red-600 text-lg">Не удалось сгенерировать полный тест. Пожалуйста, попробуйте еще раз.</p>`;
                    return;
                }
                
                results.forEach((questions, index) => {
                    const categoryTitle = categoriesArray[index];
                    const categoryKey = categories[categoryTitle];
                    allGeneratedQuestions[categoryKey] = questions;
                });

                // Set up the timer and display the first question
                timeLeft = FULL_TEST_DURATION_SECONDS;
                startFullTestTimer();

                nextBtn.style.display = 'block';
                saveAndExitBtn.style.display = 'none'; // Explicitly hide save button for full test
                displayCurrentQuestion();
                resetInactivityTimer();
            } catch (error) {
                console.error("Error generating full test:", error);
                hideLoading();
                isSessionActive = false;
                isFullTest = false;
                updateMainButtonsState(false);
                questionsContainer.innerHTML = `<p class="text-center text-red-600 text-lg">Произошла непредвиденная ошибка при создании полного теста. Пожалуйста, попробуйте еще раз.</p>`;
            }
        }
        
        // Function to handle navigation to the next question
        function handleNextQuestion() {
            const currentCategoryKey = categories[categoriesArray[currentCategoryIndex]];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];

            currentQuestionIndex++;
            if (currentQuestionIndex >= questionsInCurrentCategory.length) {
                currentQuestionIndex = 0;
                currentCategoryIndex++;
            }

            if (currentCategoryIndex >= categoriesArray.length) {
                endQuiz(); 
            } else {
                displayCurrentQuestion();
                resetInactivityTimer();
            }
        }
        
        // Function to handle quiz completion (normal or timed out)
        function endQuiz(timedOut = false) {
            clearInterval(fullTestInterval);

            const completedTests = JSON.parse(localStorage.getItem('satCompletedTests') || '[]');
            
            // Calculate score for the current test
            let correctCount = 0;
            let totalTime = 0;
            if (completedQuestions.length > 0) {
                 completedQuestions.forEach(q => {
                    if (q.user_answer === q.correct_answer) {
                        correctCount++;
                    }
                    if (q.time_taken) {
                        totalTime += q.time_taken;
                    }
                });
            }
            const averageTime = completedQuestions.length > 0 ? totalTime / completedQuestions.length : 0;
            const totalQuestions = completedQuestions.length;
            const scorePercentage = totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;
            const averageTimeThreshold = 60; // 60 seconds is a reasonable average for the test
            const scoreThreshold = 75; // 75% is a good score

            let feedbackMessage = '';
            if (timedOut) {
                feedbackMessage = `
                    <p class="text-xl font-bold mt-4 text-red-600">Время истекло!</p>
                    <p class="text-gray-700 mt-2">К сожалению, вы не успели завершить тест вовремя. Сосредоточьтесь на управлении временем и постарайтесь не задерживаться на одном вопросе слишком долго.</p>
                `;
            } else if (isFullTest) {
                if (scorePercentage >= scoreThreshold && averageTime <= averageTimeThreshold) {
                    feedbackMessage = `
                        <p class="text-xl font-bold mt-4 text-green-600">Отличный результат!</p>
                        <p class="text-gray-700 mt-2">Вы не только хорошо знаете материал, но и эффективно управляете временем. Продолжайте в том же духе, чтобы добиться максимальных результатов!</p>
                    `;
                } else if (scorePercentage >= scoreThreshold && averageTime > averageTimeThreshold) {
                    feedbackMessage = `
                        <p class="text-xl font-bold mt-4 text-yellow-600">Хороший результат!</p>
                        <p class="text-gray-700 mt-2">Вы показали прекрасные знания, но скорость ответа можно улучшить. Попробуйте сосредоточиться на более быстром чтении и анализе вопросов, чтобы уложиться в лимит времени.</p>
                    `;
                } else if (scorePercentage < scoreThreshold && averageTime <= averageTimeThreshold) {
                    feedbackMessage = `
                        <p class="text-xl font-bold mt-4 text-orange-600">Вам есть куда расти!</p>
                        <p class="text-gray-700 mt-2">Вы хорошо укладываетесь в лимит времени, но похоже, что некоторые темы требуют повторения. Потратьте больше времени на изучение разделов, где вы допустили ошибки.</p>
                    `;
                } else { // Low score and high time
                    feedbackMessage = `
                        <p class="text-xl font-bold mt-4 text-red-600">Требуется больше практики.</p>
                        <p class="text-gray-700 mt-2">Похоже, вам нужно уделить внимание как знанию материала, так и скорости ответа. Рекомендуется вернуться к базовым концепциям и больше практиковаться, стараясь отвечать быстрее.</p>
                    `;
                }
            }


            const newCompletedTest = {
                timestamp: new Date().toISOString(),
                difficulty: difficultySelect.value,
                questions: completedQuestions,
                isFullTest: isFullTest,
                timedOut: timedOut,
                score: correctCount, // Store the score
                averageTime: averageTime // Store the average time
            };
            completedTests.push(newCompletedTest);
            localStorage.setItem('satCompletedTests', JSON.stringify(completedTests));
            console.log('Completed test saved locally.');
            
            isSessionActive = false;
            isFullTest = false;
            updateMainButtonsState(false);
            localStorage.removeItem('satQuizSession');
            completedQuestions = [];
            allGeneratedQuestions = {};
            categoriesArray = [];

            let completionMessage = `<p class="text-center text-gray-600 text-lg">Тест завершен. Нажмите на кнопку категории, чтобы начать новый тест.</p>`;
            
            // Display score and feedback for full tests
            if (newCompletedTest.isFullTest) {
                completionMessage = `
                    <p class="text-center text-xl font-bold mt-4">Ваш результат: ${newCompletedTest.score} из ${totalQuestions} правильных ответов.</p>
                    <p class="text-center text-lg font-medium mt-2">Среднее время на вопрос: ${newCompletedTest.averageTime.toFixed(2)} сек.</p>
                    <div class="mt-8 p-4 bg-white rounded-lg shadow-md border border-gray-200">
                        ${feedbackMessage}
                    </div>
                `;
            }

            questionsContainer.innerHTML = completionMessage;
            
            nextBtn.style.display = 'none';
            saveAndExitBtn.style.display = 'none';
            nextBtn.textContent = 'Следующий вопрос'; 
            timerContainer.style.display = 'none';
            clearTimeout(inactivityTimer); 
        }

        // Specific function for a timed-out quiz
        function endQuizTimedOut() {
            endQuiz(true);
        }

        // Function to handle saving and exiting the test
        function handleSaveAndExit() {
            logoutUser();
            questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Тест сохранен. Вы можете сгенерировать новые вопросы.</p>';
        }

        // --- New functions for Completed Tests feature ---
        function showCompletedTests() {
            appContent.style.display = 'none';
            completedTestsScreen.style.display = 'block';
            testsListContainer.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            
            const completedTests = JSON.parse(localStorage.getItem('satCompletedTests') || '[]');
            testsListContainer.innerHTML = '';

            if (completedTests.length === 0) {
                testsListContainer.innerHTML = '<p class="text-center text-gray-600">У вас пока нет завершенных тестов.</p>';
                return;
            }

            completedTests.reverse().forEach((test, index) => {
                const testType = test.isFullTest ? `Полный тест` : test.questions[0].category;
                let scoreDisplay = '';
                if (test.isFullTest && typeof test.score !== 'undefined') {
                    scoreDisplay = `<p class="text-sm text-gray-600">Результат: ${test.score} из ${test.questions.length}</p>`;
                }
                const testCard = document.createElement('div');
                testCard.className = 'completed-test-card';
                testCard.innerHTML = `
                    <p class="text-lg font-semibold text-gray-800">Тест (${testType}) от ${new Date(test.timestamp).toLocaleString('ru-RU')}</p>
                    <p class="text-sm text-gray-600">Сложность: ${test.difficulty === 'hard' ? 'Усложненный' : 'Облегченный'}</p>
                    ${scoreDisplay}
                    ${test.timedOut ? '<p class="text-xs text-red-500 font-bold">Тест завершен по истечении времени</p>' : ''}
                `;
                testCard.addEventListener('click', () => displayCompletedTestDetails(test));
                testsListContainer.appendChild(testCard);
            });
        }

        function displayCompletedTestDetails(testData) {
            currentReviewingTest = testData;

            testsListContainer.style.display = 'none';
            completedTestDetailsContainer.style.display = 'block';
            testReviewContainer.innerHTML = '';

            const reviewTitle = document.createElement('h2');
            reviewTitle.className = 'text-3xl font-bold text-gray-800 mb-6';
            const testType = testData.isFullTest ? 'Полный тест' : testData.questions[0].category;
            reviewTitle.textContent = `Обзор теста (${testType}) от ${new Date(testData.timestamp).toLocaleString('ru-RU')}`;
            testReviewContainer.appendChild(reviewTitle);

            // Display score at the top for full tests
            if (testData.isFullTest && typeof testData.score !== 'undefined') {
                const scoreElement = document.createElement('p');
                scoreElement.className = 'text-2xl font-bold text-green-600 mb-2';
                scoreElement.textContent = `Ваш результат: ${testData.score} из ${testData.questions.length} правильных ответов.`;
                testReviewContainer.appendChild(scoreElement);
                
                // NEW: Display average time per question
                if (typeof testData.averageTime !== 'undefined' && testData.averageTime > 0) {
                    const avgTimeElement = document.createElement('p');
                    avgTimeElement.className = 'text-lg font-medium text-gray-700 mb-6';
                    avgTimeElement.textContent = `Среднее время на вопрос: ${testData.averageTime.toFixed(2)} сек.`;
                    testReviewContainer.appendChild(avgTimeElement);
                }
            }

            const allQuestions = testData.questions;
            const categoriesMap = {};
            allQuestions.forEach(q => {
                const category = q.category || 'Information and Ideas';
                if (!categoriesMap[category]) {
                    categoriesMap[category] = [];
                }
                categoriesMap[category].push(q);
            });

            let questionCounter = 0;
            Object.keys(categoriesMap).forEach((categoryTitle, categoryIndex) => {
                const sectionTitle = document.createElement('h3');
                sectionTitle.className = 'text-2xl font-semibold text-gray-700 mt-8 mb-4';
                const romanNumeral = romanNumerals[categoryIndex] || '';
                sectionTitle.textContent = `${romanNumeral}. ${categoryTitle}`;
                testReviewContainer.appendChild(sectionTitle);

                categoriesMap[categoryTitle].forEach(question => {
                    questionCounter++;
                    const questionCard = displayQuestion(question, categoryTitle, true);
                    const questionNumberText = document.createElement('p');
                    questionNumberText.className = 'font-semibold text-lg text-gray-800 mb-2';
                    questionNumberText.textContent = `Вопрос ${questionCounter}.`;
                    
                    const userAndCorrectAnswerDiv = document.createElement('div');
                    userAndCorrectAnswerDiv.className = 'completed-test-card-details';
                    
                    const userAnswerText = document.createElement('p');
                    const isCorrect = question.user_answer === question.correct_answer;
                    const userAnswerString = question.user_answer || 'Нет ответа';
                    userAnswerText.className = `user-answer ${isCorrect ? 'text-green-600' : (question.user_answer ? 'text-red-600' : 'text-gray-500')}`;
                    userAnswerText.innerHTML = `Ваш ответ: <span class="font-bold">${userAnswerString}</span> ${isCorrect ? '(Правильно)' : (question.user_answer ? '(Неправильно)' : '')}`;

                    const correctAnswerText = document.createElement('p');
                    correctAnswerText.className = 'font-medium text-green-600';
                    correctAnswerText.textContent = `Правильный ответ: ${question.correct_answer}`;

                    userAndCorrectAnswerDiv.appendChild(userAnswerText);
                    userAndCorrectAnswerDiv.appendChild(correctAnswerText);
                    
                    // NEW: Display time taken for this specific question
                    if (question.time_taken) {
                        const timeTakenText = document.createElement('p');
                        timeTakenText.className = 'text-sm text-gray-500 mt-1';
                        timeTakenText.textContent = `Время на вопрос: ${question.time_taken.toFixed(2)} сек.`;
                        userAndCorrectAnswerDiv.appendChild(timeTakenText);
                    }


                    testReviewContainer.appendChild(questionNumberText);
                    testReviewContainer.appendChild(questionCard);
                    testReviewContainer.appendChild(userAndCorrectAnswerDiv);
                });
            });
        }
        
        function backToMainScreen() {
            completedTestsScreen.style.display = 'none';
            appContent.style.display = 'block';
            updateMainButtonsState(isSessionActive);
        }

        function deleteCurrentTest() {
            if (!currentReviewingTest) {
                console.error("No test selected for deletion.");
                return;
            }

            showCustomConfirm('Вы уверены, что хотите удалить этот тест? Это действие необратимо.').then(wantsToDelete => {
                if (wantsToDelete) {
                    let completedTests = JSON.parse(localStorage.getItem('satCompletedTests') || '[]');
                    const filteredTests = completedTests.filter(test => test.timestamp !== currentReviewingTest.timestamp);
                    localStorage.setItem('satCompletedTests', JSON.stringify(filteredTests));
                    console.log('Test deleted successfully.');
                    showCompletedTests();
                }
            });
        }

        nextBtn.addEventListener('click', () => {
            const currentCategoryKey = categories[categoriesArray[currentCategoryIndex]];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];
            const isLastQuestion = (currentCategoryIndex === categoriesArray.length - 1 && 
                                   currentQuestionIndex === questionsInCurrentCategory.length - 1);
            if (isLastQuestion) {
                endQuiz();
            } else {
                handleNextQuestion();
            }
        });
        saveAndExitBtn.addEventListener('click', handleSaveAndExit);
        fullTestBtn.addEventListener('click', handleFullTest);
        
        showCompletedTestsBtn.addEventListener('click', showCompletedTests);
        backToTestsBtn.addEventListener('click', () => {
            testsListContainer.style.display = 'block';
            completedTestDetailsContainer.style.display = 'none';
            currentReviewingTest = null;
        });
        backToMainBtn.addEventListener('click', backToMainScreen);
        deleteTestBtn.addEventListener('click', deleteCurrentTest);

        const savedSession = localStorage.getItem('satQuizSession');
        if (savedSession) {
            isSessionActive = true;
        }
        updateMainButtonsState(isSessionActive);
    </script>
</body>
</html>
