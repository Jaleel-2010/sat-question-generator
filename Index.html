<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор вопросов SAT</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            width: 100%; /* Ensure container takes full width on smaller screens */
        }
        .section-title {
            border-bottom: 2px solid #cbd5e1; /* Light gray border */
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .question-card {
            background-color: #ffffff;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0; /* Light border */
        }
        .question-passage {
            font-style: italic;
            color: #4a5568; /* Dark gray text */
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        .question-text {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2d3748; /* Darker gray text */
        }
        .option-item {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0;
            border-radius: 0.5rem;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 1px solid transparent; /* Default transparent border */
        }
        .option-item:hover:not(.disabled) {
            background-color: #f3f4f6; /* Light gray on hover */
        }
        .option-item.correct {
            background-color: #d1fae5; /* Light green for correct answer */
            border-color: #34d399; /* Green border */
            font-weight: 500;
        }
        .option-item.incorrect {
            background-color: #fee2e2; /* Light red for incorrect answer */
            border-color: #ef4444; /* Red border */
            font-weight: 500;
        }
        .option-item.disabled {
            pointer-events: none; /* Disable clicks */
            opacity: 0.8; /* Slightly dim disabled options */
        }
        .explanation {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #e2e8f0;
            font-size: 0.9rem;
            color: #4a5568;
            display: none; /* Hidden by default */
        }
        .login-container {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .login-button {
            width: 100%;
            background-color: #4299e1; /* Blue */
            color: white;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #3182ce; /* Darker blue */
        }
        .error-message {
            color: #ef4444;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #94a3b8; /* Dotted underline for tooltip words */
        }
        .tooltip-text {
            visibility: hidden;
            width: auto; /* Adjust width based on content */
            max-width: 500px; /* Changed: Increased max-width for more words */
            background-color: #333;
            color: #fff;
            text-align: left; /* Changed: Align text to left for multi-line */
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 100; /* Ensure tooltip is on top */
            bottom: 125%; /* Position above the text */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: normal; /* Changed: Allow text wrapping */
            word-wrap: break-word; /* Added: Ensure long words break */
            font-size: 0.85rem;
            pointer-events: none; /* Allow clicks to pass through tooltip when not hovered */
        }
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }
    </style>
</head>
<body>
    <div id="loginScreen" class="login-container">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">Вход в Генератор вопросов SAT</h2>
        <input type="password" id="passwordInput" class="login-input" placeholder="Введите пароль">
        <button id="loginBtn" class="login-button">Войти</button>
        <p id="loginError" class="error-message" style="display: none;">Неверный пароль. Попробуйте снова.</p>
    </div>

    <div id="appContent" class="container" style="display: none;">
        <h1 class="text-4xl font-bold text-center text-gray-800 mb-8">Генератор вопросов SAT (Verbal Section)</h1>

        <div class="mb-6">
            <label for="difficultySelect" class="block text-gray-700 text-sm font-bold mb-2">Выберите уровень сложности:</label>
            <select id="difficultySelect" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline focus:border-blue-500">
                <option value="easy" selected>Облегченный уровень (Easier Module)</option>
                <option value="hard">Усложненный уровень (Harder Module 2)</option>
            </select>
        </div>

        <button id="generateBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 mb-8">
            Сгенерировать вопросы
        </button>

        <div id="loadingIndicator" class="loading-indicator text-center" style="display: none;">
            <!-- Loading indicator content will be dynamically inserted here -->
        </div>

        <div id="questionsContainer" class="space-y-10">
            <!-- Questions will be loaded here -->
        </div>

        <div class="flex flex-col sm:flex-row justify-between gap-4 mt-4">
            <button id="nextBtn" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75" style="display: none;">
                Следующий вопрос
            </button>
            <button id="endTestBtn" class="w-full sm:w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75" style="display: none;">
                Сохранить и выйти
            </button>
        </div>
    </div>

    <script type="module">
        // Import the Google Generative AI library
        import { GoogleGenerativeAI } from 'https://esm.sh/@google/generative-ai';

        // Initialize Firebase (required for Canvas environment, even if not directly used for auth in this example)
        // This ensures __app_id and __firebase_config are handled correctly.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        // Gemini API Key: The API key will be provided at runtime by the environment.
        const apiKey = ""; 

        // Initialize Google Generative AI
        const genAI = new GoogleGenerativeAI(apiKey);
        const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-preview-05-20" });

        const loginScreen = document.getElementById('loginScreen');
        const passwordInput = document.getElementById('passwordInput');
        const loginBtn = document.getElementById('loginBtn');
        const loginError = document.getElementById('loginError');
        const appContent = document.getElementById('appContent');

        const questionsContainer = document.getElementById('questionsContainer');
        const generateBtn = document.getElementById('generateBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const difficultySelect = document.getElementById('difficultySelect');
        const nextBtn = document.getElementById('nextBtn');
        const endTestBtn = document.getElementById('endTestBtn');

        const categories = {
            "Information and Ideas": "information_ideas",
            "Craft and Structure": "craft_structure",
            "Expression of Ideas": "expression_ideas",
            "Standard English Conventions": "standard_english_conventions"
        };

        // Global state to manage questions and current position
        let allGeneratedQuestions = {}; // Stores questions by category (e.g., { 'information_ideas': [q1, q2, q3, q4] })
        let categoriesArray = Object.keys(categories); // Array of category titles for ordered access
        let currentCategoryIndex = 0;
        let currentQuestionIndex = 0;
        let inactivityTimer;
        let timerId; // Variable to hold the timer interval ID
        
        // Hardcoded password for client-side authentication
        const CORRECT_PASSWORD = "Jaleel2010";

        // Inactivity timer variables
        const INACTIVITY_TIMEOUT = 30 * 60 * 1000; // 30 minutes in milliseconds

        // Function to reset the inactivity timer
        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(logoutUser, INACTIVITY_TIMEOUT);
        }

        // Function to save the current session state
        function saveSession() {
            if (Object.keys(allGeneratedQuestions).length > 0) { // Only save if questions have been generated
                const sessionData = {
                    categoryIndex: currentCategoryIndex,
                    questionIndex: currentQuestionIndex,
                    questions: allGeneratedQuestions,
                    difficulty: difficultySelect.value
                };
                localStorage.setItem('satQuizSession', JSON.stringify(sessionData));
                console.log('Session saved.');
            }
        }

        // Function to load a saved session state
        function loadSession() {
            const savedSession = localStorage.getItem('satQuizSession');
            if (savedSession) {
                const sessionData = JSON.parse(savedSession);
                // Using a custom modal dialog instead of alert/confirm
                const confirmation = showCustomConfirm('Обнаружена незавершенная сессия. Хотите продолжить с того места, где остановились?');
                
                return new Promise(resolve => {
                    confirmation.then(resume => {
                        if (resume) {
                            currentCategoryIndex = sessionData.categoryIndex;
                            currentQuestionIndex = sessionData.questionIndex;
                            allGeneratedQuestions = sessionData.questions;
                            difficultySelect.value = sessionData.difficulty; // Set difficulty to saved one
                            console.log('Session loaded. Resuming test.');
                            resolve(true); // Session resumed
                        } else {
                            localStorage.removeItem('satQuizSession'); // Clear if user doesn't want to resume
                            console.log('Saved session discarded.');
                            resolve(false); // Session not resumed
                        }
                    });
                });
            }
            return Promise.resolve(false); // No session found, resolve with false
        }

        // Custom confirmation dialog (replaces alert/confirm)
        function showCustomConfirm(message) {
            return new Promise(resolve => {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
                modalOverlay.innerHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                        <p class="text-lg font-semibold mb-4">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmYes" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Да</button>
                            <button id="confirmNo" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Нет</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalOverlay);

                document.getElementById('confirmYes').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(true);
                });
                document.getElementById('confirmNo').addEventListener('click', () => {
                    document.body.removeChild(modalOverlay);
                    resolve(false);
                });
            });
        }

        // Custom message dialog (replaces alert/confirm)
        function showCustomMessage(message) {
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50';
            modalOverlay.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl text-center max-w-sm mx-auto">
                    <p class="text-lg font-semibold mb-4">${message}</p>
                    <button id="messageOk" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200">OK</button>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            document.getElementById('messageOk').addEventListener('click', () => {
                document.body.removeChild(modalOverlay);
            });
        }

        // Function to log out the user and reset the app state
        function logoutUser(saveCurrent = true) { // Added parameter to control saving
            if (saveCurrent) {
                saveSession(); // Save session before logging out
            } else {
                localStorage.removeItem('satQuizSession'); // Clear if user finishes the test
            }

            // Hide app content and show login screen
            appContent.style.display = 'none';
            loginScreen.style.display = 'block';
            passwordInput.value = ''; // Clear password field
            loginError.style.display = 'none'; // Hide any login error message

            // Reset application state (only if not saving or after saving)
            allGeneratedQuestions = {};
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;

            // Hide all buttons that appear after login/generation
            nextBtn.style.display = 'none';
            endTestBtn.style.display = 'none';
            generateBtn.disabled = false;
            generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            questionsContainer.innerHTML = ''; // Clear questions display
            hideLoading(); // Ensure loading indicator is hidden
            
            // Stop any existing inactivity timer
            clearTimeout(inactivityTimer);
            // Clear the generation countdown timer
            clearInterval(timerId);
        }

        // Event listeners for user activity to reset the timer
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        document.addEventListener('scroll', resetInactivityTimer);

        // Initial check for activity when the page loads
        resetInactivityTimer();

        // Login function
        loginBtn.addEventListener('click', async () => { // Made async to await loadSession
            if (passwordInput.value === CORRECT_PASSWORD) {
                loginScreen.style.display = 'none';
                appContent.style.display = 'block';
                loginError.style.display = 'none';
                
                const sessionResumed = await loadSession(); // Await the promise
                if (sessionResumed) {
                    displayCurrentQuestion(); // Display the resumed question
                    // Ensure buttons are correctly displayed/enabled for resumed session
                    nextBtn.style.display = 'block';
                    endTestBtn.style.display = 'block';
                    nextBtn.disabled = true; // Still disabled until answer is picked
                    nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    // If no session or user chose not to resume, start fresh
                    questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите "Сгенерировать вопросы", чтобы начать новый тест.</p>';
                    generateBtn.style.display = 'block'; // Ensure generate button is visible
                    nextBtn.style.display = 'none';
                    endTestBtn.style.display = 'none';
                }
                resetInactivityTimer(); // Start timer after successful login
            } else {
                loginError.style.display = 'block';
            }
        });

        // Allow pressing Enter key to login
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loginBtn.click();
            }
        });

        // Function to show loading indicator with a countdown timer
        function showLoading() {
            questionsContainer.innerHTML = ''; // Clear previous questions
            
            // Display loading message and countdown timer
            loadingIndicator.innerHTML = `
                <p>Генерация вопросов... это может занять несколько секунд.</p>
                <p id="countdownTimer" class="mt-2 text-sm text-gray-600">Осталось времени: 90 с</p>
                <div class="mt-4">
                    <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-gray-900 mx-auto"></div>
                </div>
            `;
            loadingIndicator.style.display = 'block'; // Make loading indicator visible
            
            // Start the countdown timer
            let timeLeft = 90;
            const timerElement = document.getElementById('countdownTimer');
            timerId = setInterval(() => {
                timeLeft--;
                if (timeLeft >= 0) {
                    timerElement.textContent = `Осталось времени: ${timeLeft} с`;
                } else {
                    clearInterval(timerId);
                }
            }, 1000);

            generateBtn.disabled = true;
            generateBtn.classList.add('opacity-50', 'cursor-not-allowed');
            nextBtn.style.display = 'none'; // Hide next button during generation
            endTestBtn.style.display = 'none'; // Hide end test button during generation
            clearTimeout(inactivityTimer); // Stop timer during generation
        }

        // Function to hide loading indicator
        function hideLoading() {
            loadingIndicator.style.display = 'none'; // Hide loading indicator
            loadingIndicator.innerHTML = ''; // Clear its content
            generateBtn.disabled = false;
            generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            clearInterval(timerId); // Stop the countdown timer
        }

        // Function to generate multiple questions for a given category with exponential backoff
        async function generateQuestionsForCategory(categoryName, categoryKey, difficulty, retries = 0) {
            const MAX_RETRIES = 5;
            const BASE_DELAY_MS = 1000; // 1 second

            let prompt = "";
            let topic = "general knowledge"; // Default topic, can be varied
            const numberOfQuestions = 4; // We want 4 questions per category

            const difficultyModifier = difficulty === 'hard' ? 'challenging' : 'straightforward';
            const wordCountRange = difficulty === 'hard' ? '60-80' : '40-60';
            const analyticalSkill = difficulty === 'hard' ? 'deep analytical skills' : 'basic comprehension';
            const grammaticalNuance = difficulty === 'hard' ? 'complex grammatical error' : 'common grammatical error';
            const rhetoricalEffect = difficulty === 'hard' ? 'advanced rhetorical effect' : 'clear and concise expression';

            // Define the JSON schema for the expected output
            const responseSchema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        passage: { type: "STRING" },
                        question: { type: "STRING" },
                        options: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    label: { type: "STRING" },
                                    text: { type: "STRING" }
                                },
                                required: ["label", "text"]
                            }
                        },
                        correct_answer: { type: "STRING" },
                        explanation: { type: "STRING" },
                        vocabulary: { // New vocabulary field
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    word: { "type": "STRING" },
                                    translation: { "type": "STRING" },
                                    explanation: { "type": "STRING" } // Added explanation for vocabulary
                                },
                                required: ["word", "translation", "explanation"]
                            }
                        }
                    },
                    required: ["passage", "question", "options", "correct_answer", "explanation"]
                }
            };

            // Base prompt structure for generating multiple questions in a JSON array
            const basePrompt = (passageType, questionType, highlightInstruction = '') => `
                Generate ${numberOfQuestions} unique and diverse SAT-style "${categoryName}" questions.
                For each question, provide:
                1. A short, ${difficultyModifier} academic-style passage (${wordCountRange} words) on a distinct topic (e.g., ${passageType}). Ensure variety in topics and phrasing.
                2. A SAT-style "${questionType}" question based on the passage that requires ${analyticalSkill} to answer. Avoid direct repetition of concepts or exact wording from previous questions.
                3. Four answer choices (A, B, C, D), one correct and three plausible distractors.
                4. The correct answer label (e.g., "A").
                5. A brief explanation (1-2 sentences) in Russian for the correct answer.
                6. Identify 4-5 English words from the passage that would likely be rare or complex for a 9th-grade student in a Russian-language secondary school. For each identified word, provide its exact English form (preserving its original casing from the passage), its Russian translation, and a brief Russian explanation of its meaning in a 'vocabulary' array.
                ${highlightInstruction}
            `;

            switch (categoryKey) {
                case "information_ideas":
                    prompt = basePrompt('advanced science, philosophy, nuanced history, art criticism, economic theory', 'Information and Ideas (e.g., main idea, detail, or inference)');
                    break;
                case "craft_structure":
                    prompt = basePrompt('literary analysis, rhetorical strategy, stylistic choices, author\'s intent', 'Vocabulary in Context or Rhetorical Purpose', `
                    For "Craft and Structure" questions, one ${difficulty === 'hard' ? 'nuanced word or phrase with subtle meanings or a complex rhetorical device' : 'common word or phrase with a clear meaning in context'} in the passage should be highlighted by enclosing it in double asterisks (e.g., **word**). Ensure variety in highlighted elements and passage themes.
                    `);
                    break;
                case "expression_ideas":
                    prompt = basePrompt('research methodology, policy analysis, argumentation, essay structure', 'Expression of Ideas (e.g., best revision, addition, or transition to improve ${rhetoricalEffect})');
                    break;
                case "standard_english_conventions":
                    prompt = basePrompt('scientific principles, historical analysis, grammar rules, syntax', 'Standard English Conventions (asking to correct a ${grammaticalNuance})', `
                    For "Standard English Conventions" questions, the part with the grammatical error in the passage should be highlighted by enclosing it in double asterisks. Ensure variety in grammatical errors and passage themes.
                    `);
                    break;
            }

            try {
                // Use generationConfig to enforce JSON schema
                const result = await model.generateContent({
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    }
                });
                
                // The response should now be directly parsable JSON
                const questionsArray = JSON.parse(result.response.text());
                
                // Ensure the response is indeed an array
                if (!Array.isArray(questionsArray)) {
                    throw new Error("API did not return a JSON array of questions.");
                }
                return questionsArray; // Return the array of questions
            } catch (error) {
                console.error(`Error generating questions for ${categoryName} (Difficulty: ${difficulty}):`, error);
                
                // Implement exponential backoff for retries
                if (retries < MAX_RETRIES) {
                    const delay = BASE_DELAY_MS * Math.pow(2, retries) + (Math.random() * 100); // Add jitter
                    console.warn(`Retrying ${categoryName} question generation in ${delay}ms (retry ${retries + 1}/${MAX_RETRIES})...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return generateQuestionsForCategory(categoryName, categoryKey, difficulty, retries + 1);
                }

                let errorMessage = `<p class='text-red-600'>Произошла ошибка при генерации вопросов для категории "${categoryName}" (Уровень: ${difficulty === 'hard' ? 'Усложненный' : 'Облегченный'}). Пожалуйста, попробуйте еще раз.</p>`;

                if (error.message) {
                    if (error.message.includes("403") && error.message.includes("unregistered callers")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: Проблема с доступом к Gemini API (ошибка 403). Пожалуйста, убедитесь, что ваш API-ключ действителен и имеет необходимые разрешения для модели 'gemini-2.5-flash-preview-05-20' в Google Cloud Console.</p>";
                    } else if (error.message.includes("API key not valid")) {
                        errorMessage = "<p class='text-red-600'>Ошибка: API ключ Gemini недействителен. Пожалуйста, убедитесь, что он правильно настроен в вашей среде.</p>";
                    } else if (error.message.includes("JSON")) {
                            errorMessage = `<p class='text-red-600'>Ошибка парсинга JSON для категории "${categoryName}". Модель вернула некорректный формат. Пожалуйста, попробуйте еще раз.</p>`;
                    }
                }
                loadingIndicator.innerHTML = errorMessage; // Display error message in loading indicator area
                hideLoading(); // Hide loading indicator (which now contains the error message)
                return null; // Return null if all retries fail
            }
        }

        // Function to display a single question
        function displayQuestion(questionData, categoryTitle) {
            if (!questionData) return;

            const questionCard = document.createElement('div');
            questionCard.className = 'question-card';

            const categoryHeader = document.createElement('h3');
            categoryHeader.className = 'text-xl font-semibold text-gray-700 mb-4';
            categoryHeader.textContent = categoryTitle;
            questionCard.appendChild(categoryHeader);

            let passageContent = questionData.passage;

            // First, add tooltips for vocabulary words
            if (questionData.vocabulary && Array.isArray(questionData.vocabulary)) {
                questionData.vocabulary.forEach(vocabItem => {
                    // Use a regex with global and case-insensitive flags for whole word match
                    // Escape special characters in the word for regex safety
                    const escapedWord = vocabItem.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi'); 
                    // Use a replacement function to preserve the original casing of the matched word
                    passageContent = passageContent.replace(regex, (matchedWord) => {
                        // Capitalize the first letter and make it bold for the tooltip display
                        const formattedWordInTooltip = `<strong>${matchedWord.charAt(0).toUpperCase() + matchedWord.slice(1)}</strong>`;
                        return `<span class="tooltip-container">${matchedWord}<span class="tooltip-text">${formattedWordInTooltip}: ${vocabItem.translation}: ${vocabItem.explanation}</span></span>`;
                    });
                });
            }

            // Then, apply highlighting for Craft and Structure / Standard English Conventions
            if (categoryTitle === "Craft and Structure") {
                // For "Craft and Structure", the highlighted word is enclosed in double asterisks
                passageContent = passageContent.replace(/\*\*(.*?)\*\*/g, `<span class="font-bold underline">$1</span>`);
            } else if (categoryTitle === "Standard English Conventions") {
                // For "Standard English Conventions", the error part is highlighted by **...**
                passageContent = passageContent.replace(/\*\*(.*?)\*\*/g, `<span class="font-bold underline text-red-600">$1</span>`);
            }

            const passageDiv = document.createElement('div');
            passageDiv.className = 'question-passage';
            passageDiv.innerHTML = passageContent; // Use innerHTML to render bold/underline/tooltips

            const questionTextDiv = document.createElement('div');
            questionTextDiv.className = 'question-text';
            questionTextDiv.textContent = questionData.question;

            const optionsList = document.createElement('div');
            optionsList.className = 'options-list';

            questionData.options.forEach(option => {
                const optionItem = document.createElement('div');
                optionItem.className = 'option-item px-4';
                optionItem.textContent = `${option.label}) ${option.text}`;
                optionItem.dataset.label = option.label;

                // Add event listener to check the answer
                optionItem.addEventListener('click', () => {
                    // Disable all options after a choice is made
                    questionsContainer.querySelectorAll('.option-item').forEach(opt => {
                        opt.classList.add('disabled');
                        opt.style.cursor = 'default';
                    });

                    if (optionItem.dataset.label === questionData.correct_answer) {
                        optionItem.classList.add('correct');
                    } else {
                        optionItem.classList.add('incorrect');
                        // Highlight the correct answer
                        const correctAnswerElement = questionsContainer.querySelector(`[data-label="${questionData.correct_answer}"]`);
                        if (correctAnswerElement) {
                            correctAnswerElement.classList.add('correct');
                        }
                    }

                    // Show the explanation
                    explanationDiv.style.display = 'block';

                    // Enable the next button
                    nextBtn.style.display = 'block';
                    nextBtn.disabled = false;
                    nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');

                    saveSession(); // Save session after each answer
                    resetInactivityTimer(); // Reset timer after user interaction
                });

                optionsList.appendChild(optionItem);
            });

            const explanationDiv = document.createElement('div');
            explanationDiv.className = 'explanation';
            explanationDiv.innerHTML = `<strong>Объяснение:</strong> ${questionData.explanation}`;

            questionCard.appendChild(passageDiv);
            questionCard.appendChild(questionTextDiv);
            questionCard.appendChild(optionsList);
            questionCard.appendChild(explanationDiv);

            questionsContainer.innerHTML = '';
            questionsContainer.appendChild(questionCard);
        }

        // Function to display the current question based on global state
        function displayCurrentQuestion() {
            const currentCategoryTitle = categoriesArray[currentCategoryIndex];
            const currentCategoryKey = categories[currentCategoryTitle];
            const currentQuestions = allGeneratedQuestions[currentCategoryKey];

            if (currentQuestions && currentQuestions.length > currentQuestionIndex) {
                const questionData = currentQuestions[currentQuestionIndex];
                displayQuestion(questionData, currentCategoryTitle);
                
                // Hide next button until an answer is selected
                nextBtn.style.display = 'block';
                nextBtn.disabled = true;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
                endTestBtn.style.display = 'block';
            } else {
                endTest();
            }
        }

        // Event listener for the main generation button
        generateBtn.addEventListener('click', async () => {
            showLoading();
            
            // Reset quiz state
            allGeneratedQuestions = {};
            currentCategoryIndex = 0;
            currentQuestionIndex = 0;

            const difficulty = difficultySelect.value;
            const promises = categoriesArray.map(categoryTitle => {
                const categoryKey = categories[categoryTitle];
                return generateQuestionsForCategory(categoryTitle, categoryKey, difficulty);
            });

            try {
                const results = await Promise.all(promises);

                // Check if any generation failed
                if (results.some(result => !result)) {
                    // An error message has already been displayed by generateQuestionsForCategory, just exit.
                    return;
                }

                // Map results back to the category keys
                categoriesArray.forEach((categoryTitle, index) => {
                    const categoryKey = categories[categoryTitle];
                    allGeneratedQuestions[categoryKey] = results[index];
                });

                hideLoading();
                displayCurrentQuestion();

            } catch (error) {
                console.error("Critical error during batch generation:", error);
                loadingIndicator.innerHTML = '<p class="text-red-600">Произошла критическая ошибка при генерации всех вопросов. Пожалуйста, попробуйте еще раз.</p>';
                hideLoading();
            }
            resetInactivityTimer(); // Reset timer after generation completes
        });

        // Event listener for the "Next Question" button
        nextBtn.addEventListener('click', () => {
            const currentCategoryKey = categories[categoriesArray[currentCategoryIndex]];
            const questionsInCurrentCategory = allGeneratedQuestions[currentCategoryKey];

            // Move to the next question in the current category
            currentQuestionIndex++;

            // Check if we have more questions in the current category
            if (currentQuestionIndex < questionsInCurrentCategory.length) {
                displayCurrentQuestion();
            } else {
                // Move to the next category
                currentCategoryIndex++;
                currentQuestionIndex = 0;

                // Check if there are more categories
                if (currentCategoryIndex < categoriesArray.length) {
                    displayCurrentQuestion();
                } else {
                    // End of the test
                    endTest();
                }
            }
            saveSession(); // Save state after moving to the next question
            resetInactivityTimer(); // Reset timer after user interaction
        });

        // Event listener for the "Save and Exit" button
        endTestBtn.addEventListener('click', () => {
            // Save the session and log out. The user will see a message on login.
            logoutUser(true);
            showCustomMessage('Текущая сессия сохранена. Вы можете войти снова, чтобы продолжить.');
            resetInactivityTimer();
        });

        // Function to end the test and show summary/options
        function endTest() {
            questionsContainer.innerHTML = `
                <div class="question-card text-center">
                    <h3 class="text-2xl font-bold text-gray-800 mb-4">Тест завершен!</h3>
                    <p class="text-lg text-gray-600">Надеемся, вы хорошо поработали.</p>
                    <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                        <button id="startNewTestBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Начать новый тест</button>
                        <button id="logoutTestBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Выйти</button>
                    </div>
                </div>
            `;
            // Hide control buttons
            nextBtn.style.display = 'none';
            endTestBtn.style.display = 'none';

            // Attach event listeners to new buttons in the summary card
            document.getElementById('startNewTestBtn').addEventListener('click', () => {
                localStorage.removeItem('satQuizSession'); // Clear session
                questionsContainer.innerHTML = '<p class="text-center text-gray-600 text-lg">Нажмите "Сгенерировать вопросы", чтобы начать новый тест.</p>';
                generateBtn.style.display = 'block';
            });
            document.getElementById('logoutTestBtn').addEventListener('click', () => {
                logoutUser(false); // Do not save the finished session
            });
        }
    </script>
</body>
</html>
